<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ICDE</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 04 Mar 2024 17:11:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>P2: Extensible Hash Table</title>
      <link>http://example.com/2024/03/05/cmu15445/23fall-p2/</link>
      <guid>http://example.com/2024/03/05/cmu15445/23fall-p2/</guid>
      <pubDate>Mon, 04 Mar 2024 17:11:36 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;task-1---readwrite-page-guards&quot;&gt;Task #1 - Read/Write Page
Guards&lt;/h2&gt;
&lt;p&gt;在Project1的BufferPoolManager中，FetchPage和NewPage这两个API都是直接返</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="task-1---readwrite-page-guards">Task #1 - Read/Write PageGuards</h2><p>在Project1的BufferPoolManager中，FetchPage和NewPage这两个API都是直接返回<code>Page *</code>指针。然后通过程序员手动地调用<code>UnpinPage</code>方法来使得页面会处于Evictable的状态，一旦程序员在使用完页面之后忘记调用<code>UnpinPage</code>方法，可能就会导致这个页面一直处于Unevictable的状态而一直留在BufferPool中。</p><p>为了可以避免这个问题，就采用一个数据结构将<code>Page *</code>指针包裹起来——<code>XXPageGuard</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicPageGuard</span> &#123;<br>    BufferPoolManager *bpm_&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    Page *page_&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    <span class="hljs-type">bool</span> is_dirty_&#123;<span class="hljs-literal">false</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>PageGuard</code>中的API实现：1、当Page离开其作用域，不能再被访问到的时候，<code>PageGuard</code>销毁时自动调用<code>UnpinPage</code>；2、程序员可以主动调用<code>Drop()</code>方法告诉BufferPoolManager，将不再使用这个页面。</p><blockquote><p>🚀注意：移动构造函数和移动赋值函数的区别！</p><p>移动赋值函数，赋值等号左边的PageGuard可能已经初始化，正在guard一个page；</p><p>但是对于移动构造函数则不存在这个问题～</p></blockquote><h2 id="task-2---extendible-hash-table-pages">Task #2 - Extendible HashTable Pages</h2><p>如图所示是一个extendible hash table，它的headerpage的最大深度为2，directory page的最大深度为2，而且bucketpages最后存放两个entry。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20231121130310745.png"alt="extensible hash table" /><figcaption aria-hidden="true">extensible hash table</figcaption></figure><h3 id="hash-table-header-page">Hash Table Header Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Header page format:</span><br><span class="hljs-comment"> *  ---------------------------------------------------</span><br><span class="hljs-comment"> * | DirectoryPageIds(2048) | MaxDepth (4) | Free(2044)</span><br><span class="hljs-comment"> *  ---------------------------------------------------</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>由于最大深度是4，所以在headerpage中实际上最多只能存放16<code>(1&lt;&lt;4)</code>个指向directorypage的page id。</p><h3 id="hash-table-directory-page">Hash Table Directory Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Directory page format:</span><br><span class="hljs-comment"> *  --------------------------------------------------------------------------------------</span><br><span class="hljs-comment"> * | MaxDepth (4) | GlobalDepth (4) | LocalDepths (512) | BucketPageIds(2048) | Free(1528)</span><br><span class="hljs-comment"> *  --------------------------------------------------------------------------------------</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>MaxDepth：directory page的最大深度</li><li>GlobalDepth：当前directory page的全局深度，使用了几个bit位</li><li>LocalDepths：对于其中一个bucket page，使用的bit位数</li><li>BucketPageIds：存放指向bucket page的page id</li><li>下图展示了这些概念的含义：</li></ul><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20231121130354461.png"alt="direcotry page" /><figcaption aria-hidden="true">direcotry page</figcaption></figure><h3 id="hash-table-bucket-page">Hash Table Bucket Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Bucket page format:</span><br><span class="hljs-comment"> *  ----------------------------------------------------------------------------</span><br><span class="hljs-comment"> * | METADATA | KEY(1) + VALUE(1) | KEY(2) + VALUE(2) | ... | KEY(n) + VALUE(n)</span><br><span class="hljs-comment"> *  ----------------------------------------------------------------------------</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Metadata format (size in byte, 8 bytes in total):</span><br><span class="hljs-comment"> *  --------------------------------</span><br><span class="hljs-comment"> * | CurrentSize (4) | MaxSize (4)</span><br><span class="hljs-comment"> *  --------------------------------</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li><code>Remove()</code>的实现：考虑两种：1、在移除了key-value之后，做compression，使得<code>[0, size)</code>中始终都是有效的键值对；2、只移除键值对，不做compression，在<code>[0, max_size_)</code>进行Lookup和Insert（如何判断某个entry是空的？）<ul><li><u>使用的是第一种</u></li><li><font color='green'>后面在优化的时候选择了第二种</font></li></ul></li></ul><h2 id="task-3---extendible-hashing-implementation">Task #3 - ExtendibleHashing Implementation</h2><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20231121130310745.png"alt="extensible hash table" /><figcaption aria-hidden="true">extensible hash table</figcaption></figure><blockquote><p><ahref="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">ExtendibleHashing (Dynamic approach to DBMS) - GeeksforGeeks</a></p></blockquote><p>需要实现三个API：</p><ul><li><code>GetValue</code>：只需要从HeaderPage开始向下检索即可。</li><li><code>Remove</code>：<ul><li>MergeBucket：如果做完Remove操作之后，Page变为空，则需要进行Merge；Merge之后还可能需要进行DirectoryShrink。</li><li><strong>MergeBucket只会出现在<code>local_depth==global_depth</code>的bucket上</strong><ul><li>这个是错误的，导致这个想法的本质原因是GetSplitImageIndex的错误实现！！！</li></ul></li></ul></li><li><code>Insert</code>：需要考虑几种情况<ul><li>由于HashTable初始化完之后，只有一个HeaderPage，所以第一个插入的Key-Value，需要新建DirectoryPage和BucketPage。</li><li>如果BucketPage满了的话，需要进行Bucket Split和DirectoryExpansion。</li></ul></li><li>注意点<ul><li>一次SplitBucket可能不能达到目的，Split之后，要插入的页面可能还是满的，需要while循环直到能够顺利插入</li><li>注意GetValue和Remove方法中取出来的directory_page_id和bucket_page_id不一定是有效的（比如在没有插入任何Key-Value就进行GetValue或者Remove）</li><li>Merge和Split的一样，也不是一次就结束的，在完成一次Merge之后需要判断新的BucketPage的SplitImage是否为空（手册中已经给了提示），同样需要while循环</li></ul></li></ul><h2 id="task-4---concurrency-control">Task #4 - Concurrency Control</h2><p>没有什么特殊的，使用Task#1中的API——FetchPageRead和FetchPageWrtie即可。</p><blockquote><p>✋为什么？首先BufferPoolManager是线程安全的，对于public的三个API：Insert、Remove和GetValue，它们执行的过程都是依次获取HeaderPage、DirectoryPage、BucketPage，然后根据Page上的内容做后续的操作。使用FetchPageRead和FetchPageWrite就是得线程在获取到对应的Page的同时也持有Page上的读锁或者写锁，能够在线程持有的时候做到并发控制。</p></blockquote><h2 id="debug">Debug</h2><p>有三个测试一直过不去</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/3aa3032db801492db525e473629feff1.png"alt="failed testcases" /><figcaption aria-hidden="true">failed testcases</figcaption></figure><h3 id="bug1.-inserttest3">BUG1. InsertTest3</h3><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/437c34e242b7410091495b75db09220d.png"alt="InsertTest3" /><figcaption aria-hidden="true">InsertTest3</figcaption></figure><h3 id="bug2.-recursivemergetest">BUG2. RecursiveMergeTest</h3><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/65ba806f00fd4bce80bc21fc997dec27.png"alt="RecursiveMergeTest" /><figcaption aria-hidden="true">RecursiveMergeTest</figcaption></figure><blockquote><p>估计是漏了一次BucketMerge</p></blockquote><h3 id="bug3.-growshrinktest">BUG3. GrowShrinkTest</h3><blockquote><p>原因应该是在一次SplitBucket时，BufferPoolManager的NewPage失败，返回了空指针。</p></blockquote><h3 id="solve1.-没有理解bucketsplit和bucketmerge的真正过程">Solve1.没有理解BucketSplit和BucketMerge的真正过程</h3><blockquote><p>解决了前两个bug！！</p></blockquote><blockquote><p>💬关于<strong>GetSplitImageIndex</strong>函数，之前的理解有误！</p></blockquote><ul><li>首先是对这个函数的含义理解错误：这个函数返回的是这个bucket在前面split的时候同时产生的另一个bucket的索引。所以这个函数应该是用在BucketMerge中的。<ul><li>之前的理解是，用于计算一个bucket在split后产生的新的bucket的索引。</li></ul></li><li>对bucket-spliting和bucket-merging的理解出现偏差<ul><li>将它们简单地理解成了两个bucket merge或者一个bucketsplit。但是一个bucketpage是会涉及多个bucket_idx的，所以要充分考虑所有指向这个bucketpage的bucket_idx。</li><li>本质上，spliting和merging还是local_depth对应的<code>lsb</code>的收缩和扩展，考虑的应该是hash值的最低有效位，而不应该是索引。</li></ul></li></ul><h3 id="slove2.-没有注意bufferpool的size">Slove2.没有注意BufferPool的size</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/ceb9f678f9f84ed09e7eb7273c0359a1.png" /></p><blockquote><p>🍳考虑一个情况：BufferPool的大小只有3个Page时，如果在插入时需要做BucketSplit，会发生什么？</p><p>进而需要考虑：BufferPool的大小为2（Page）时应该怎么办呢？为1呢？最小能为多少呢？</p></blockquote><ul><li>分析对于每个API，[当前实现]一次最多会使用到多少个Page？<ul><li>GetValue：最多3个——Header、Directory、Bucket各一个。</li><li>Insert：最多4个——Header、Directory、Bucket各一个，如果需要进行BucketSplit，在while循环中会多一个BucketPage。</li><li>Remove：最多3个——Header、Directory、Bucket各一个。</li></ul></li><li>这三个API理论上最少需要多少个Page同时在BufferPool中：<ul><li>GetValue：最少只需要一个；可以依次取出HeaderPage、DirectoryPage、BucketPage。</li><li>Insert：最少需要三个；HeaderPage可以Drop掉。Split的时候需要DirectoryPage和BucketPage，以及一个新建的BucketPage</li><li>Remove：最少需要两个；HeaderPage可以Drop掉。Merge的时候需要DirectoryPage和BucketPage</li></ul></li><li>所以，BufferPool的Size最少为3(Page)时，ExtensibleHashTable才能正常工作。</li></ul><h3 id="bug4.-超时">BUG4. 超时</h3><p>但是这个test仍然无法通过，原因是超时！！</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/362bfec3df554ebea7891ffe6ab1668d.png" /></p><p>似乎是真的太慢了？猜测应该是BucketPage里的Insert和Remove实现太慢了</p><p>改进了BucketPage存储data的方式，添加一个bitmap，bitmap[i]表示array中index为i的键值是否为空，这样最坏情况下只需要<code>[0, max_size_]</code>的遍历。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/698d4605c4d44b2b9a1db8aa2409b165.png" /></p><blockquote><p>好消息：变快了；坏消息：还是超时？！</p></blockquote><hr /><blockquote><p>🙌需要明确的是：修改几千次就需要30s以上，确实是某些地方实现不恰当？</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/1fac9ef504da409985ec6c1de3a32c76.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/477594a624af4dd2a5c769d2b7c8922c.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/b441e26013554d529327e077ba26de98.png" /></p><p>在本地统计了一下每insert/remove and lookup 10keys所需要的时间，可以看到无论是insert还是remove，越往后所需要的时间越多。</p><h2 id="完结">完结！</h2><p>经过接近一个星期的Debug，终于通过了！！</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/7af50da14006455a8ea7f53ba44eb476.png"alt="pass" /><figcaption aria-hidden="true">pass</figcaption></figure><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/9223079ff77142da960bd1b53ba8c951.png" /></p><p>在重新实现了P1的BufferPoolManager之后，顺利通过了P2，在重写的时候优化了LRUKNode里对访问记录的存储：</p><ul><li>之前是：一股脑全部存进<code>history_</code></li><li>优化后：<code>history_</code>中只存放最近的十条访问记录</li></ul><p>下面是优化前后，ExtensibleHashTable运行过程中在LRUKNode的Access中打印出来的日志：优化前，history_中要存放6000左右个访问记录，而优化后只需要10个；而且在1500次左右的Insert-and-Lookup和Remove-and-Lookup的操作中，有18000次对Node的访问操作。</p><p>原因可能是：<code>history_</code>中存储过多的数据，导致内存频繁换页，空间局部性丢失。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/ff1e000ebffa40668b9d12027d2c1657.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/b6784331635644f59a0f5b40e8f5d3b9.png" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CMU-15445/">CMU 15445</category>
      
      
      <category domain="http://example.com/tags/15445/">15445</category>
      
      
      <comments>http://example.com/2024/03/05/cmu15445/23fall-p2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ECMAScript</title>
      <link>http://example.com/2024/03/05/front-end-technology/ECMAScript/</link>
      <guid>http://example.com/2024/03/05/front-end-technology/ECMAScript/</guid>
      <pubDate>Mon, 04 Mar 2024 17:11:36 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;ecmascript&quot;&gt;ECMAScript&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;1 概述&lt;/h2&gt;
&lt;p&gt;ECMA是一个组织，制定了一些标准，然后JS去实现这些标准。&lt;/p&gt;
&lt;p&gt;ES2015兼容性：IE10+、Chrome、FireFox、移动端、Nod</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="ecmascript">ECMAScript</h1><h2 id="概述">1 概述</h2><p>ECMA是一个组织，制定了一些标准，然后JS去实现这些标准。</p><p>ES2015兼容性：IE10+、Chrome、FireFox、移动端、NodeJS</p><p>由于兼容性问题，对于一些版本较低的设备，就需要使用一些方法使得ES6的代码可以运行起来</p><p>1、浏览器打开页面时，对ES6代码进行转换。</p><p>2、先将ES6代码编译为可以被低版本设备接收的代码，再拿去执行。</p><h2 id="letconst和块级作用域">2 let/const和块级作用域</h2><p>之前的JS中只有<code>var</code>可以声明变量，但是<code>var</code>存在一些问题：</p><ol type="1"><li>可以重复声明 =》混乱</li><li>无法限制修改 =》 想要声明常量全凭自觉</li><li>没有块级作用域（只有函数作用域）</li></ol><p>对于第3个问题，下面举一个例子说明</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> arr = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)&#123;<br>        arr.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> i*i;<br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">var</span> resluts = <span class="hljs-title function_">func</span>()<br><span class="hljs-keyword">var</span> f1 = results[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> f2 = resluts[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">var</span> f3 = resluts[<span class="hljs-number">2</span>];<br><br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// 16</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 16</span><br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><p>这个现象就是由于<code>var</code>没有块级作用域引起的。由于函数内部都引用了变量<code>i</code>，但是函数并不是立刻执行的，等到<code>results[0]</code>需要返回的时候，<code>i</code>已经变成3了，所以都输出了<code>9</code>。</p><p>一种解决方法是使用闭包来解决，创建一个匿名函数并立刻执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> arr = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)&#123;<br>        arr.<span class="hljs-title function_">push</span>( <br>            (<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                    <span class="hljs-keyword">return</span> n * n;<br>                &#125;<br>            &#125;)(i)<br>                );<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">var</span> resluts = <span class="hljs-title function_">func</span>()<br><span class="hljs-keyword">var</span> f1 = results[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> f2 = resluts[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">var</span> f3 = resluts[<span class="hljs-number">2</span>];<br><br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 4</span><br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure></blockquote><p>ES6引入<code>let</code>和<code>const</code>关键字，可以有效解决上面三个问题。</p><ol type="1"><li>使用<code>let</code>和<code>const</code>声明变量，不能重复声明</li><li><code>const</code>声明常量，不能修改</li><li><code>let</code>和<code>const</code>都是块级作用域，要解决上面的问题，只要将<code>for(var i...)</code>改成<code>for(let i...)</code>即可。</li></ol><h2 id="解构赋值">3 解构赋值</h2><p>解构赋值是对赋值操作符的扩展，从字面意思上理解，就是把复杂对象拆分开给其他变量赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// a=1, b=2, c=3</span><br><span class="hljs-keyword">let</span> [a, ...b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// a=1, b=[2,3]</span><br><br><span class="hljs-keyword">let</span> &#123;x, y, z&#125; = &#123;<span class="hljs-attr">x</span>:<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-attr">y</span>:<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-attr">z</span>:<span class="hljs-string">&quot;z&quot;</span>&#125;; <span class="hljs-comment">// x=&quot;x&quot;, y=&quot;y&quot;, z=&quot;z&quot;</span><br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/front-end/">front-end</category>
      
      
      <category domain="http://example.com/tags/ES6/">ES6</category>
      
      
      <comments>http://example.com/2024/03/05/front-end-technology/ECMAScript/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Lab2 System Call</title>
      <link>http://example.com/2024/03/05/6.S081/6.S081-lab2-syscall/</link>
      <guid>http://example.com/2024/03/05/6.S081/6.S081-lab2-syscall/</guid>
      <pubDate>Mon, 04 Mar 2024 17:11:35 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;preview&quot;&gt;1. Preview&lt;/h2&gt;
&lt;h3 id=&quot;xv6-book-chap2&quot;&gt;1.1 xv6-book Chap2&lt;/h3&gt;
&lt;p&gt;xv6-book的第二章和lecture3的内容类似，主要介绍了操作系统的组织结构，从物理资源的抽象、用户态</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="preview">1. Preview</h2><h3 id="xv6-book-chap2">1.1 xv6-book Chap2</h3><p>xv6-book的第二章和lecture3的内容类似，主要介绍了操作系统的组织结构，从物理资源的抽象、用户态/内核态、系统调用、微内核/宏内核以及代码层面展开</p><p>xv6-book的4.3、4.4节讲的是如何进行系统调用</p><h3 id="code">1.2 code</h3><p>了解xv6启动过程</p><p><code>_entry.S</code>中将<code>stack0+4096</code>赋给栈指针寄存器<code>sp</code>，使得其指向栈顶，然后<code>call start</code></p><p><code>start</code> =&gt; <code>main</code> =&gt;<code>userinit</code> =&gt; <code>initcode.S</code> =&gt;<code>init.c</code></p><h2 id="system-call-tracing">2 System call tracing</h2><p><code>trace</code>是一个工具，能够记录指定的系统调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">trace 32 grep hello README</span><br>3: syscall read -&gt; 1023<br>3: syscall read -&gt; 966<br>3: syscall read -&gt; 70<br>3: syscall read -&gt; 0<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令的格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">trace [MASK] [OPTIONS...] <span class="hljs-comment"># 其中[MASK]是一个数字n; 如果 (n &gt;&gt; i) &amp; 1 == 1 表示i号系统调用需要trace</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出的形式</span><br>[pid]: syscall &lt;name&gt; -&gt; &lt;return_value&gt;<br></code></pre></td></tr></table></figure><p>首先需要明确的是<code>trace</code>也是一个系统调用，所以就需要大概明白从用户态调用<code>trace</code>工具到内核调用对应的系统调用的过程。</p><p>根据手册的指示大概能够推测出来</p><p>1、在命令行中输入：<code>trace 32 grep hello README</code>后，实际上是执行 /user/trace.c 文件。过程就是 先执行 <code>trace</code>函数，然后再执行后面的命令。</p><p>2、这个 trace 函数是需要在 /user/user.h文件中定义原型的，之后好像就找不到对应的实现了。其实之后的实现是在内核态了，需要先陷入内核，手册中说要在/user/usys.pl 中定义一个 stub: <code>entry("trace")</code>，这个stub会在user/usys.S 生成一段汇编代码：进行系统调用。</p><p>3、其中的<code>ecall</code>指令就会调用 /kernel/syscall.c 中的<code>syscall</code> 函数，执行对应的系统调用函数 sys_<name></p><p>然后就可以开始根据手册的提示写代码了...</p><ol type="1"><li>在 kernel/sysproc.c 中增加 sys_trace() 函数</li><li>要在 proc 结构体中增加一个新的变量存储 trace 的参数</li><li>修改 syscall() 函数来打印 trace 输出</li><li>修改 fork() 函数使得 trace 的参数从父进程拷贝到子进程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在 kernel/sysproc.c 中增加 sys_trace 函数</span><br>uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">if</span>( argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span> )&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// parse the `n` to get which sys_call need to be traced</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>  p-&gt;trace_mask = n;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 修改 kernel/syscall.c 中的 syscall 函数</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7; <span class="hljs-comment">// a7: sys_call number</span><br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    <span class="hljs-comment">// add the trace check</span><br>    <span class="hljs-keyword">if</span>( (( p-&gt;trace_mask &gt;&gt; num ) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> )&#123; <span class="hljs-comment">// need to trace</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sys_call_names[num], p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><blockquote><p>注意第四个测试有可能会超时，需要修改 gradelib.py 文件的第 428 行扩大时间限制</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212319005.png" /></p><h2 id="sysinfo">3 Sysinfo</h2><p>还是实现一个系统调用，在内核填上 <code>struct sysinfo</code>的两个字段，并拷贝回用户空间，主要过程：</p><ol type="1"><li>像<code>trace</code>那样，在对应位置增加系统调用所需的相关信息。</li><li>在 <code>kernel/proc.c</code> 中增加一个统计<code>not UNUSED process</code> 的函数</li><li>在 <code>kernel/kalloc.c</code> 中增加一个统计<code>free memory</code> 的函数</li><li>理解 <code>copyout</code> 函数，在系统调用中将<code>struct sysinfo</code> 从内核空间 拷贝入 用户空间</li></ol><p>核心代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// need to copy the sysinfo struct from kernel space to user space</span><br>uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  uint64 addr;<br>  <span class="hljs-keyword">if</span>( argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> )&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">si</span>;</span><br>  si.nproc = notunusedproc();<br>  si.freemem = freemem();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">if</span>( copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)(&amp;(si)), <span class="hljs-keyword">sizeof</span>(si)) &lt; <span class="hljs-number">0</span> )&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>统计 不是 UNUSED 的 进程数量，只需要遍历 proc 数组即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">notunusedproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NPROC; i++)&#123;<br>    <span class="hljs-keyword">if</span>(proc[i].state != UNUSED)&#123;<br>      num++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><p>统计 free memory，需要读一下 <code>kalloc.c</code> 的代码，会发现 在<code>kalloc</code> 函数中，如果 <code>kmem.freelist</code>不为空的话就会分配一个 <code>PGSIZE</code> 的内存空间，所以只需要统计<code>kmem.freelist</code> 链表长度即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">freemem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>* <span class="hljs-title">r</span> =</span> kmem.freelist;<br>  <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(r)&#123;<br>    r = r-&gt;next;<br>    num++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> num * PGSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212340499.png" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/6-S081-labs/">6.S081-labs</category>
      
      
      <category domain="http://example.com/tags/6-S081/">6.S081</category>
      
      
      <comments>http://example.com/2024/03/05/6.S081/6.S081-lab2-syscall/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Lab1 Utilities</title>
      <link>http://example.com/2024/03/05/6.S081/6.S081-lab1-utils/</link>
      <guid>http://example.com/2024/03/05/6.S081/6.S081-lab1-utils/</guid>
      <pubDate>Mon, 04 Mar 2024 17:11:35 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;搭建lab环境&quot;&gt;1、搭建lab环境&lt;/h3&gt;
&lt;h4 id=&quot;安装工具包&quot;&gt;1、安装工具包&lt;/h4&gt;
&lt;p&gt;使用的是之前跑在 VirtualBox 上的 Ubuntu 虚拟机 版本 20.04.5 TLS&lt;/p&gt;
&lt;p&gt;然后按照&lt;a
href=&quot;http</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="搭建lab环境">1、搭建lab环境</h3><h4 id="安装工具包">1、安装工具包</h4><p>使用的是之前跑在 VirtualBox 上的 Ubuntu 虚拟机 版本 20.04.5 TLS</p><p>然后按照<ahref="https://pdos.csail.mit.edu/6.828/2021/tools.html">官网</a>上的指令下载对应的工具包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></code></pre></td></tr></table></figure><p>完成之后可以测试一下</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212121280.png" /></p><p>然后到<ahref="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">lab页</a>clone相应的代码</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212134633.png" /></p><p>最后执行 <code>make qemu</code>，出现</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212150813.png" /></p><p>即为搭建成功</p><h4 id="gdb调试过程">2、gdb调试过程</h4><p>1、打开两个cmd窗口</p><p>2、其中一个输入：make qemu-gdb</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212206029.png" /></p><p>3、另一个输入：gdb-multiarch kernel/kernel</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212223488.png" /></p><p>4、可以使用gdb命令进行调试了</p><h3 id="book-riscv-chapter-one">2、book-riscv Chapter One</h3><h3 id="sleepeasy">3、sleep（easy）</h3><p>这个函数比较简单，使用系统调用 sleep</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;too few arguments...&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pingpongeasy">3、pingpong（easy）</h3><p>这个函数的实现需要重点理解<code>pipe</code>函数（xv6-book的ChapterOne）</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212234931.png" /></p><p>感性的理解，<code>pipe</code>就是创建了一个管道，使得两个进程之间可以通信（互相读取到对方写的数据）</p><p>实际上，<code>pipe</code>在传入的数组<code>p</code>里存放一个<code>read file descriptor</code>(<code>p[0]</code>)和<code>write file descriptor</code>(<code>p[1]</code>)</p><p>就像管道的一头一尾，从"头部"写入数据，可以从"尾部"读取数据</p><p>而由于<code>fork</code>创建的子进程也会带着这个数组<code>p</code>，从而可以实现父子进程的通信</p><p>（具体细节参见<ahref="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6-book</a>的相应部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-type">char</span> * parent_msg = <span class="hljs-string">&quot;p&quot;</span>;<br>    <span class="hljs-type">char</span> * child_msg  = <span class="hljs-string">&quot;c&quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">2</span>];<br><br>    pipe(p);<br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br>        close(p[<span class="hljs-number">0</span>]);<br>        write(p[<span class="hljs-number">1</span>], child_msg, <span class="hljs-number">1</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        write(p[<span class="hljs-number">1</span>], parent_msg, <span class="hljs-number">1</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>        read(p[<span class="hljs-number">0</span>], buffer, <span class="hljs-number">1</span>);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="primesmoderatehard">4、primes（moderate/hard）</h3><p><code>primes</code>函数是借助<code>pipeline</code>实现了一个素数筛。</p><p>需要好好理解下面<ahref="https://swtch.com/~rsc/thread/">这幅图</a>和上面的<code>pipe</code></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212246450.png" /></p><p>思想：在每个进程中，选取一个素数<code>N</code>（就是通过管道读到的第一个数），然后把所有读到的数中不能被整除<code>N</code>的数继续通过管道写进下一个进程中，而把可以整除的数<code>drop</code>掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> * p)</span>&#123;<br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>    p1[<span class="hljs-number">0</span>] = p[<span class="hljs-number">0</span>]; p1[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>];<br><br>    pipe(p); <span class="hljs-comment">// create the new pipeline connect the it and the it&#x27;s child</span><br><br>    <span class="hljs-type">char</span> num[<span class="hljs-number">1</span>];<br>    close(p1[<span class="hljs-number">1</span>]); <span class="hljs-comment">// close the old write</span><br>    <span class="hljs-keyword">if</span>( read(p1[<span class="hljs-number">0</span>], num, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> )&#123;<br>        <span class="hljs-type">int</span> prime = num[<span class="hljs-number">0</span>]; <span class="hljs-comment">// the first number is the prime</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, prime);<br><br>        <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>            func(p); <span class="hljs-comment">// recursion</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// close the read</span><br>            <span class="hljs-keyword">while</span> ( read(p1[<span class="hljs-number">0</span>], num, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> )&#123;<br>                <span class="hljs-type">int</span> n = num[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(n % prime != <span class="hljs-number">0</span>)&#123;<br>                    write(p[<span class="hljs-number">1</span>], num, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            close(p1[<span class="hljs-number">0</span>]);<br>            close(p[<span class="hljs-number">1</span>]);<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// no data avaliable</span><br>        close(p[<span class="hljs-number">0</span>]);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br><br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>      func(p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> num[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++)&#123;<br>            num[<span class="hljs-number">0</span>] = i;<br>            write(p[<span class="hljs-number">1</span>], num, <span class="hljs-number">1</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="findmoderate">5、find（moderate）</h3><p><code>find</code>函数的实现需要先去学习一下<code>ls</code>函数的实现，主要是学习如何读取目录的，读懂了之后难度不是很大，需要注意一些细节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">// Look at user/ls.c to see how to read directories.</span><br>    <span class="hljs-comment">// Use recursion to allow find to descend into sub-directories.</span><br>    <span class="hljs-comment">// Don&#x27;t recurse into &quot;.&quot; and &quot;..&quot;.</span><br>    <span class="hljs-comment">// Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</span><br>    <span class="hljs-comment">// You&#x27;ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</span><br>    <span class="hljs-comment">// Note that == does not compare strings like in Python. Use strcmp() instead.</span><br>    <span class="hljs-comment">// Add the program to UPROGS in Makefile. </span><br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *dir, <span class="hljs-type">char</span> *file)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br><br>    <span class="hljs-comment">// put the dir_name into the buf</span><br>    <span class="hljs-comment">// buf : dir_name/</span><br>    <span class="hljs-built_in">strcpy</span>(buf, dir);<br>    p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span>( (fd = open(dir, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span> )&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span> )&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, dir);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(st.type != T_DIR)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: %s is not a dir\n&quot;</span>, dir);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// read the every file or dir in the `dir` sequentially</span><br>    <span class="hljs-keyword">while</span>( read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>        <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">char</span> *name = de.name;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// not consider the . and ..</span><br><br>        memmove(p, name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, name);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(st.type == T_DIR)&#123;<br>            find(buf, file);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(name, file) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>        &#125;<br>    &#125;<br>    close(fd);<br>&#125;<br><br><span class="hljs-comment">// find &lt;dir_name&gt; &lt;file_name&gt;</span><br><span class="hljs-comment">// find all the &lt;file_name&gt; in the &lt;dir_name&gt;</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;the arguments is too few...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xargsmoderate">6、xargs（moderate）</h3><p>首先需要知道这个命令是干什么的。</p><blockquote><p>Run COMMAND with arguments INITIAL-ARGS and more arguments read frominput.</p></blockquote><p>总的来说就是<strong>用来跑其他命令的，而参数从输入中读取</strong>。</p><p>从实验手册上的要求和例子来看，实现的是一个只带<code>-n</code>参数且参数值只为1的<code>xargs</code>命令</p><p>这里的<code>-n</code>的意思是执行命令最大能够从输入读取的参数个数，如果<code>-n 1</code>就意味着只能从输入读取一个参数执行命令，所以就意味着会执行多次命令（需要把读取的参数用完）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> hello too | xargs <span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span></span><br>bye hello too<br><span class="hljs-meta prompt_">$</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="hljs-built_in">echo</span> line</span><br>line 1<br>line 2<br><span class="hljs-meta prompt_">$</span><br></code></pre></td></tr></table></figure><p>理解了<code>xargs</code>的作用和实现的细节，就可以开始写代码了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">author: zhhc</span><br><span class="hljs-comment">date:   2022-10-09</span><br><span class="hljs-comment">time-spent: about 3 hours</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> seq_num = MAXARG;  <span class="hljs-comment">// the max_args per cmd</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">exec1</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span>&#123;<br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>        exec(argv[<span class="hljs-number">0</span>], argv);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;too few arguments...&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>]; <span class="hljs-comment">// store the input from the previous cmd</span><br>    <span class="hljs-type">int</span> read_n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> read_total = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// attention: if exits &#x27;\n&#x27;, just a read can not read all</span><br>    <span class="hljs-keyword">while</span>( (read_n = read(<span class="hljs-number">0</span>, buf + read_total, <span class="hljs-number">512</span>)) &gt; <span class="hljs-number">0</span> )&#123;<br>        read_total += read_n; <span class="hljs-comment">// stat the number of input</span><br>    &#125;<br>    <span class="hljs-type">int</span> len = read_total;<br><br>    <span class="hljs-comment">// switch all the &#x27;\n&#x27; to &#x27; &#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>) buf[i] = <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> cmd_ptr = <span class="hljs-number">1</span>; <span class="hljs-comment">// the ptr to cmd</span><br>    <span class="hljs-type">bool</span> is_set_n = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// set the max args</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-n&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>        is_set_n = <span class="hljs-literal">true</span>;<br>        cmd_ptr = <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span>* cmd_argv[MAXARG]; <span class="hljs-comment">// the cmd argv</span><br>    <span class="hljs-comment">// put the arg into the cmd_argv</span><br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cmd_ptr; i &lt; argc; i++) &#123;<br>        <span class="hljs-type">char</span> *arg = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(argv[i])+<span class="hljs-number">1</span>); <span class="hljs-comment">// attention: must use malloc, put the data in heap</span><br>        <span class="hljs-comment">// if use char arg[MAXARG] will cause the error</span><br>        <span class="hljs-built_in">strcpy</span>(arg, argv[i]);<br>        cmd_argv[idx] = arg;<br>        idx ++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(is_set_n)&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> arg[MAXARG];<br>        <span class="hljs-built_in">memset</span>(arg, <span class="hljs-number">0</span>, MAXARG); <span class="hljs-comment">// clear the space</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// can spilt out a arg</span><br><br>                arg[index++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                cmd_argv[idx++] = arg;<br><br>                <span class="hljs-comment">// run</span><br>                exec1(cmd_argv);<br><br>                index = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">memset</span>(arg, <span class="hljs-number">0</span>, MAXARG); <span class="hljs-comment">// clear the space</span><br><br>                idx --;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            arg[index ++] = buf[i];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// should spilt the args with &#x27; &#x27;</span><br>        <span class="hljs-comment">// and put them into cmd_argv sequentially</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-type">char</span>* add_arg = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(i - prev);<br>                <span class="hljs-built_in">memcpy</span>(add_arg, buf+prev, i - prev);<br>                prev = i+<span class="hljs-number">1</span>; <span class="hljs-comment">// attention</span><br>                cmd_argv[idx++] = add_arg;<br>            &#125;<br>        &#125;<br>        exec1(cmd_argv);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>记录一个小问题</p><p>发生在将argv里的参数拷贝到cmd_argv的过程中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>    <span class="hljs-type">char</span> agr[<span class="hljs-number">32</span>]; <span class="hljs-comment">// 每次分配到的地址都是一样的！！！</span><br>    cmd_argv[idx ++] = <span class="hljs-built_in">strcpy</span>(arg, argv[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>数组空间是分配在栈中的，而且一次迭代之后空间失效，再次分配时就会分配相同的地址空间，导致cmd_argv中的指针值都是一样的，然后strcpy就是在不断地改变那块地址中的内容。</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/6-S081-labs/">6.S081-labs</category>
      
      
      <category domain="http://example.com/tags/6-S081/">6.S081</category>
      
      
      <comments>http://example.com/2024/03/05/6.S081/6.S081-lab1-utils/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>记录一次重装Ubuntu双系统</title>
      <link>http://example.com/2023/11/01/Linux/%E9%87%8D%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</link>
      <guid>http://example.com/2023/11/01/Linux/%E9%87%8D%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</guid>
      <pubDate>Tue, 31 Oct 2023 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;原因是在写ics2023的pa2时，遇到了问题始终无法解决，由于当时的系统版本是ubuntu21.04，而手册是ubuntu22.04，所以认为可能是系统版本的问题，于是想要更换系统版本。按理说只需要升级一下Ubuntu即可，但是尝试了若干种方式都无法成功升级，于是只能删掉</description>
        
      
      
      
      <content:encoded><![CDATA[<p>原因是在写ics2023的pa2时，遇到了问题始终无法解决，由于当时的系统版本是ubuntu21.04，而手册是ubuntu22.04，所以认为可能是系统版本的问题，于是想要更换系统版本。按理说只需要升级一下Ubuntu即可，但是尝试了若干种方式都无法成功升级，于是只能删掉原有的ubuntu21.04，装上新的ubuntu22.04.</p><h2 id="删除双系统">删除双系统</h2><blockquote><p><ahref="https://blog.csdn.net/yldmkx/article/details/103949640">Windows和ubuntu双系统“彻底”删除ubuntu系统_ubuntu系统删除microsoft基本数据-CSDN博客</a></p></blockquote><h2 id="安装双系统">安装双系统</h2><p>绝世好文，两次安装双系统都是参考这篇文章</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/407175785">Win10 下安装Ubuntu21.04桌面版 双系统 并设置win10为默认启动系统 详细教程</a></p></blockquote><p>不过在进入系统启动菜单的时候，按<code>F2</code>或者<code>F12</code>都没用，结果是关机之后戳耳机孔边上的小洞才会进入系统启动菜单。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/16988307940501.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="配置新环境">配置新环境</h2><blockquote><p>遇到了两个比较棘手的问题</p></blockquote><h3 id="apt-get-install的unmet-dependencies-error">apt-getinstall的Unmet Dependencies Error</h3><p>在使用<code>apt-get install</code>安装依赖包的时候，总是会出现<code>unmeet dependencies</code>。就是要安装这个包，这个包的依赖包没有装上，所以这个包装不上。</p><blockquote><p>https://appuals.com/fix-unmet-dependencies-error-ubuntu/</p></blockquote><p>最后是使用<code>aptitude</code>这个工具，它会针对出现的依赖问题，给出解决方案，最后能够成功装上依赖包。</p><h3 id="git的openssl编译">git的openssl编译</h3><blockquote><p>gnutls_handshake() failed: The TLS connection was non-properlyterminated</p></blockquote><p>经常会在装完ubuntu系统之后<code>git clone</code>出现这种错误，无论是虚拟机还是真机。一查解决方案，大都是不痛不痒的<code>git config</code>一些东西。然而真正的原因是<code>gnutls</code>这个包的效果不够好，应该换成<code>openssl</code>。</p><blockquote><p><ahref="https://askubuntu.com/questions/186847/error-gnutls-handshake-failed-when-connecting-to-https-servers">"error:gnutls_handshake() failed" when connecting to https servers</a></p></blockquote><p>那么如何用openssl重新编译git呢？有大佬制作好了<code>shell</code>脚本放在了Github上</p><blockquote><p>https://github.com/paul-nelson-baker/git-openssl-shellscript</p></blockquote><p>但是，由于前面<code>apt-get install</code>的问题，需要对脚本进行一些修改，即<code>apt-get</code>-&gt;<code>aptitude</code>，并且去掉后面<code>-y</code>，这样就能在安装依赖包的时候选择想要的解决方案（因为<code>aptitude</code>大部分情况下默认解决方案是啥都不干）</p><blockquote><p>所幸，安装完新系统之后，问题得到了解决！</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux/">Linux</category>
      
      
      <category domain="http://example.com/tags/linux/">linux</category>
      
      
      <comments>http://example.com/2023/11/01/Linux/%E9%87%8D%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>为git添加ssh</title>
      <link>http://example.com/2023/03/08/others/%E5%A2%9E%E5%8A%A0ssh/</link>
      <guid>http://example.com/2023/03/08/others/%E5%A2%9E%E5%8A%A0ssh/</guid>
      <pubDate>Tue, 07 Mar 2023 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;应项目要求，需要为&lt;code&gt;Git&lt;/code&gt;配置&lt;code&gt;SSH&lt;/code&gt;密钥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;生成ssh密钥&quot;&gt;生成SSH密钥&lt;/h3&gt;
&lt;figure class=&quot;highlight s</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>应项目要求，需要为<code>Git</code>配置<code>SSH</code>密钥</p></blockquote><h3 id="生成ssh密钥">生成SSH密钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 2048 -C &quot;201250150@smail.nju.edu.cn&quot;<br></code></pre></td></tr></table></figure><p>输入命令后，会在对应的<code>.ssh</code>文件夹下生成两个文件<code>id_rsa</code>和 <code>id_rsa.pub</code></p><h3 id="将公钥拷贝到gitlab账户">将公钥拷贝到GitLab账户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub | clip # 将公钥拷贝至剪贴版<br></code></pre></td></tr></table></figure><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230308104505040.png" /></p><h3 id="配置git">配置Git</h3><blockquote><p>注意对Git版本有要求：&gt;= 2.34.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git update-git-for-windows<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config [--global] gpg.format ssh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config [--global] user.signingkey ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h3 id="使用ssh密钥签署提交">使用ssh密钥签署提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -S -m &quot;My commit msg&quot; # -S 表示签署提交时使用标志<br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2023/03/08/others/%E5%A2%9E%E5%8A%A0ssh/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Web前端复习</title>
      <link>http://example.com/2023/02/22/nju-course-review-notes/web%E5%89%8D%E7%AB%AF/</link>
      <guid>http://example.com/2023/02/22/nju-course-review-notes/web%E5%89%8D%E7%AB%AF/</guid>
      <pubDate>Tue, 21 Feb 2023 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;密码加密&quot;&gt;密码加密&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可逆加密算法：加密后可以解密得到密码原文&lt;/li&gt;
&lt;li&gt;对称加密：加密、解密使用相同的密钥
&lt;ul&gt;
&lt;li&gt;加密速度快；不安全；AES；DES&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;非对称加密</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="密码加密">密码加密</h2><ul><li>可逆加密算法：加密后可以解密得到密码原文</li><li>对称加密：加密、解密使用相同的密钥<ul><li>加密速度快；不安全；AES；DES</li></ul></li><li>非对称加密：加密使用公钥、解密使用私钥<ul><li>安全性高；加密时间长；RSA；DSA</li></ul></li><li>不可逆加密算法：加密后不能反向解密<ul><li>存储密码等用户敏感信息；MD5；SHA</li></ul></li></ul><h2 id="前端鉴权">前端鉴权</h2><blockquote><p>认证、授权、鉴权和权限控制是一个前后依次发生、上下游的关系</p><p>1.认证 =》2.授权=》3.鉴权=》4.权限控制</p></blockquote><ul><li>认证：根据声明者所特有的识别信息确认声明者的身份</li><li>授权：资源所有者赋予执行者指定范围的资源操作权限，以便对资源的相关操作</li><li>鉴权：对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程</li><li>权限控制：将可执行的操作定义为权限列表并判断操作是否允许/禁止</li></ul><h3 id="http基本鉴权">HTTP基本鉴权</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219161544843.png" /></p><ul><li>优点：简单</li><li>缺点：不安全（用户名密码裸露）；无法主动撤销</li><li>使用场景：对安全要求不高的网络（内部网络）</li></ul><h3 id="session-cookie鉴权">Session-Cookie鉴权</h3><blockquote><p>服务端的Session和浏览器端的Cookie</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219161844528.png" /></p><ul><li>优点：Cookie简单易用；Session相较于JWT方便管理；后端操作即可</li><li>缺点：依赖Cookie（禁用就会失效）；Cookie不安全；Session增大服务端开销；</li><li>使用场景：中大型的网站</li></ul><h3 id="token">Token</h3><blockquote><p>访问资源接口需要的资源凭证</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219162244318.png" /></p><ul><li>优点：服务端无状态化、可扩展性好；支持APP移动端设备；不需要Cookie，安全性好，支持跨程序调用；</li><li>缺点：需要前后端配合；占带宽（比sid更大）；有效期短；性能问题（需要对token加密解密）</li></ul><h3 id="refresh-token">Refresh Token</h3><blockquote><p>用来获取Access Token，有效期比Access Token长一些</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219163335945.png" /></p><h3 id="jwt鉴权">JWT鉴权</h3><blockquote><p>对用户信息组成JSON对象然后进行加密签名实现授权验证的方案</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219163533415.png" /></p><ul><li>优点：不需要在服务端保存会话信息</li><li>缺点：加密问题；到期问题（无法废止Token或更改Token）</li></ul><h3 id="cookie和session">Cookie和Session</h3><ul><li>安全性：Cookie保存在客户端，可以被随意篡改</li><li>存取值的类型：Cookie只支持字符串数据；Session可以存放任意数据</li><li>有效期不同：Cookie可以设置长时间保持；Session一般失效时间短</li><li>存储大小不同：Cookie保存数据不能超出4K</li></ul><h3 id="token和session">Token和Session</h3><ul><li>存储位置不同：Token存储在前端，Session存储在后端</li><li>安全性：Token安全性更好，因为每个请求都有签名</li><li>支持性不同：Session-Cookie认证需要浏览器的Cookie机制实现；Token验证机制丰富了客户端类型</li></ul><h3 id="登录方案">登录方案</h3><ul><li>单点登录（SSO: Single SignOn）登录一次就可以访问其他相互信任的应用系统</li><li>OAuth2.0：允许用户授权第三方网站访问他们存储在另外的服务提供者的信息，而不需要将用户名和密码提供给第三方网站</li><li>联合登录和信任登录</li><li>唯一登录：禁止多人同时登录统一账号</li><li>扫码登录</li><li>一键登录：短信验证码</li></ul><h2 id="前端性能优化">前端性能优化</h2><blockquote><p>要点，常用术语，浏览器渲染机制，性能分析方法，最佳实践</p></blockquote><blockquote><p><strong>看PPT</strong></p></blockquote><h3 id="浏览器页面渲染机制">浏览器页面渲染机制</h3><ul><li>DNS查询 =》TCP握手 =》TLS（Transport Layer Security）协商=》TCP慢启动（14KB规则）</li><li>第一步：处理HTML标记并构造DOM树，HTML解析涉及到 tokenization和树的构造（<code>&lt;script&gt;</code>标签会阻塞HTML的解析）</li><li>第二步：处理CSS并构建CSSOM树，遍历CSS中每个规则集，根据选择器创建具有父、子和兄弟关系的节点数</li><li>第三步：将DOM和CSSOM组合成一个Render树，计算样式树或渲染树从DOM树的根节点开始构建，遍历每个可见节点</li><li>第四步：在渲染树上运行布局以计算每个节点的几何体<ul><li>第一次确定节点大小和位置称为布局；随后对节点大小和位置的重新计算称为回流</li></ul></li><li>最后一步：将各个节点绘制到屏幕上，将在布局阶段计算的每个框转换为屏幕上的实际像素</li><li>TTI（Time To Interactive）第一个请求导致DNS和SSL 到 页面可交互所用的时间</li><li>关键渲染路径（Critical RenderPath）优化策略使浏览器能够通过确定优先加载的资源以及资源加载的顺序来尽可能快地加载页面</li></ul><h3 id="性能优化">性能优化</h3><ul><li>延迟与带宽：传播/传输/处理/排队延迟</li><li>web性能要点<ul><li>延迟和带宽对web性能的影响</li><li>传输协议（TCP）对HTTP的影响</li><li>HTTP协议自身的缺陷</li><li>Web应用的发展趋势及性能需求</li><li>浏览器局限性和优化思路</li></ul></li><li>性能要素：计算、渲染、网络<ul><li>三个任务：获取资源、页面布局和渲染、js执行</li><li>更多带宽并不重要；延迟是性能瓶颈</li></ul></li><li>性能监控指标<ul><li>首屏时间</li><li>用户可交互时间</li><li>总下载时间</li><li>FP（First Paint）、FCP（First Content Paint）（DOM内容）、FMP（FirstMeaningful Paint）（关键元素）</li></ul></li><li>浏览器优化<ul><li>基于文档的优化：提前获取资源，提前解析</li><li>推测性优化：预先解析DNS、预先连接可能的目标</li></ul></li><li>（<strong>最佳实践</strong>）两个准则<ul><li>消除或减少不必要的网络延迟</li><li>将需要传输的数据压缩至最少</li></ul></li><li>性能准则<ul><li>减少DNS查找</li><li>重用TCP连接</li><li>减少HTTP重定向</li><li>使用CDN（Content Distributed Network 内容分发网络）</li><li>去掉不必要的资源</li></ul></li><li>其他准则<ul><li>在客户端缓存资源</li><li>传输压缩过的内容</li><li>消除不必要的请求开销</li><li>并行处理请求和响应</li><li>针对协议版本采取优化措施<ul><li>针对HTTP1.x优化建议<ul><li>采用HTTP管道</li><li>采用域名分片</li><li>打包资源以减少HTTP请求</li><li>嵌入小资源</li></ul></li><li>针对HTTP2的优化<ul><li>少发数据，减少请求，减少传输数据量和不必要网络延迟，调整资源供给</li><li>每个来源一个链接，去掉不必要资源打包，利用服务器推送</li></ul></li></ul></li></ul></li></ul><h2 id="http">HTTP</h2><blockquote><p>基本原理、为何演进、常见的请求方法、头域、状态码</p></blockquote><h3 id="头域">头域</h3><p>由主键/值对组成，描述客户端或者服务器的属性、被传输的资源以及应该实现的连接</p><p>四种不同类型的头标</p><ul><li>通用头标：即可用于请求，也可以用于响应，是作为一个整体而不是特定资源与事务相关联</li><li>请求头标：允许客户端传递关于自身的信息和希望的响应形式</li><li>响应头标：服务器用于传递自身信息的响应</li><li>实体头标：定义被传送资源的信息，即可用于请求，也可以用于响应</li></ul><h3 id="状态码">状态码</h3><ul><li>1xx：信息响应</li><li>2xx：成功响应</li><li>3xx：重定向消息<ul><li>301：永久重定向</li></ul></li><li>4xx：客户端错误响应<ul><li>400：请求错误</li><li>401：未认证</li><li>403：未授权禁止访问</li><li>404：找不到</li></ul></li><li>5xx：服务端错误响应<ul><li>500：服务器内部错误</li></ul></li></ul><h3 id="请求方法">请求方法</h3><ul><li>GET：从服务器获取URL对应资源</li><li>POST：修改URL对应资源</li><li>PUT：修改或创建资源</li><li>DELETE：删除资源</li><li>HEAD：获取少量信息</li></ul><h3 id="http的演进">HTTP的演进</h3><ul><li>HTTP/1.x：报文有一些性能上的缺点：Header无法压缩；相似header的报文重复传输；无法复用</li><li>HTTP/2：通过启用完整的请求和响应多路复用来减少延迟，通过有效压缩HTTP标头字段来最小化协议开销，并增加对请求优先级和服务器推送的支持</li><li>HTTP/3：TCP队头阻塞问题、TCP握手时长问题、移动场景的网络切换成本</li></ul><h3id="影响http常见的与tcp相关的延迟">影响HTTP常见的与tcp相关的延迟</h3><ul><li>TCP连接握手</li><li>TCP慢启动拥塞控制</li><li>Nagle的数据聚合算法</li><li>TCP用于承载确认的延迟确认算法</li><li>TIME_WAIT的延迟和端口耗尽</li></ul><h3 id="http1.x的连接管理">HTTP/1.x的连接管理</h3><ul><li>短连接：每一次HTTP请求之前都会有一次TCP握手</li><li>长连接：长连接会保持一段时间</li><li>HTTP流水线：在同一条长连接上发出连续的请求，而不用等待应答返回</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219174647488.png" /></p><h2 id="node.js">Node.js</h2><blockquote><p>客户端与服务端编程、静态网页和动态网页、Nodejs优势/特点/应用/原理，事件驱动模型，同步IO和异步IO，阻塞与非阻塞，模块，ES6与CommonJS模块</p></blockquote><h3 id="静态网页与动态网页">静态网页与动态网页</h3><ul><li>静态网页：写死的HTML文件，每次通过url获取到的都是一样的页面，可以直接在浏览器上显示</li><li>动态网页：由程序/脚本生成HTML文件然后返回给前端，每次获取的都可能是不同的页面，不能直接在浏览器上显示</li></ul><h3 id="客户端与服务端编程">客户端与服务端编程</h3><ul><li>客户端编程：JS编程？所见即所得？（及时展示反馈）<ul><li>好处：（不用和服务端交互）效率高、事件驱动、平台独立性</li></ul></li><li>服务端编程：使用web编程语言之一编写的程序。定制用户体验<ul><li>好处：安全性、兼容性、功能全</li></ul></li></ul><h3 id="node.js概述">Node.js概述</h3><ul><li>Node.js是一个开源的、跨平台的运行时环境。开发人员可以使用JavaScript创建各种服务端工具和应用程序</li><li>特点：事件驱动、异步IO框架</li><li>应用：网站、即时聊天、前端构建工具、命令行工具、反向代理<ul><li>适用于数据密集型实时程序（DIRT data-intensivereal-time）IO密集型</li></ul></li><li>优势：卓越的性能表现；切换成本低；可移植；活跃的社区</li></ul><h3 id="事件驱动模型">事件驱动模型</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219182900853.png" /></p><ul><li>维护了一个 event queue 事件队列</li><li>有一个 event loop 事件循环不断读取 event queue 中的事件<ul><li>对于非阻塞事件，处理完调用回调函数向上一层返回结果</li><li>对于阻塞事件，委托后台线程池处理；完成后将执行结果与提供的回调函数一起再被放入事件队列中；当eventloop 再次读到这个事件时会执行回调函数，将结果返回给上一层。</li></ul></li></ul><h3 id="同步io与异步io">同步IO与异步IO</h3><table><thead><tr class="header"><th>同步IO（阻塞式）</th><th>异步IO（非阻塞式）</th></tr></thead><tbody><tr class="odd"><td>利用多线程提供吞吐量</td><td>单线程即可实现高吞吐量</td></tr><tr class="even"><td>通过时间片分割和线程调度利用多核CPU</td><td>通过功能划分利用多核CPU</td></tr><tr class="odd"><td>需要操作系统调用多线程使用多核CPU</td><td>可以将单进程绑定到单核CPU</td></tr><tr class="even"><td>难以充分利用CPU资源</td><td>可以充分利用CPU资源</td></tr><tr class="odd"><td>内存轨迹大，数据局部性弱</td><td>内存轨迹小，数据局部性强</td></tr><tr class="even"><td>符合线性编程思维</td><td>不符合传统编程思维</td></tr></tbody></table><h3 id="阻塞与非阻塞">阻塞与非阻塞</h3><ul><li>阻塞是指在Node.js程序中，其他JS语句的执行，必须等待一个非JS操作完成，因为当阻塞发生时，事件循环无法继续运行JS</li><li>非阻塞是指程序先注册一个回调函数（callback），当操作完成后，触发该回调函数执行后续逻辑，但是不阻碍后面代码的执行。</li></ul><h3 id="es6与commonjs模块">ES6与CommonJS模块</h3><blockquote><p>模块：两种模块，不兼容；esm和cjs</p></blockquote><ul><li>语法<ul><li>CommonJS模块使用<code>require()</code>加载和<code>module.exports</code>输出</li><li>ES6模块使用<code>import</code>和<code>export</code></li></ul></li><li>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用</li><li>CommonJS模块是运行时加载，ES6模块是编译时输出接口</li><li>循环加载<ul><li>对于CommonJS：加载时执行，脚本在<code>require</code>的时候就会全部执行<ul><li>require全部执行；加载多少输出多少；循环加载只输出执行部分</li></ul></li><li>对于ESM：<u>遇到模块加载命令只是生成一个引用</u>，等真的需要再去模块里取值</li></ul></li></ul><h2 id="express">Express</h2><blockquote><p>路由、中间件、模板引擎</p></blockquote><h3 id="express概述">express概述</h3><ul><li>最流行的node web框架</li><li>特点：精简、灵活</li><li>express不是固执己见的，是高度包容的</li></ul><h3 id="路由">路由</h3><ul><li>把需要支持的请求（以及请求URL中包含的任何信息）转发到适当的控制器函数</li><li>路由用于确定应用程序如何响应对特定端点的客户机请求，包括一个URI（或路径）和一个特定的HTTP请求方法（GET、POST等）</li><li>每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行</li><li>路由路径<ul><li>可以是正则表达式</li><li>可以包含参数：<code>/users/:userId</code> =》可以匹配<code>/users/11</code> 的URL，其中userId保存在req.params对象中。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;GET it&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="中间件">中间件</h3><ul><li>中间件是一种功能的封装方式，具体来说就是封装在程序中处理HTTP请求的功能</li><li>中间件是在管道中执行的，通过<code>app.use</code>向管道中插入中间件</li><li>中间件中要调用<code>next()</code>，将控制权传递给下一个中间件</li><li>中间件的装入顺序十分重要</li></ul><h3 id="模板引擎">模板引擎</h3><p>选用模板引擎需要考虑的因素</p><ul><li>进入生产状态的时间</li><li>流行度和活跃度</li><li>风格</li><li>性能/渲染时间</li><li>功能</li></ul><h2 id="javascript">JavaScript</h2><blockquote><p>基本概念，基本语法等、DOM、BOM、事件、事件驱动编程、事件处理模型、作用域、词法作用域、作用域链、闭包、提升、最佳实践、正则、原型对象、class、this、框架优缺点</p></blockquote><h3 id="js概述">JS概述</h3><ul><li>一种脚本语言，由js解释器/引擎计算和执行</li><li>解释型语言，更加宽松的语法和规则，关键类型是函数，包含在网页中</li><li>基本语法：略</li></ul><h3 id="dom和bom">DOM和BOM</h3><ul><li>DOM：文档对象模型，是获取、更改、添加或者删除HTML元素的标准；<ul><li>通过该模型，js可以获取创建动态html所需的所有功能</li></ul></li><li>BOM：浏览器对象模型<ul><li>通过该模型，赋予了js程序与浏览器交互的能力</li></ul></li><li>window对象：document对象、location对象（当前URL信息）、navigator对象（浏览器信息）、screen对象、history对象，还可以通过window.cookie使用cookie</li></ul><h3 id="事件">事件</h3><ul><li>使web应用程序的响应性、动态性和交互性更强，一般通过回调函数处理</li><li>允许脚本去响应用户与网页上元素的交互，允许通过事件进行对页面的修改</li></ul><h3 id="事件驱动编程">事件驱动编程</h3><ul><li>事件驱动编程是一种编程范式，其中程序流由事件决定，执行特定的操作来响应用户输入</li><li>在事件驱动的应用程序中，通常有一个主循环监听事件，然后在检测到其中一个事件时触发回调函数</li><li>事件处理程序可用于处理和验证用户输入、用户操作和浏览器操作</li></ul><h3 id="事件处理模型">事件处理模型</h3><ul><li>DOM0：内联模型：事件处理程序作为<u>元素的属性</u>添加；传统模型：可以通过脚本（js）添加/删除事件处理程序</li><li>DOM2：通过<code>addEventListener</code>和<code>removeEventListener</code>来添加和删除事件</li><li>DOM事件流：捕获阶段 =》目标阶段 =》冒泡阶段（处理事件）</li></ul><h3 id="作用域">作用域</h3><ul><li>作用域是当前执行上下文，可见或者可被访问的值和表达式，即有权访问的变量集合<ul><li>全局作用域</li><li>模块作用域</li><li>函数作用域</li><li>块级作用域（const和let）</li></ul></li></ul><h3 id="闭包">闭包</h3><p>闭包是一个函数及其捆绑的周边环境状态的引用的组合；闭包让开发者可以从内部函数访问外部函数的作用域，会随着函数的创建而创建</p><p><strong>词法作用域</strong>：（静态作用域）根据源代码中声明变量的位置来确定该变量在何处可用</p><p>闭包的应用场景：</p><ul><li>实现私有成员</li><li>保护命名空间</li><li>避免污染全局变量</li><li>变量需要长久驻留在内存</li></ul><h3 id="作用域链">作用域链</h3><p>作用域链包含了一个函数被创建的作用域中对象的集合，决定了哪些数据可以被函数访问，用于在处理标识符的时候进行变量查询</p><h3 id="提升">提升</h3><ul><li>可以先使用变量，再进行声明而不会引发异常，感觉像是 声明被提升到了使用语句的前面</li><li>只有使用var声明的变量才能被提升</li><li>类和函数表达式不能被提升，函数声明可以被提升</li><li>let先声明后使用会引起暂时性死区（TDZ）</li></ul><h3 id="最佳实践">最佳实践</h3><ul><li>避免全局变量，始终声明局部变量</li><li>使用严格模式</li><li>在顶部声明，声明变量时初始化</li><li>使用<code>===</code>比较</li><li>减少循环活动</li></ul><blockquote><p>严格模式：<code>use strict</code></p><p>消除js语法的一些不合理、不严谨之处，减少一些怪异行为；消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度；为未来新版本的js做好铺垫</p></blockquote><h3 id="框架优缺点">框架优缺点</h3><ul><li>优点<ul><li>封装了复杂困难的代码</li><li>加快开发速度，更快完成项目</li><li>专注于产品内容的价值，而不是实现过程</li><li>让合作更简单</li></ul></li><li>缺点<ul><li>如果遇到问题需要钻研框架</li><li>框架更新快速，升级更新是问题</li></ul></li></ul><h3 id="正则表达式">正则表达式</h3><ul><li>以<code>/</code>开始和结束</li><li><code>.</code>匹配单一字符</li><li><code>i</code>：对大小写不敏感</li><li><code>|</code>选择、<code>()</code>子表达式、<code>^</code>匹配开始、<code>$</code>匹配结束、<code>\</code>转义</li><li><code>*</code>：0+次；<code>+</code>：1+次；<code>?</code>：0/1次</li><li><code>&#123;min,max&#125;</code>：min-max次</li><li><code>[]</code>：字符集</li></ul><h3 id="class">class</h3><blockquote><p>JS中声明类的关键字</p></blockquote><h3 id="this">this</h3><ul><li>全局环境下的this：严格模式下是undefined；非严格模式下是window</li><li>上下文对象调用中的this：绑定到该对象上</li><li>bind、call、apply改变this指向：指定参数上</li><li>构造函数和this：构造函数内的this绑定到新创建对象上</li><li>箭头函数中的this：由外层作用域来决定</li></ul><h3 id="原型对象">原型对象</h3><ul><li>每一个对象都有它的原型对象，它可以使用自己原型对象上的属性和方法</li><li>可以通过原型对象扩展对象</li><li>原型链：任何对象都有原型对象=》形成原型链</li></ul><h2 id="css">CSS</h2><blockquote><p>基本概念、选择器、层叠排序、CSS3新特性、CSSSprites、布局、盒模型、BFC、响应式web设计、移动优先设计、渐进渐强</p></blockquote><h3 id="css概述">CSS概述</h3><ul><li>Cascading Style Sheets 层叠样式表，用于设计风格和布局</li><li>CSS优势：丰富的样式定义、简洁、清晰、易于修改和使用</li></ul><h3 id="选择器">选择器</h3><p>语法：<code>selector &#123; property: value; [...] &#125;</code></p><p>例如：<code>h1 &#123; color: blue; &#125;</code></p><ul><li>id(<code>#</code>)/class(<code>.</code>)/标签(<code>p</code>)/属性(<code>[title]</code>)/伪类(<code>:hover</code>)/伪元素(<code>:first-line</code>)/选择器</li><li>组合选择器：<ul><li>后代选择器：<code>div p</code> （对div标签下的所有p标签生效）</li><li>子元素选择器：<code>div&gt;p</code>（对div标签下的<strong>子</strong>p标签生效）</li><li>相邻兄弟选择器：<code>div+p</code>（对div标签相邻的p标签生效）</li><li>普通兄弟选择器：<code>div-p</code>（对div标签同一层级的p标签生效）</li></ul></li></ul><h3 id="层叠排序">层叠排序</h3><ul><li>内联样式 &gt; 嵌入样式（头部style） &gt; 外部样式 &gt;浏览器缺省样式</li><li>优先级计算：a(是否来自style属性即是否是内联样式)-b(ID)-c(属性/伪类)-d(元素/伪元素)</li></ul><h3 id="css3">CSS3</h3><ul><li>被分成若干个相互独立的模块：有利于规范及时更新和发布，及时调整模块的内容；厂商可以有选择地支持一部分模块，有利于CSS3推广。</li><li>新特征：圆角效果、图形化边界、块阴影与文字阴影、渐变效果、定制字体（<spanclass="citation" data-cites="font-face">@font-face</span>）</li><li><strong>CSS Sprites</strong>：是单个图像中包含的图像集合<ul><li>优点：减少服务器请求节约带宽；更换风格方便</li><li>缺点：维护麻烦；图片合成费时费力</li></ul></li></ul><h3 id="布局">布局</h3><p><strong>盒模型</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230220214046314.png" /></p><p><strong>BFC</strong>：（块级格式化上下文）是一个独立的布局环境，其中的元素布局不受外界的影响，并且在一个BFC中，块盒与行盒都会垂直地沿着其父元素的边框排列，只有Block-levelbox参与，规定了内部的Block-levelBox如何布局，并且与这个局域外部毫不相干</p><h3 id="响应式web设计">响应式web设计</h3><p>（RWD）是一种网页设计方法，该设计可以使网站在多种浏览设备上阅读和导航，同时减少缩放、平移和滚动</p><ul><li><p>优点：可用性得到提升；简化服务器端；更易维护；支持未知设备</p></li><li><p>缺点：性能较差；限制应用的复杂性；用户混淆</p></li><li><p>流畅或灵活的页面布局，根据浏览器窗口大小成比例缩放</p></li><li><p>灵活、比例适中的图像和试听媒体</p></li><li><p>使用CSS3媒体查询，确定浏览器屏幕的宽度并作出相应调整</p></li></ul><h3 id="移动优先">移动优先</h3><ul><li>优先内容和功能</li><li>好处：通用访问，即使没有js也能看到一个拥有基本功能的网站</li><li>移动优先是渐进渐强理念的良好范例，所有用户都能访问核心内容和功能</li></ul><p><strong>渐进渐强</strong>：首先基于一个具有广泛兼容性的核心方案，创建一个基线版本，然后再根据可能用到的浏览器特性，慢慢添加一些特性和功能。</p><h2 id="html">HTML</h2><blockquote><p>基本标签、块内元素和行内元素、HTML5、优势、应用、新元素、新功能、语义化</p></blockquote><h3 id="html概述">HTML概述</h3><ul><li>HyperText Markup Language，超文本标记语言，定义了网页内容和结构</li><li>块级元素占据父元素（容器）的整个水平空间，垂直空间等于内同高度；行内元素只占据元素边框所包含的空间</li><li><code>&lt;title&gt;</code>：用于定义浏览器工具栏中的标题；提供页面被添加到收藏夹的标题；显示在搜索引擎结果中的页面标题</li><li><code>&lt;meta&gt;</code>：用于提供HTML文档元数据；只出现在head里；用于给出网页描述、关键词、文档作者、最后修改日期等信息</li><li>em vs i，strong vs b：i和b都是无强调或着重意味的</li><li>table 不要用于布局：结构混乱不清晰；机器难以理解，不利于SEO；</li><li>表单中的隐藏字段：目的在于收集或发送信息，以利于被处理表单的程序所使用；帮助确认用户身份；保存全局变量；</li></ul><h3 id="html5">HTML5</h3><ul><li><p>HTML5是最新的稳定版本</p></li><li><p>优势：跨浏览器兼容性、<u>大道至简</u>（各种简化）、语义化、可用性和用户体验的改进、无插件范式、安全、大量用于移动应用和游戏，对SEO友好</p></li><li><p>应用：本地数据存储、访问本地文件、本地SQL数据、缓存引用</p></li><li><p>新元素/新功能</p><ul><li><p>新元素：article、section、header、footer等语义化标签、</p></li><li><p>更多原生功能，原生支持音视频</p></li><li><p>完全支持CSS3</p></li><li><p>提供原生的绘图功能（svg和canvas对比）</p><table><thead><tr class="header"><th>canvas</th><th>svg</th></tr></thead><tbody><tr class="odd"><td>依赖分辨率</td><td>不依赖分辨率</td></tr><tr class="even"><td>不支持事件处理器</td><td>支持事件处理器</td></tr><tr class="odd"><td>弱文本渲染能力</td><td>强文本渲染能力</td></tr><tr class="even"><td>最适合图像密集型游戏</td><td>不适合游戏</td></tr></tbody></table></li><li><p>web存储：相比cookie更加安全快速；localStorage（整个网站数据）sessionStorage（当前会话数据）</p></li><li><p>其他新特性：缓存、数据库、web worker、webSocket</p></li></ul></li><li><p><strong>语义化</strong>：根据结构化的内容选择合适的标签；有利于SEO、开发维护体验好、用户体验更好、更好的可访问性，方便任何设备对代码进行解析。</p><ul><li>帮助实现ARIA（Accesible RIA）无障碍富网络应用</li></ul></li><li><p>无插件范式：过去很多功能只能通过插件实现，但是在HTML5中提供了原生实现</p><ul><li>插件的问题：安装可能失败；被禁用或者屏蔽；被攻击</li></ul></li><li><p>CORS：Cross-Origin Resource Share 跨域资源共享 SOP：Same OriginPolicy 同源政策</p></li><li><p>RIA：Rich Internet Applications 富网络应用</p></li></ul><h2 id="概述">概述</h2><blockquote><p>DNS、URL/URI/URN、web发展历程、Web3.0</p></blockquote><h3 id="web发展历程">web发展历程</h3><ul><li>web1.0 =》web2.0 =》web3.0</li><li>web2.0的局限性：用户缺乏自主权（数字身份、个人数据、算法）</li><li><strong>web3.0</strong>的特征：语义化、3D、人工智能、去中心化</li></ul><h3 id="dns">DNS</h3><ul><li>Domain Name System</li><li>其出现之前使用 hosts.txt保存name-to-IP的映射关系</li><li>应用程序（DNS客户端）——解析器——DNS服务器</li><li>DNS名称树形层次结构</li><li>FQDN：Fully Qualified Domain Name 全限定域名</li><li>主名称服务器和辅名称服务器</li><li><strong>递归和迭代查询</strong></li><li>DNS服务器有缓存</li></ul><h3 id="uriurnurl">URI/URN/URL</h3><ul><li>RR：Resource Records 资源记录</li><li>URI：Uniform Resource Identifier ⽤于标识某⼀互联⽹资源名称的字符串（最大 是后面两个超集）</li><li>URL：Uniform Resource Location 属于URI 标识互联网资源<ul><li>URL协议：http https file mailto</li><li>超链接：绝对URL、相对URL、同一网页内</li><li>URL编码：<strong>只能使用 ASCII 字符集</strong><ul><li>%20/+ =&gt; 空格</li><li>%xx =&gt; 中文</li></ul></li></ul></li><li>URN：Uniform Resource Name 仅用于命名 位置无关 通过名称指定</li></ul><h2 id="级web前端期末考试2022">2020级web前端期末考试（2022）</h2><h3 id="名词解释">名词解释</h3><ul><li>URN</li><li>CSSOM</li><li>SVG</li><li>CANVAS</li><li>ES6</li><li>WebAssembly</li><li>Cookie</li><li>Session</li><li>Render Tree</li><li>RWD</li></ul><h3 id="简答题">简答题</h3><ol type="1"><li>web3.0核心技术</li><li>对闭包的理解、优缺点和应用</li><li>前端智能化的理解和典型应用</li><li>JavaScript的数据类型</li><li>JavaScript的动态和弱类型是什么意思</li><li>状态码的解释：200、301、303、404、500</li><li>箭头函数和普通函数的区别</li><li>Nodejs如何实现高并发</li></ol><h3 id="问答题">问答题</h3><ol type="1"><li>流行的前端框架？Vanilla JavaScript是什么？为什么要推广？</li><li>HTTP1.0-3.0的发展过程？HTTP/3相比之前的HTTP协议解决了什么问题？</li><li>简述四种前端鉴权方案？</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/nju-course-review/">nju-course-review</category>
      
      
      <category domain="http://example.com/tags/front-end/">front-end</category>
      
      
      <comments>http://example.com/2023/02/22/nju-course-review-notes/web%E5%89%8D%E7%AB%AF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Lab6 Multithreading</title>
      <link>http://example.com/2023/02/21/6.S081/6.S081-lab6-thread/</link>
      <guid>http://example.com/2023/02/21/6.S081/6.S081-lab6-thread/</guid>
      <pubDate>Mon, 20 Feb 2023 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;线程切换&quot;&gt;线程切换&lt;/h2&gt;
&lt;p&gt;&lt;img
src=&quot;https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212104346281.png&quot; /&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="线程切换">线程切换</h2><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212104346281.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212105840373.png" /></p><h2 id="uthread-switching-between-threads">Uthread: switching betweenthreads</h2><blockquote><p>针对用户级的线程系统设计并实现一个上下文切换</p></blockquote><p>理解了<code>lecture</code>中的线程切换就比较简单，基本上模仿内核模式写就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>&#123;</span><br>    <span class="hljs-type">char</span> <span class="hljs-built_in">stack</span>[STACK_SIZE];<br>    <span class="hljs-type">int</span>state;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span>  <span class="hljs-title">context</span>;</span> <span class="hljs-comment">// 增加一个线程上下文 内容和kernel下的context一致</span><br>&#125;;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_create</span><span class="hljs-params">(<span class="hljs-type">void</span> (*func)())</span><br>&#123;<br>...<br>    <span class="hljs-comment">// 设置该线程运行的函数</span><br>  t-&gt;context.ra = (uint64)func;<br>    t-&gt;context.sp = (uint64)(t-&gt;<span class="hljs-built_in">stack</span> + PGSIZE);<br>&#125;<br><br><span class="hljs-comment">// thread_schedule</span><br>thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;current_thread-&gt;context);<br><br><span class="hljs-comment">// thread_switch内容和kernel下的swtch一致</span><br></code></pre></td></tr></table></figure><blockquote><p>疑难点：设置线程运行函数那一个地方还是需要理解一下（当然<code>lecture</code>中以及<code>xv6</code>中也有相应的部分可以参考），就是为什么设置了两个寄存器就可以了？<font color='red'>因为每次切换上下文之后返回的都是当前<code>ra</code>寄存器指向的位置，所以想要使函数可以运行在对应线程上，只要设置该线程<code>context</code>里的<code>ra</code>寄存器。<code>sp</code>寄存器是为函数的运行分配栈空间。</font></p></blockquote><h2 id="using-threads">Using threads</h2><blockquote><p>解决多线程读写哈希表（数组+链表）引发的<code>race-condition</code></p></blockquote><p>现象产生的原因：阅读<code>ph.c</code>中代码可以发现，针对一个新的key，是会插入这个key对应桶中链表的头部。但是一旦有两个进程并发执行，而不加措施，就会有<code>entry</code>丢失。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, <span class="hljs-keyword">struct</span> entry **p, <span class="hljs-keyword">struct</span> entry *n)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> entry));<br>  e-&gt;key = key;<br>  e-&gt;value = value;<br>  e-&gt;next = n; <span class="hljs-comment">// 如果两个线程都在执行完这条语句之后中断，之后无论哪个进程执行下一条语句，都会有一个entry丢失。因为此时两个entry同时指向原链表的表头。</span><br>  *p = e;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方案：<strong>加锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 全局声明</span><br><span class="hljs-type">pthread_mutex_t</span> lock;<br><br><span class="hljs-comment">// main函数里 初始化lock</span><br>pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// 在 put 函数的 调用insert函数的语句前后 加锁和解锁</span><br>pthread_mutex_lock(&amp;lock);<br>insert(...);<br>pthread_mutex_unlock(&amp;lock);<br></code></pre></td></tr></table></figure><blockquote><p>加锁的粒度：经过思考可以发现，很多情况下是不需要加锁的，真正产生冲突的原因是insert函数，所以最小的锁粒度应该针对每一次的<code>insert</code>函数。</p></blockquote><h2 id="barrier">Barrier</h2><blockquote><p>实现一个同步点：所有的线程要等待其他线程到达该点</p></blockquote><blockquote><p>需要学习一下<code>xv6</code>中的<code>sleep</code>和<code>wakeup</code>函数（lecture13）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Block until all threads have called barrier() and</span><br>  <span class="hljs-comment">// then increment bstate.round.</span><br>  <span class="hljs-comment">//</span><br>    <br>  <span class="hljs-comment">// 首先需要获取锁，因为需要修改bstate.nthread</span><br>  <span class="hljs-comment">// 这个场景和lecture中解决lost wakeup问题的场景很像</span><br>  <span class="hljs-comment">// 都是在外面获取锁，在sleep(wait)里面释放锁，从而避免了一个时间窗口使得先wakeup然后sleep</span><br>  pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>  bstate.nthread++;<br>  <span class="hljs-keyword">if</span> (bstate.nthread != nthread) &#123;<br>    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 注意: 由于是if-else结构，所以只有最后一个到达barrier的线程才会执行else部分</span><br>      <span class="hljs-comment">// 其他都被阻塞，唤醒之后直接释放锁退出了</span><br>    bstate.nthread = <span class="hljs-number">0</span>;<br>    bstate.round ++;<br>    pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>  &#125;<br>  pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/6-S081-labs/">6.S081-labs</category>
      
      
      <category domain="http://example.com/tags/6-S081/">6.S081</category>
      
      
      <comments>http://example.com/2023/02/21/6.S081/6.S081-lab6-thread/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>需求与商业模式创新</title>
      <link>http://example.com/2023/02/15/nju-course-review-notes/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</link>
      <guid>http://example.com/2023/02/15/nju-course-review-notes/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</guid>
      <pubDate>Tue, 14 Feb 2023 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;新浪微博——便利蜂——蔚来汽车&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第1题商业模式画布&quot;&gt;第1题（商业模式画布）&lt;/h2&gt;
&lt;p&gt;分析微博的商业模式，并画出商业模式画布&lt;/p&gt;
&lt;p&gt;根据材料画商业模式画布及各部分元素。写</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>新浪微博——便利蜂——蔚来汽车</p></blockquote><h2 id="第1题商业模式画布">第1题（商业模式画布）</h2><p>分析微博的商业模式，并画出商业模式画布</p><p>根据材料画商业模式画布及各部分元素。写出一个“约束”需求</p><p>分析蔚来电动车的商业模式，并画出商业模式画布，写出约束三大来源+本系统的一条约束需求</p><h2 id="第2题商业模式特点">第2题（商业模式特点）</h2><p>分析微博如何体现多边平台商业模式的特点，并指出微博存在的问题</p><p>属于哪一个商业模式？这个模式有什么要点？再结合材料谈谈</p><p>对比传统车和用户，分析蔚来电动车体现何种商业模式，该商业模式具有什么特点</p><h2 id="第3题客户洞察场景讲故事">第3题（客户洞察、场景、讲故事）</h2><p>对微博的普通用户进行客户洞察，主要特点是想要进行社交和追踪时事热点</p><p>从公司和客户角度分别讲一个故事</p><p>App商城内的题面，对客户的讲故事和场景有什么区别？给出一个场景，并阐述为什么适用？</p><h2 id="第4题商业模式分析">第4题（商业模式分析）</h2><p><font color="red"></font></p><p>对微博的商业模式进行SWOT评估（不需要打分，概要评估）</p><p>SWOT评估包括哪些要点？结合材料和画布里的每个元素，简要分析（不需要打分）</p><p>对蔚来电动车的商业模式进行环境评估（不需要打分，概要评估）</p><h2 id="第5题目标模型">第5题（目标模型）</h2><p>结合微博存在的问题，进行目标分析（尽可能多地使用目标分析的元素）</p><p>想要在2021年大规模扩张，画出目标模型</p><p>结合蔚来电动车的车友社区，进行目标分析（尽可能多地使用目标分析的元素）</p><h2 id="第6题涉众分析">第6题（涉众分析）</h2><p>使用power-interest和power-attribute模型，阐述如何化解微博的涉众风险</p><p>有店员因为数学不好而离职，老店长认为计算机不能代替人类决策；通过实验证明数据模型更有效；老店长培养新店长；减少店员数量，增加店员收入。结合材料，用stakeholder-issue模型进行涉众共赢分析</p><p>使用stakeholder/issue模型进行共赢分析</p><h2id="第7题需求获取三大手段面谈原型观察">第7题（需求获取三大手段：面谈、原型、观察）</h2><p>假设你想要开发直播带货，结合三种需求获取方法，简述你将如何进行需求获取</p><p>想搞社区团购，有个人懂，并且还会直播带货。需求获取有哪3个方法？结合材料谈如何需求获取</p><p>面谈问题的两大类型，和一个传统燃油车用户面谈，探讨服务和让这些客户选择电动车，构思一个问题列表</p><h2 id="第8题需求管理与验证">第8题（需求管理与验证）</h2><p>简述需求管理的三种方法和流程</p><p>让你做小程序和App，需求管理包括哪些要点？结合着谈谈</p><p>简述需求管理的三种方法和管理变更的五大原则</p><h2id="第9题需求分析画图概念类图顺序图状态图">第9题（需求分析画图：概念类图、顺序图、状态图）</h2><p>微博有一系列的封号规则，根据规则画出状态图</p><p>买优惠券包、查看优惠券、优惠券包退款、优惠券包过期换积分。画出用例的系统顺序图</p><p>蔚来电动车有一系列的升级（类似）规则，根据规则画出状态图</p><h2 id="商业模式画布">商业模式画布</h2><ul><li><strong>客户细分</strong><ul><li>目标人群、取舍与细分</li><li>群体划分：<u>大众市场、小众市场、求同存异的客户群体、多元化的客户群体、多变平台</u></li></ul></li><li><strong>价值主张</strong><ul><li>为某一客户群体能够为其创造价值的产品和服务</li><li>让事情更简单（<u>保姆式服务</u>、<u>便利性</u>、<u>价格</u>）、更复杂（<u>定制</u>）、更透明（<u>风控</u>）、<u>创新</u>、<u>性能</u>、<u>设计</u>、<u>品牌/地位</u>、<u>缩减成本</u>、<u>可获得性</u></li></ul></li><li><strong>关键业务</strong><ul><li><u>生产、解决方案、平台/网络</u></li></ul></li><li><strong>核心资源</strong><ul><li>保证商业模式运行的最重要资产（品牌也算）</li><li><u>实物资源、知识型资源、人力资源、金融资源</u></li></ul></li><li><strong>渠道通路</strong><ul><li>如何和客户群体达成沟通并建立联系，以向对方传递自身的价值主张</li><li><u>知名度-评价-购买-传递-售后</u></li></ul></li><li><strong>重要合作</strong><ul><li>供应商和合作伙伴网络</li><li>非竞争者的战略同盟、竞争者的战略同盟（合作）、为新业务建立合资公司、稳定供应关系的供应商和采购商</li><li>动机：优化及规模效应、降低风险和不确定性、特殊资源及活动的获得</li></ul></li><li><strong>收入来源</strong><ul><li>用户真正愿意付费的点</li><li><u>资产销售、使用费、会员费、租赁、许可使用费、经纪人佣金、广告费</u></li><li>固定价格、浮动价格</li></ul></li><li><strong>成本结构</strong><ul><li><u>固定成本、可变成本、规模经济、范围经济</u></li></ul></li><li><strong>客户关系</strong><ul><li><u>私人服务、专属私人服务、自助服务、自动化服务、社区、协作/共同创造</u></li></ul></li></ul><h2 id="商业模式类型">商业模式类型</h2><h3 id="分拆商业模式">分拆商业模式</h3><ul><li>企业从事活动的三种不同类型：<strong>客户关系管理</strong>、<strong>新产品开发</strong>、<strong>基础设施管理</strong></li><li>对应着三种价值信条：<strong>亲近客户</strong>、<strong>产品领先</strong>、<strong>运营卓越</strong></li></ul><h3 id="多边平台商业模式">多边平台商业模式</h3><ul><li>平台将两个或更多独立但相互依存的客户群体连接在一起，平台通过促进不同群体之间的互动而创造价值</li><li>价值主张：吸引用户、群体配对、利用平台交易渠道降低交易成本</li><li>客户群体相互依存，无法独立</li><li>核心是补贴正确的客户群</li></ul><h3 id="长尾商业模式">长尾商业模式</h3><ul><li>致力于提供相当多种类的小众产品，而其中的每种卖出量相对很少，但总销售额可以与传统模式销售媲美</li><li>图书：以畅销书为中心的出版模式=》为任何需要的人出版</li><li>乐高：传统的积木制作=》用户定制+在线售卖</li><li>出现的原因：<ul><li>生产工具的普及</li><li>销售渠道的普及</li><li>连接供需双方搜寻成本的降低</li></ul></li></ul><h3 id="免费商业模式">免费商业模式</h3><ul><li>至少有一个关键的客户群体是可以持续免费地享受服务，不付费客户所得到地财务支持来自于另一个客户群体</li><li>广告模式<ul><li>免费的形式：基于多边平台的免费商品</li></ul></li><li>免费增值<ul><li>免费的形式：免费的基本服务，可选的增值服务</li></ul></li><li>诱饵&amp;陷阱<ul><li>以一个免费或者很便宜的初始价格吸引客户，引诱客户进入重复购买状态</li></ul></li></ul><h3 id="开放商业模式">开放商业模式</h3><ul><li>系统性与外部伙伴合作</li><li>由内到外：将外部的理论、技术或知识产权引入内部</li><li>由外到内：将内部的知识产权或技术，特别是闲置资产向外出售</li></ul><h2 id="商业模式设计">商业模式设计</h2><h3 id="客户洞察">客户洞察</h3><ul><li><strong>看到什么</strong>：描述这个客户在她所在的环境中<strong>所看到的东西</strong>，同类产品、朋友、看我们的产品</li><li><strong>听到什么</strong>：描述环境如何影响到这个客户</li><li><strong>想&amp;感受</strong>：尝试勾勒你的<strong>客户思维</strong>的过程，重要、打动</li><li><strong>说&amp;做</strong>：想象客户可能出现的<strong>言辞</strong>，或公共场合的<strong>行为</strong></li><li><strong>痛点</strong>：已遭受的挫折、正遇到的阻碍、怕承担的风险</li><li><strong>收益</strong>：预期成就、成功衡量标准、实现目标所采用的策略</li></ul><h3 id="构思">构思</h3><ul><li>灵感、构思、实施</li><li>生成大量创意=》对创意进行整合筛选</li><li>头脑风暴</li><li>资源驱动、供给驱动、客户驱动、财务驱动、多点驱动</li><li>从画布寻找创新点、如果...会怎样</li></ul><h3 id="视觉化思考">视觉化思考</h3><ul><li>抽象=》具体</li><li>两项技术：如何使用便利贴+如何将草图与商业模式画布结合</li><li>四个流程：理解、对话、探索、沟通</li><li>作用：加深理解、提高对话效率、探索创意、提升沟通</li></ul><h3 id="模型构建">模型构建</h3><ul><li>抽象概念具体化，帮助探索新的创意，有助于实际商业模式的探索</li><li>设计态度：专注探索、全面考虑、快速放弃、选出值得优化的想法、接收不确定性</li><li>控制规模<ul><li>随手素描</li><li>精心描绘的画布</li><li>商业案例</li><li>实地验证</li></ul></li></ul><h3 id="讲故事">讲故事</h3><ul><li>理想的热身工具，为深度讨论商业模式与其内在逻辑做好准备</li><li>为什么要讲故事<ul><li>介绍新想法</li><li>向投资人推荐</li><li>吸引员工</li><li>让未来触手可及</li></ul></li><li>故事的不同视角：客户、公司、未来</li></ul><h3 id="场景">场景</h3><ul><li>将模型构建中明确的方向具体化，从而给出有见地的设计</li><li>两种场景<ul><li>不同的客户结构：结合客户洞察描绘处独特、具体的图景</li><li>未来可能的竞争环境：想象未来可能的具体细节，品味特定条件下商业模式如何演进</li></ul></li><li>为一个故事设计并补充一个场景</li><li>了解评估=》购买与传递=》交互=》售后=》评价与复购</li></ul><h2 id="商业模式战略">商业模式战略</h2><h3 id="商业模式环境">商业模式环境</h3><ul><li><strong>市场影响力</strong>：<ul><li>市场问题：</li><li>市场分类：识别客户群体</li><li>需求和诉求：</li><li>切换成本：</li><li>收入吸引力：</li></ul></li><li><strong>行业影响力</strong><ul><li>竞争对手</li><li>新进入者（挑战者）</li><li>替代产品和服务：潜在替代品</li><li>供应商和价值量链上的其他厂商：市场价值链中的关键玩家</li><li>利益相关者：影响组织和商业模式的人</li></ul></li><li><strong>关键趋势</strong>：<ul><li>技术趋势：威胁/推动商业模式的技术</li><li>行业管理趋势：</li><li>社会和文化趋势：价值观？</li><li>社会经济趋势：</li></ul></li><li><strong>宏观经济影响</strong>：<ul><li>全球市场情况</li><li>资本市场</li><li>大宗商品和其他资源：商业模式所需资源的价格和价格趋势（人才、原料）</li><li>经济基础设施</li></ul></li></ul><h3 id="swot分析">SWOT分析</h3><ul><li><strong>SW</strong><ul><li>价值主张<ul><li>用户需求、网络效应、产品服务强耦合、用户满意</li></ul></li><li>成本/收入<ul><li>利润高、收入可预期、收入可持续、收入多样化、支出前有进账、抓住客户的意愿、客户想要的和提供的一致</li><li>成本可预测、成本匹配商业模式、运营成本效率高、规模经济中获益</li></ul></li><li>基础设施（核心资源、关键业务、重要合作）<ul><li>对手难复制、资源需求可预测、合适时间部署合适资源</li><li>有效执行关键业务、难以复制、执行质量高、自有活动和外包活动平衡</li><li>必要合作、关系融洽</li></ul></li><li>客户界面（客户细分、渠道通路、客户关系）<ul><li>客户流失率低、很好地分类用户、不断获得用户</li><li>渠道有效率、渠道有效果、连接客户效果好、客户轻易接触渠道、高度整合、规模经济、匹配客户群体</li><li>客户关系强、匹配客户群体、切换成本高绑定关系、品牌很强</li></ul></li></ul></li><li><strong>O</strong><ul><li>价值主张：产品服务化？整合产品服务？额外需求？价值主张外延？额外工作？</li><li>成本/收入：<ul><li>重复收入？内部或合作伙伴交叉销售？增加创造收入来源？提价？</li><li>削减成本？</li></ul></li><li>基础设施：<ul><li>资源成本更低？转移给合作伙伴？开发不足？对他人有用的知识资产</li><li>关键业务标准化？提高效率？IT帮助？</li><li>外包？扩大合作？交叉销售？帮助连接客户？补充价值主张？</li></ul></li><li>客户界面：<ul><li>增长的市场？新客户？更细致的分类？</li><li>提升效率效益？整合渠道？补充性渠道伙伴？去中间商？匹配渠道客户？</li><li>提升客户跟进效果？紧密客户关系？改进定制化？提升切换成本？舍弃无利润客户？客户关系自动维护？</li></ul></li></ul></li><li><strong>T</strong><ul><li>价值主张：存在可替代品？</li><li>成本/收入：<ul><li>利润的威胁？收益来源单一？收益来源消失？</li><li>成本无法预测？成本超过收入？</li></ul></li><li>基础设施<ul><li>资源供应不足、资源质量保证？</li><li>关键业务干扰？业务质量被威胁？</li><li>失去合作伙伴？和对手合作？过分依赖伙伴？</li></ul></li><li>客户界面<ul><li>市场饱和？威胁市场份额？转投竞争对手？竞争白热化？</li><li>威胁渠道？渠道用户不相关？</li><li>客户关系恶化？</li></ul></li></ul></li></ul><h3 id="蓝海战略">蓝海战略</h3><ul><li>增加价值+减少成本</li><li>三个视角：客户群体视角、价值主张视角、成本的视角</li><li>四项行动：删除、削减、提升、创造</li><li>太阳马戏团：价值主张：增加艺术元素，放弃动物表演</li><li>任天堂的wii：客户群体：铁杆玩家=》休闲玩家</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230205120635021.png" /></p><h2 id="需求基础">需求基础</h2><blockquote><p>第一题可能会涉及一些需求基础</p></blockquote><ul><li>需求的层次性：<ul><li>业务需求：解决方案与系统特性</li><li>用户需求：用户可以使用系统完成xx任务</li><li>系统级需求：用户对系统行为的期望，具体的</li></ul></li><li>需求分类<ul><li>软件需求</li><li>硬件需求</li><li>其他需求</li></ul></li><li>软件需求<ul><li>功能需求</li><li>性能需求</li><li>质量需求</li><li>对外接口</li><li><strong>约束</strong>：限制开发人员设计和构建系统时的选择范围<ul><li>系统开发及运行的环境</li><li>问题域标准：法律法规</li><li>商业规则</li><li>社会性因素</li></ul></li><li>其他需求</li></ul></li></ul><h2 id="目标模型">目标模型</h2><h3 id="目标规格的基本模式">目标规格的基本模式</h3><blockquote><p>（需要记住这些名词在画图的时候会用到）</p></blockquote><table><thead><tr class="header"><th>模式</th><th>符号描述</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>实现(Achieve)</td><td><span class="math inline">\(P \Rightarrow \Diamond Q\)</span></td><td>如果将来某一时刻Q为真(被满足)，则目标实现</td></tr><tr class="even"><td>终止(Cease)</td><td><span class="math inline">\(P \Rightarrow \Diamond \negQ\)</span></td><td>如果将来某一时刻Q为假(被终止)，则目标实现</td></tr><tr class="odd"><td>保持(Maintain)</td><td><span class="math inline">\(P \Rightarrow \Box Q\)</span></td><td>将来任一时刻Q都为真，则目标实现</td></tr><tr class="even"><td>避免(Avoid)</td><td><span class="math inline">\(P \Rightarrow \Box \neg Q\)</span></td><td>将来任一时刻Q都为假，则目标实现</td></tr><tr class="odd"><td>优化(Optimize)</td><td>-</td><td>最大化Maximize(目标功能) 或 最小化Minimize (目标功能)</td></tr></tbody></table><h3 id="目标模型的关系">目标模型的关系</h3><ul><li><strong>精化</strong><ul><li><u>AND精化</u>：任一子目标的完成都有助于父目标的完成<ul><li>完备AND精化：子目标的完成可以直接保证父目标的完成</li></ul></li><li><u>OR精化</u>：任一子目标都是父目标的替代方案</li></ul></li><li><strong>阻碍</strong>：子目标达成会使得父目标失败；可以对阻碍目标继续精化</li><li><strong>支持与冲突</strong><ul><li>support：一个目标对其他目标的支持促进作用，可以被处理为<strong>OR精化关系</strong></li><li>conflict：一个目标对其他目标的实现有阻碍作用</li></ul></li></ul><h3 id="目标分析过程">目标分析过程</h3><ul><li><strong>从高层目标描述中发现关系</strong><ul><li>AND精化关系<ul><li>同一个目标有不同场景</li><li>完成目标有连续过程</li><li>完成目标需要多个方面精密配合</li><li>目标有不同质量环境及表现</li></ul></li><li>OR精化关系：多种可以相互替代的“候选方法”</li></ul></li><li><strong>考虑阻碍目标实现的情况</strong><ul><li>考虑使得子目标失败的阻碍</li><li>考虑主体行为导致目标失败的阻碍</li><li>考虑预防失败的情况</li><li>重新处理太理想化的目标</li></ul></li><li><strong>考虑已有目标之间的支持与冲突关系</strong></li><li><strong>对高层目标问how，对低层目标问why</strong></li><li><strong>目标的实现</strong><ul><li>1、将最底层目标分配给主体</li><li>2、设计实现最底层目标的操作</li><li>目标与主体的关系：OR和AND</li><li>目标与操作的关系：OR和AND（没有箭头 目标间关系有箭头）</li></ul></li></ul><h3 id="示例">示例</h3><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book5/37.png" /></p><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book5/38.png" /></p><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book5/69.png" /></p><h2 id="涉众分析">涉众分析</h2><h3 id="涉众识别之adm模型">涉众识别之ADM模型</h3><blockquote><p>主体依赖模型</p></blockquote><ul><li><font color='red'><strong>目标依赖</strong></font>：依赖者希望被依赖者满足一个条件，但是不规定怎样满足该条件</li><li><font color='#f4df15'><strong>软目标依赖</strong></font>：一种特殊类型的目标依赖，无法量化描述</li><li><font color='green'><strong>任务依赖</strong></font>：依赖者希望被依赖者执行特定任务，比目标依赖更加具体</li><li><font color='blue'><strong>资源依赖</strong></font>：依赖者希望被依赖者提供资源实体（抽象信息或者实物材料）为自己所用</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210154032835.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210155251866.png" /></p><h3 id="涉众分析power-interest模型">涉众分析—Power-Interest模型</h3><p><strong>优先级评估</strong>：有些涉众就是会更加重要一点，具有更高优先级，体现在和系统的联系上</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/11.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/12.png" /></p><p><strong>化解涉众风险的策略</strong></p><ul><li>提高环境设定者对系统的关注，转变为参与者</li><li>消除强反对者的反对原因，变为强支持者</li><li>给予被影响者发表实现自身意愿的权利，化解弱反对者忧虑</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/13.png" /></p><h3id="共赢分析stakeholder-issue模型">共赢分析—Stakeholder-Issue模型</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/15.png" /></p><ol type="1"><li>列出所有涉众类别</li><li>发现涉众们背后涉及的共同问题（issue）</li><li>建立涉众类别和问题的关联</li><li>表明stakeholder-issue关系所寄予的期望</li></ol><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210171728451.png" /></p><h2 id="需求获取手段">需求获取手段</h2><h3 id="面谈">面谈</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211102941016.png" /></p><h4 id="问题类型">问题类型</h4><ul><li>开放式问题<ul><li>“请解释你是如何做进度决策的”</li><li>优点：细节丰富；被会见者自在</li><li>缺点：信息率低；</li><li>需求获取的初期，掌握的信息优先，希望提供丰富的信息</li></ul></li><li>封闭式问题<ul><li>回答的形式受限制</li><li>优点：节省时间；切中要点</li><li>缺点：细节不够；被厌烦</li><li>需求获取的后期，已经对事实和问题的范围比较明确</li></ul></li><li>诱导性问题</li><li>探究式问题</li><li>双筒式问题</li><li>元问题</li></ul><h4 id="面谈的问题准备示例">面谈的问题准备示例</h4><ul><li>前期</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211103950830.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211104035259.png" /></p><ul><li>后期</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211104114828.png" /></p><h3 id="原型">原型</h3><blockquote><p>获取不确定需求：可能法僧的需求变更；存在冲突的地方；信息不充分...</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211110400104.png" /></p><ul><li>确定原型需求：为什么要开发原型，拥有的起始点是什么，期望的结束标准是什么</li><li>原型开发：依据原型的需求特点和开发目的，以最低的成本建立初始原型</li><li>原型评估：对上一阶段产生的原型进行评估，根据评估者（用户和开发者）的反馈判断原型是否满足结束标准</li><li>原型修正：如果已经达到了目的就结束；否则根据评估者反馈进行原型调整</li></ul><h3 id="观察">观察</h3><blockquote><p>事件的情境性：某些事件只有和具体的情境联系起来才能得到很好的理解</p></blockquote><h4 id="采样观察">采样观察</h4><ul><li>时间采样：指定时间间隔来观察用户的活动情况<ul><li>在7个8小时工作日内随机指定5个10分钟间隔来观察用户</li><li>优点：减少偶然偏差；节省时间成本</li><li>缺点：不能提供全面的信息；忽视重要但是频率低的事务</li></ul></li><li>事件采样：有目的地选取整个事件进行观察<ul><li>不会遗漏重要事件</li><li>事件成本高；漏掉频发发生事件的代表性样本</li></ul></li></ul><h4 id="民族志">民族志</h4><blockquote><p>民族志可以很好地处理复杂的协同工作，例如航空调度、证券交易等</p></blockquote><p>优点：能够深度理解信息；让真实事件的社会性因素可见化</p><p>缺点：时间成本高；产生的数据过于广泛，数据抽取存在一定难度</p><p>实施：</p><ul><li>针对复杂协同问题的民族志（关注以下3方面）<ul><li>分布式协同：用户的活动是一个有组织的整体活动的一部分，而不是单纯的个体活动</li><li>计划和程序：产生的资料、记录任务完成得细节步骤和过程</li><li>工作的意识：活动对协同中的其他人可见或者可理解</li></ul></li><li>普通民族志的规则<ul><li>定期记录发现</li><li>尽快记录可能发生的面谈</li><li>定期复查和更新自己的想法</li><li>及时对信息进行总结索引分类</li></ul></li></ul><h2 id="需求分析">需求分析</h2><p><strong>需求分析的根本任务</strong>：</p><ul><li>建立分析模型，达成开发者和用户对需求信息的共同理解<ul><li>模型是对事务的抽象：抽象、分解、投影</li><li>两种世界与三种模型<ul><li>计算世界与计算模型</li><li>问题世界与业务模型</li><li>软件分析模型（分析视图）</li><li>业务模型=》软件分析模型=》计算模型</li></ul></li></ul></li><li>依据共同的理解，发挥创造性，创建软件系统解决方案</li></ul><h3 id="对象模型">对象模型</h3><h4 id="对象">对象</h4><ul><li><strong>独立可确认</strong>：<u>相对于问题域</u>是可界定的，具有==标识符==来唯一地标识自己</li><li><strong>有明确的角色</strong>：要求对象具有一定<u>状态和行为</u><ul><li>==状态==：对象的特征描述</li><li>==行为==：对象在其状态发生改变或者接收到外界消息时所采取的行动</li></ul></li><li>对象间的关系：对象间互相协作的关系称为<u>链接</u>，建立a指向b的链接的途径有：<ul><li>b是全局对象</li><li>b是a的一部分</li><li>b是被a创建的</li><li>b的引用被作为消息的一部分传递给了a</li></ul></li></ul><h4 id="类">类</h4><ul><li><p>类的概念：共享相同属性和行为的对象的集合</p></li><li><p>类的产生——分类：</p><ul><li>数据驱动：以对象的属性为标准</li><li>职责驱动：结合对象的状态和行为 考虑概念之间的相似性</li></ul></li><li><p>类的产生——抽象：</p><ul><li>水平层次忽略：忽略不重要的属性</li><li>垂直层次忽略：将值忽略，抽象为属性</li></ul></li><li><p>类的封装：</p><ul><li>信息隐藏</li><li>只公开对象为履行职责所必需的协议</li></ul></li><li><p><strong>类之间的关系</strong></p><ul><li><p><strong>关联</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212140305004.png" /></p></li><li><p><strong>聚合和组合</strong></p><ul><li>聚合：表示整体与部分之间的关系</li><li>组合：除了包含关系，还对部分有完全的管理职责（一旦部分属于某个整体，改部分不能属于其他整体，也不能单独存在）</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212140340175.png" /></p></li><li><p><strong>继承</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212140447249.png" /></p></li><li><p>多态</p></li></ul></li></ul><h4 id="领域模型">领域模型</h4><p>领域模型中的类大多是<strong>概念类</strong>：</p><ul><li>概念类间存在指明语义联系的关联，这些关联通常不标记方向，也不比较关联端的可见性</li><li>概念类会显式描述自己的一些重要属性，但是不是全部的详细属性，属性没有类型的约束</li><li>概念类不显示地标记类的行为，即不包含明确的方法</li></ul><h4 id="建立领域模型概念类图">建立领域模型（概念类图）</h4><blockquote><p>学习教材中的几个例子（P349）</p></blockquote><ol type="1"><li><strong>识别候选对象与类</strong><ul><li>概念类分类列表</li><li>名词分析</li><li>行为分析：识别系统行为中的被动对象和主动对象</li></ul></li><li><strong>确定概念类</strong><ul><li>确定为概念类的对象需要既维持一定的状态、又依据状态表现一定的行为</li><li>属性的复杂度，例如“图书”和“作者”</li><li>武断地将单值状态类抽象为其他类的属性，例如“商品”和“价格”</li></ul></li><li><strong>建立类之间的关系</strong></li><li><strong>添加类的重要属性</strong></li></ol><h3 id="行为模型">行为模型</h3><h4 id="顺序图">顺序图</h4><ul><li>顺序图示例</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212154449638.png" /></p><ul><li><p>系统顺序图：将整个系统看作一个黑箱的对象，强调外部参与者和系统的交互行为，重点展示系统级事件（<u>和设计的区别：设计会将系统拆成一个个模块</u>）</p></li><li><p>顺序图的组合片段</p><ul><li><code>seq</code>：同一根生命线上的操作需要按顺序执行，不同生命线的操作是并发的</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212155122180.png" /></p></li><li><p>系统顺序图示例</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212155445497.png" /></p></li></ul><h4 id="状态图">状态图</h4><p><strong>建立状态图</strong></p><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/59.png" /><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/60.png" />UML状态图示例 <imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/61.png" /></p><ul><li>确定上下文环境</li><li>识别状态</li><li>建立状态转换</li><li>补充详细信息</li></ul><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/35.png" /></p><h2 id="需求管理与验证">需求管理与验证</h2><h3 id="需求管理的三个活动">需求管理的三个活动</h3><ol type="1"><li><p><strong>维护需求基线</strong></p><ul><li>需求基线：已经通过正式评审和批准的规格说明或产品，可以作为进一步开发的基础，并且只有通过正式的变更控制过程才能修改它</li><li>需求基线的维护：<ul><li>配置管理：1、标识配置项；2、版本控制；3、变更控制；4、访问审计；5、状态报告</li><li>状态维护：反映项目的实际进展状况<ul><li>已提议；已批准；已实现；已验证；已删除；已否决</li></ul></li></ul></li></ul></li><li><p><strong>实现需求跟踪</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230213093320780.png" /></p><ul><li>在涉众需求变化中协调系统的演化，保持各项开发工作对需求的一致性</li><li>前向跟踪：涉众需要=》软件需求；软件需求=》涉众需要</li><li>后向跟踪：软件需求=》后续开发物件；后续开发物件=》软件需求</li><li>需求跟踪的实现方法：矩阵、实体关系模型和交叉引用3种</li></ul></li><li><p><strong>变更控制</strong></p><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book17/8.png" /></p><ul><li>需求的变化是正当的和不可避免的</li><li>以可控、一致的方式进行需求基线中需求变更处理，包括对变化的评估、协调、批准或拒绝、实现和验证</li><li>5个注意事项（5大原则？）<ul><li>认识到变更的必要性，并为之制定计划</li><li>维护需求基线，审计变更记录</li><li>管理范围蔓延</li><li>灵活应对变请求</li><li>使用辅助工具</li></ul></li></ul></li></ol><h3 id="需求验证">需求验证</h3><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book16/1.png" /></p><ul><li>需求的验证：以正确的方式建立需求</li><li>需求的确认：建立的需求是正确的</li><li>验证方法：评审、原型与模拟、测试用例开发、用户手册编制、利用跟踪关系和自动化分析</li><li><strong>评审</strong>：静态分析；作者之外的人</li><li><strong>原型</strong>：涉及复杂的动态动作，成本较高</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/nju-course-review/">nju-course-review</category>
      
      
      <category domain="http://example.com/tags/demand-and-business-model-innovation/">demand and business model innovation</category>
      
      
      <comments>http://example.com/2023/02/15/nju-course-review-notes/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>处理器管理</title>
      <link>http://example.com/2023/02/15/nju-course-review-notes/os/processor-management/</link>
      <guid>http://example.com/2023/02/15/nju-course-review-notes/os/processor-management/</guid>
      <pubDate>Tue, 14 Feb 2023 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;处理器&quot;&gt;2.1 处理器&lt;/h2&gt;
&lt;h3 id=&quot;处理器与寄存器&quot;&gt;2.1.1 处理器与寄存器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户程序可见寄存器&lt;/strong&gt;：减少访问主存储器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制与状态寄存器&lt;/st</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="处理器">2.1 处理器</h2><h3 id="处理器与寄存器">2.1.1 处理器与寄存器</h3><ul><li><strong>用户程序可见寄存器</strong>：减少访问主存储器</li><li><strong>控制与状态寄存器</strong></li><li><strong>程序状态字</strong></li></ul><h3 id="指令与处理器模式">2.1.2 指令与处理器模式</h3><ul><li><strong>机器指令</strong>：计算机系统执行的基本命令，中央处理器执行的基本单位</li><li>指令执行过程：取指——解码——执行</li><li>特权指令和非特权指令</li><li>模式切换</li></ul><h2 id="中断管理">2.2 中断管理</h2><h3 id="中断与中断源">2.2.1 中断与中断源</h3><ul><li><strong>==中断==</strong>：程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行的程序，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或者调度其他程序执行的过程</li><li>操作系统是中断驱动的，中断是激活操作系统的唯一方式</li><li>狭义的中断：来源于处理器之外的中断事件，与当前执行指令无关的中断事件</li><li>异常：<u>当前运行指令</u>引起的中断事件=》非正常</li><li>系统异常：执行陷入指令出发系统调用：请求设备、请求I/O、创建进程等</li><li><strong>中断源</strong>：<ul><li>硬件故障</li><li>程序性中断——异常</li><li>自愿性中断——系统调用、陷入指令</li><li>I/O中断事件——IO处理</li><li>外部中断事件——设备引起的中断（时钟、键盘）</li></ul></li></ul><h3 id="中断系统">2.2.2 中断系统</h3><ul><li><p><strong>中断系统</strong>是计算机系统响应并处理中断的系统</p><ul><li>硬件子系统=》中断响应</li><li>软件子系统=》中断处理</li></ul></li><li><p>中断响应处理 =》在每个指令周期的最后进行</p></li><li><p>中断装置：计算机系统发现并相应中断的硬件装置</p><ul><li>处理器以外的中断：中断控制器发现并响应</li><li>处理器以内的异常：指令的控制逻辑和实现线路发现并响应</li><li>请求OS服务的<u>系统异常</u></li></ul></li><li><p>中断控制器：控制部件，中断控制逻辑线路+中断寄存器</p><ul><li>外部设备发出IRQ=》在中断寄存器中设置已发生的中断</li><li>在指令处理结束前，检查中断的产生</li></ul></li><li><p>中断响应过程</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215113158382.png" /></p></li></ul><h3 id="多中断的响应与处理">2.2.3 多中断的响应与处理</h3><ul><li>中断屏蔽可以使中断装置不响应某些中断</li><li>中断优先级决定了中断装置响应中断的次序</li><li>中断嵌套有层数限制</li><li>中断的嵌套处理改变了中断处理的次序（先响应后处理）</li></ul><h2 id="进程管理">2.3 进程管理</h2><h3 id="进程及其状态">2.3.1 进程及其状态</h3><ul><li><p><strong>进程</strong>：一个具有一定独立功能的程序关于某个数据集合的一次运行活动</p></li><li><p>进程是操作系统进行资源分配和调度的一个独立单位</p></li><li><p>一个进程包括五个实体部分：P（管理运行程序的数据结构）、C（内存代码）、D（内存数据）、R（通用寄存器信息）、PSW（程序状态字信息）</p></li><li><p>代码、数据、运行时间的不同都意味着不同的进程</p></li><li><p><strong>状态</strong></p><ul><li><strong>运行态</strong>：进程占有处理器</li><li><strong>就绪态</strong>：进程具备运行条件等待被处理器选中运行</li><li><strong>等待态</strong>：等待资源、输入输出、信号等而不具备运行条件</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215090607700.png" /></p></li><li><p><strong>挂起态</strong>：某些进程被剥夺了内存及其他资源，调入OS管理的对换区，不参加进程调度，等待适当时候再调入内存、恢复资源、参与运行=》 进程挂起（不占据任何资源）</p></li></ul><h3 id="进程的数据描述">2.3.2 进程的数据描述</h3><ul><li><strong>进程控制块</strong>：<code>PCB</code>，OS用于记录和刻画进程状态及环境信息的数据结构，借以全面管理进程的物理实体，刻画进程的执行现状，控制进程的执行<ul><li>标识信息：唯一标识进程</li><li>现场信息：用户可见寄存器、控制与状态寄存器、栈指针内容</li><li>控制信息</li></ul></li><li><strong>进程映像</strong>：某一时刻进程的内容及其执行状态集合。进程映像是内存级的物理实体，又称为进程的内存映像<ul><li>进程控制块</li><li>进程程序块</li><li>进程数据块</li><li>核心栈（内核模式）</li></ul></li><li><strong>进程上下文</strong>：进程物理实体+支持进程运行的环境=》进程上下文<ul><li>用户级上下文</li><li>寄存器上下文</li><li>系统级上下文</li></ul></li></ul><h3 id="进程管理的实现">2.3.3 进程管理的实现</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215105222086.png" /></p><ul><li><p>建立多个进程队列=》就绪队列和等待队列=》先进先出队列和优先队列</p></li><li><p>进程的控制和管理</p></li><li><p>进程控制过程中涉及对OS核心数据结构的修改需要使用原语</p></li><li><p>进程切换</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215111124677.png" /></p></li><li></li></ul><h3 id="多线程技术">2.4 多线程技术</h3><h3 id="多线程环境概述">2.4.1 多线程环境概述</h3><ul><li>单线程结构进程的问题：<ul><li>进程切换开销大</li><li>进程通信开销大</li><li>限制了并发进程的粒度</li><li>降低了并行计算的效率</li></ul></li><li>多线程环境下，<u>进程是OS进行保护和资源分配的基本单位</u>；<u>线程是调度的基本单位</u>，同一个进程中的所有线程共享进程获得的主存空间和资源。</li><li>多线程优点：线程切换快速；减少管理开销；通信易于实现；并行程度提高；节省内存空间</li><li>多线程应用：前后台工作、C/S应用模式、加快执行速度、设计用户接口</li></ul><h3 id="多线程的实现技术">2.4.2 多线程的实现技术</h3><ul><li><p><strong>内核级多线程（KLT）</strong>：线程管理的所有工作由OS内核来做</p><ul><li>线程切换需要内核参与=》模式切换=》系统开销大</li><li>物理并行性问题</li></ul></li><li><p><strong>用户级多线程（ULT）</strong>：线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在</p><ul><li>线程切换不需要内核参与；但是不能利用多处理器的优点，线程的阻塞会引起整个进程的阻塞</li><li>逻辑并行性问题</li></ul></li><li><p><strong>Jacketing技术</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215101225878.png" /></p><ul><li>解决ULT中一个线程的阻塞引起整个进程阻塞的问题</li><li>线程不是直接进行系统调用，而是调用jacketing程序，由jacketing程序来检查线程所需资源是否空闲，如果不空闲的话就进行线程切换（如果不使用jacketing技术，该线程就会陷入系统调用然后被阻塞），当该线程再次被赋予时间片的时候，jacket程序会再次检查资源是否空闲<ul><li>阻塞式系统调用=》非阻塞式</li></ul></li></ul></li><li><p><strong>混合式策略</strong>：组合用户级线程和内核级线程</p><ul><li><p>一个应用中的ULT会被映射到一个或多个KLT上</p></li><li><p>线程的创建、调度和同步完全是在用户空间完成的</p></li><li><p>调度图</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215101829462.png" /></p></li></ul></li></ul><table><thead><tr class="header"><th>内核级线程</th><th>用户级线程</th><th>混合式线程</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215100240015.png" /></td><td><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215100254822.png" /></td><td><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215100312478.png" /></td></tr></tbody></table><h2 id="处理器调度">2.5 处理器调度</h2><h3 id="处理器调度层次">2.5.1 处理器调度层次</h3><ul><li><strong>高级调度（长程/作业调度）</strong>：决定能否加入到执行的进程池中<ul><li>新建态=》就绪态/就绪挂起态</li><li>是否新建？是否加入进程池中？运行前的准备</li></ul></li><li><strong>中级调度（平衡负载调度）</strong>：决定主存中可用的进程集合（挂起相关）<ul><li>为了提高内存利用率和作业吞吐量</li><li>决定哪些进程留在主存中参与处理器竞争，哪些进程换出主存</li></ul></li><li><strong>低级调度（短程/进程调度）</strong>：决定哪个可用进程可以占用处理器执行（核心三态模型之间的调度）</li></ul><h3 id="处理器调度算法">2.5.2 处理器调度算法</h3><ul><li><strong>优先数调度算法</strong>：根据分配给进程的优先数<ul><li>抢占式/非抢占式</li><li>优先数确定准则：任务紧迫程度、交互性、使用外设频率、进入系统时间长短</li><li>计算时间短、剩余计算时间短、响应比（等待时间/进入时间）高优先、先来先服务</li></ul></li><li><strong>时间片轮转调度算法</strong>：根据进入就绪队列的时间先后轮流占有CPU一个时间片</li><li><strong>分级调度算法</strong>：多级队列策略<ul><li><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215103848868.png" /></li></ul></li><li><strong>彩票调度算法</strong>：随机？根据优先级发放彩票数量（优先级高彩票数量多）调度=》随机抽彩票</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/nju-course-review/">nju-course-review</category>
      
      
      <category domain="http://example.com/tags/OS/">OS</category>
      
      
      <comments>http://example.com/2023/02/15/nju-course-review-notes/os/processor-management/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
