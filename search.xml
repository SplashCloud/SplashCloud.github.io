<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>P2: Extensible Hash Table</title>
      <link href="/2024/03/05/cmu15445/23fall-p2/"/>
      <url>/2024/03/05/cmu15445/23fall-p2/</url>
      
        <content type="html"><![CDATA[<h2 id="task-1---readwrite-page-guards">Task #1 - Read/Write PageGuards</h2><p>在Project1的BufferPoolManager中，FetchPage和NewPage这两个API都是直接返回<code>Page *</code>指针。然后通过程序员手动地调用<code>UnpinPage</code>方法来使得页面会处于Evictable的状态，一旦程序员在使用完页面之后忘记调用<code>UnpinPage</code>方法，可能就会导致这个页面一直处于Unevictable的状态而一直留在BufferPool中。</p><p>为了可以避免这个问题，就采用一个数据结构将<code>Page *</code>指针包裹起来——<code>XXPageGuard</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicPageGuard</span> &#123;<br>    BufferPoolManager *bpm_&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    Page *page_&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    <span class="hljs-type">bool</span> is_dirty_&#123;<span class="hljs-literal">false</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>PageGuard</code>中的API实现：1、当Page离开其作用域，不能再被访问到的时候，<code>PageGuard</code>销毁时自动调用<code>UnpinPage</code>；2、程序员可以主动调用<code>Drop()</code>方法告诉BufferPoolManager，将不再使用这个页面。</p><blockquote><p>🚀注意：移动构造函数和移动赋值函数的区别！</p><p>移动赋值函数，赋值等号左边的PageGuard可能已经初始化，正在guard一个page；</p><p>但是对于移动构造函数则不存在这个问题～</p></blockquote><h2 id="task-2---extendible-hash-table-pages">Task #2 - Extendible HashTable Pages</h2><p>如图所示是一个extendible hash table，它的headerpage的最大深度为2，directory page的最大深度为2，而且bucketpages最后存放两个entry。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20231121130310745.png"alt="extensible hash table" /><figcaption aria-hidden="true">extensible hash table</figcaption></figure><h3 id="hash-table-header-page">Hash Table Header Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Header page format:</span><br><span class="hljs-comment"> *  ---------------------------------------------------</span><br><span class="hljs-comment"> * | DirectoryPageIds(2048) | MaxDepth (4) | Free(2044)</span><br><span class="hljs-comment"> *  ---------------------------------------------------</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>由于最大深度是4，所以在headerpage中实际上最多只能存放16<code>(1&lt;&lt;4)</code>个指向directorypage的page id。</p><h3 id="hash-table-directory-page">Hash Table Directory Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Directory page format:</span><br><span class="hljs-comment"> *  --------------------------------------------------------------------------------------</span><br><span class="hljs-comment"> * | MaxDepth (4) | GlobalDepth (4) | LocalDepths (512) | BucketPageIds(2048) | Free(1528)</span><br><span class="hljs-comment"> *  --------------------------------------------------------------------------------------</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>MaxDepth：directory page的最大深度</li><li>GlobalDepth：当前directory page的全局深度，使用了几个bit位</li><li>LocalDepths：对于其中一个bucket page，使用的bit位数</li><li>BucketPageIds：存放指向bucket page的page id</li><li>下图展示了这些概念的含义：</li></ul><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20231121130354461.png"alt="direcotry page" /><figcaption aria-hidden="true">direcotry page</figcaption></figure><h3 id="hash-table-bucket-page">Hash Table Bucket Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Bucket page format:</span><br><span class="hljs-comment"> *  ----------------------------------------------------------------------------</span><br><span class="hljs-comment"> * | METADATA | KEY(1) + VALUE(1) | KEY(2) + VALUE(2) | ... | KEY(n) + VALUE(n)</span><br><span class="hljs-comment"> *  ----------------------------------------------------------------------------</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Metadata format (size in byte, 8 bytes in total):</span><br><span class="hljs-comment"> *  --------------------------------</span><br><span class="hljs-comment"> * | CurrentSize (4) | MaxSize (4)</span><br><span class="hljs-comment"> *  --------------------------------</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li><code>Remove()</code>的实现：考虑两种：1、在移除了key-value之后，做compression，使得<code>[0, size)</code>中始终都是有效的键值对；2、只移除键值对，不做compression，在<code>[0, max_size_)</code>进行Lookup和Insert（如何判断某个entry是空的？）<ul><li><u>使用的是第一种</u></li><li><font color='green'>后面在优化的时候选择了第二种</font></li></ul></li></ul><h2 id="task-3---extendible-hashing-implementation">Task #3 - ExtendibleHashing Implementation</h2><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20231121130310745.png"alt="extensible hash table" /><figcaption aria-hidden="true">extensible hash table</figcaption></figure><blockquote><p><ahref="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">ExtendibleHashing (Dynamic approach to DBMS) - GeeksforGeeks</a></p></blockquote><p>需要实现三个API：</p><ul><li><code>GetValue</code>：只需要从HeaderPage开始向下检索即可。</li><li><code>Remove</code>：<ul><li>MergeBucket：如果做完Remove操作之后，Page变为空，则需要进行Merge；Merge之后还可能需要进行DirectoryShrink。</li><li><strong>MergeBucket只会出现在<code>local_depth==global_depth</code>的bucket上</strong><ul><li>这个是错误的，导致这个想法的本质原因是GetSplitImageIndex的错误实现！！！</li></ul></li></ul></li><li><code>Insert</code>：需要考虑几种情况<ul><li>由于HashTable初始化完之后，只有一个HeaderPage，所以第一个插入的Key-Value，需要新建DirectoryPage和BucketPage。</li><li>如果BucketPage满了的话，需要进行Bucket Split和DirectoryExpansion。</li></ul></li><li>注意点<ul><li>一次SplitBucket可能不能达到目的，Split之后，要插入的页面可能还是满的，需要while循环直到能够顺利插入</li><li>注意GetValue和Remove方法中取出来的directory_page_id和bucket_page_id不一定是有效的（比如在没有插入任何Key-Value就进行GetValue或者Remove）</li><li>Merge和Split的一样，也不是一次就结束的，在完成一次Merge之后需要判断新的BucketPage的SplitImage是否为空（手册中已经给了提示），同样需要while循环</li></ul></li></ul><h2 id="task-4---concurrency-control">Task #4 - Concurrency Control</h2><p>没有什么特殊的，使用Task#1中的API——FetchPageRead和FetchPageWrtie即可。</p><blockquote><p>✋为什么？首先BufferPoolManager是线程安全的，对于public的三个API：Insert、Remove和GetValue，它们执行的过程都是依次获取HeaderPage、DirectoryPage、BucketPage，然后根据Page上的内容做后续的操作。使用FetchPageRead和FetchPageWrite就是得线程在获取到对应的Page的同时也持有Page上的读锁或者写锁，能够在线程持有的时候做到并发控制。</p></blockquote><h2 id="debug">Debug</h2><p>有三个测试一直过不去</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/3aa3032db801492db525e473629feff1.png"alt="failed testcases" /><figcaption aria-hidden="true">failed testcases</figcaption></figure><h3 id="bug1.-inserttest3">BUG1. InsertTest3</h3><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/437c34e242b7410091495b75db09220d.png"alt="InsertTest3" /><figcaption aria-hidden="true">InsertTest3</figcaption></figure><h3 id="bug2.-recursivemergetest">BUG2. RecursiveMergeTest</h3><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/65ba806f00fd4bce80bc21fc997dec27.png"alt="RecursiveMergeTest" /><figcaption aria-hidden="true">RecursiveMergeTest</figcaption></figure><blockquote><p>估计是漏了一次BucketMerge</p></blockquote><h3 id="bug3.-growshrinktest">BUG3. GrowShrinkTest</h3><blockquote><p>原因应该是在一次SplitBucket时，BufferPoolManager的NewPage失败，返回了空指针。</p></blockquote><h3 id="solve1.-没有理解bucketsplit和bucketmerge的真正过程">Solve1.没有理解BucketSplit和BucketMerge的真正过程</h3><blockquote><p>解决了前两个bug！！</p></blockquote><blockquote><p>💬关于<strong>GetSplitImageIndex</strong>函数，之前的理解有误！</p></blockquote><ul><li>首先是对这个函数的含义理解错误：这个函数返回的是这个bucket在前面split的时候同时产生的另一个bucket的索引。所以这个函数应该是用在BucketMerge中的。<ul><li>之前的理解是，用于计算一个bucket在split后产生的新的bucket的索引。</li></ul></li><li>对bucket-spliting和bucket-merging的理解出现偏差<ul><li>将它们简单地理解成了两个bucket merge或者一个bucketsplit。但是一个bucketpage是会涉及多个bucket_idx的，所以要充分考虑所有指向这个bucketpage的bucket_idx。</li><li>本质上，spliting和merging还是local_depth对应的<code>lsb</code>的收缩和扩展，考虑的应该是hash值的最低有效位，而不应该是索引。</li></ul></li></ul><h3 id="slove2.-没有注意bufferpool的size">Slove2.没有注意BufferPool的size</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/ceb9f678f9f84ed09e7eb7273c0359a1.png" /></p><blockquote><p>🍳考虑一个情况：BufferPool的大小只有3个Page时，如果在插入时需要做BucketSplit，会发生什么？</p><p>进而需要考虑：BufferPool的大小为2（Page）时应该怎么办呢？为1呢？最小能为多少呢？</p></blockquote><ul><li>分析对于每个API，[当前实现]一次最多会使用到多少个Page？<ul><li>GetValue：最多3个——Header、Directory、Bucket各一个。</li><li>Insert：最多4个——Header、Directory、Bucket各一个，如果需要进行BucketSplit，在while循环中会多一个BucketPage。</li><li>Remove：最多3个——Header、Directory、Bucket各一个。</li></ul></li><li>这三个API理论上最少需要多少个Page同时在BufferPool中：<ul><li>GetValue：最少只需要一个；可以依次取出HeaderPage、DirectoryPage、BucketPage。</li><li>Insert：最少需要三个；HeaderPage可以Drop掉。Split的时候需要DirectoryPage和BucketPage，以及一个新建的BucketPage</li><li>Remove：最少需要两个；HeaderPage可以Drop掉。Merge的时候需要DirectoryPage和BucketPage</li></ul></li><li>所以，BufferPool的Size最少为3(Page)时，ExtensibleHashTable才能正常工作。</li></ul><h3 id="bug4.-超时">BUG4. 超时</h3><p>但是这个test仍然无法通过，原因是超时！！</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/362bfec3df554ebea7891ffe6ab1668d.png" /></p><p>似乎是真的太慢了？猜测应该是BucketPage里的Insert和Remove实现太慢了</p><p>改进了BucketPage存储data的方式，添加一个bitmap，bitmap[i]表示array中index为i的键值是否为空，这样最坏情况下只需要<code>[0, max_size_]</code>的遍历。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/698d4605c4d44b2b9a1db8aa2409b165.png" /></p><blockquote><p>好消息：变快了；坏消息：还是超时？！</p></blockquote><hr /><blockquote><p>🙌需要明确的是：修改几千次就需要30s以上，确实是某些地方实现不恰当？</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/1fac9ef504da409985ec6c1de3a32c76.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/477594a624af4dd2a5c769d2b7c8922c.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/b441e26013554d529327e077ba26de98.png" /></p><p>在本地统计了一下每insert/remove and lookup 10keys所需要的时间，可以看到无论是insert还是remove，越往后所需要的时间越多。</p><h2 id="完结">完结！</h2><p>经过接近一个星期的Debug，终于通过了！！</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/7af50da14006455a8ea7f53ba44eb476.png"alt="pass" /><figcaption aria-hidden="true">pass</figcaption></figure><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/9223079ff77142da960bd1b53ba8c951.png" /></p><p>在重新实现了P1的BufferPoolManager之后，顺利通过了P2，在重写的时候优化了LRUKNode里对访问记录的存储：</p><ul><li>之前是：一股脑全部存进<code>history_</code></li><li>优化后：<code>history_</code>中只存放最近的十条访问记录</li></ul><p>下面是优化前后，ExtensibleHashTable运行过程中在LRUKNode的Access中打印出来的日志：优化前，history_中要存放6000左右个访问记录，而优化后只需要10个；而且在1500次左右的Insert-and-Lookup和Remove-and-Lookup的操作中，有18000次对Node的访问操作。</p><p>原因可能是：<code>history_</code>中存储过多的数据，导致内存频繁换页，空间局部性丢失。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/ff1e000ebffa40668b9d12027d2c1657.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/b6784331635644f59a0f5b40e8f5d3b9.png" /></p>]]></content>
      
      
      <categories>
          
          <category> CMU 15445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 15445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript</title>
      <link href="/2024/03/05/front-end-technology/ECMAScript/"/>
      <url>/2024/03/05/front-end-technology/ECMAScript/</url>
      
        <content type="html"><![CDATA[<h1 id="ecmascript">ECMAScript</h1><h2 id="概述">1 概述</h2><p>ECMA是一个组织，制定了一些标准，然后JS去实现这些标准。</p><p>ES2015兼容性：IE10+、Chrome、FireFox、移动端、NodeJS</p><p>由于兼容性问题，对于一些版本较低的设备，就需要使用一些方法使得ES6的代码可以运行起来</p><p>1、浏览器打开页面时，对ES6代码进行转换。</p><p>2、先将ES6代码编译为可以被低版本设备接收的代码，再拿去执行。</p><h2 id="letconst和块级作用域">2 let/const和块级作用域</h2><p>之前的JS中只有<code>var</code>可以声明变量，但是<code>var</code>存在一些问题：</p><ol type="1"><li>可以重复声明 =》混乱</li><li>无法限制修改 =》 想要声明常量全凭自觉</li><li>没有块级作用域（只有函数作用域）</li></ol><p>对于第3个问题，下面举一个例子说明</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> arr = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)&#123;<br>        arr.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> i*i;<br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">var</span> resluts = <span class="hljs-title function_">func</span>()<br><span class="hljs-keyword">var</span> f1 = results[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> f2 = resluts[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">var</span> f3 = resluts[<span class="hljs-number">2</span>];<br><br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// 16</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 16</span><br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><p>这个现象就是由于<code>var</code>没有块级作用域引起的。由于函数内部都引用了变量<code>i</code>，但是函数并不是立刻执行的，等到<code>results[0]</code>需要返回的时候，<code>i</code>已经变成3了，所以都输出了<code>9</code>。</p><p>一种解决方法是使用闭包来解决，创建一个匿名函数并立刻执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> arr = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)&#123;<br>        arr.<span class="hljs-title function_">push</span>( <br>            (<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                    <span class="hljs-keyword">return</span> n * n;<br>                &#125;<br>            &#125;)(i)<br>                );<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">var</span> resluts = <span class="hljs-title function_">func</span>()<br><span class="hljs-keyword">var</span> f1 = results[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> f2 = resluts[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">var</span> f3 = resluts[<span class="hljs-number">2</span>];<br><br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 4</span><br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure></blockquote><p>ES6引入<code>let</code>和<code>const</code>关键字，可以有效解决上面三个问题。</p><ol type="1"><li>使用<code>let</code>和<code>const</code>声明变量，不能重复声明</li><li><code>const</code>声明常量，不能修改</li><li><code>let</code>和<code>const</code>都是块级作用域，要解决上面的问题，只要将<code>for(var i...)</code>改成<code>for(let i...)</code>即可。</li></ol><h2 id="解构赋值">3 解构赋值</h2><p>解构赋值是对赋值操作符的扩展，从字面意思上理解，就是把复杂对象拆分开给其他变量赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// a=1, b=2, c=3</span><br><span class="hljs-keyword">let</span> [a, ...b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// a=1, b=[2,3]</span><br><br><span class="hljs-keyword">let</span> &#123;x, y, z&#125; = &#123;<span class="hljs-attr">x</span>:<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-attr">y</span>:<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-attr">z</span>:<span class="hljs-string">&quot;z&quot;</span>&#125;; <span class="hljs-comment">// x=&quot;x&quot;, y=&quot;y&quot;, z=&quot;z&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab2 System Call</title>
      <link href="/2024/03/05/6.S081/6.S081-lab2-syscall/"/>
      <url>/2024/03/05/6.S081/6.S081-lab2-syscall/</url>
      
        <content type="html"><![CDATA[<h2 id="preview">1. Preview</h2><h3 id="xv6-book-chap2">1.1 xv6-book Chap2</h3><p>xv6-book的第二章和lecture3的内容类似，主要介绍了操作系统的组织结构，从物理资源的抽象、用户态/内核态、系统调用、微内核/宏内核以及代码层面展开</p><p>xv6-book的4.3、4.4节讲的是如何进行系统调用</p><h3 id="code">1.2 code</h3><p>了解xv6启动过程</p><p><code>_entry.S</code>中将<code>stack0+4096</code>赋给栈指针寄存器<code>sp</code>，使得其指向栈顶，然后<code>call start</code></p><p><code>start</code> =&gt; <code>main</code> =&gt;<code>userinit</code> =&gt; <code>initcode.S</code> =&gt;<code>init.c</code></p><h2 id="system-call-tracing">2 System call tracing</h2><p><code>trace</code>是一个工具，能够记录指定的系统调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">trace 32 grep hello README</span><br>3: syscall read -&gt; 1023<br>3: syscall read -&gt; 966<br>3: syscall read -&gt; 70<br>3: syscall read -&gt; 0<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令的格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">trace [MASK] [OPTIONS...] <span class="hljs-comment"># 其中[MASK]是一个数字n; 如果 (n &gt;&gt; i) &amp; 1 == 1 表示i号系统调用需要trace</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出的形式</span><br>[pid]: syscall &lt;name&gt; -&gt; &lt;return_value&gt;<br></code></pre></td></tr></table></figure><p>首先需要明确的是<code>trace</code>也是一个系统调用，所以就需要大概明白从用户态调用<code>trace</code>工具到内核调用对应的系统调用的过程。</p><p>根据手册的指示大概能够推测出来</p><p>1、在命令行中输入：<code>trace 32 grep hello README</code>后，实际上是执行 /user/trace.c 文件。过程就是 先执行 <code>trace</code>函数，然后再执行后面的命令。</p><p>2、这个 trace 函数是需要在 /user/user.h文件中定义原型的，之后好像就找不到对应的实现了。其实之后的实现是在内核态了，需要先陷入内核，手册中说要在/user/usys.pl 中定义一个 stub: <code>entry("trace")</code>，这个stub会在user/usys.S 生成一段汇编代码：进行系统调用。</p><p>3、其中的<code>ecall</code>指令就会调用 /kernel/syscall.c 中的<code>syscall</code> 函数，执行对应的系统调用函数 sys_<name></p><p>然后就可以开始根据手册的提示写代码了...</p><ol type="1"><li>在 kernel/sysproc.c 中增加 sys_trace() 函数</li><li>要在 proc 结构体中增加一个新的变量存储 trace 的参数</li><li>修改 syscall() 函数来打印 trace 输出</li><li>修改 fork() 函数使得 trace 的参数从父进程拷贝到子进程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在 kernel/sysproc.c 中增加 sys_trace 函数</span><br>uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">if</span>( argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span> )&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// parse the `n` to get which sys_call need to be traced</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>  p-&gt;trace_mask = n;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 修改 kernel/syscall.c 中的 syscall 函数</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7; <span class="hljs-comment">// a7: sys_call number</span><br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    <span class="hljs-comment">// add the trace check</span><br>    <span class="hljs-keyword">if</span>( (( p-&gt;trace_mask &gt;&gt; num ) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> )&#123; <span class="hljs-comment">// need to trace</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sys_call_names[num], p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><blockquote><p>注意第四个测试有可能会超时，需要修改 gradelib.py 文件的第 428 行扩大时间限制</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212319005.png" /></p><h2 id="sysinfo">3 Sysinfo</h2><p>还是实现一个系统调用，在内核填上 <code>struct sysinfo</code>的两个字段，并拷贝回用户空间，主要过程：</p><ol type="1"><li>像<code>trace</code>那样，在对应位置增加系统调用所需的相关信息。</li><li>在 <code>kernel/proc.c</code> 中增加一个统计<code>not UNUSED process</code> 的函数</li><li>在 <code>kernel/kalloc.c</code> 中增加一个统计<code>free memory</code> 的函数</li><li>理解 <code>copyout</code> 函数，在系统调用中将<code>struct sysinfo</code> 从内核空间 拷贝入 用户空间</li></ol><p>核心代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// need to copy the sysinfo struct from kernel space to user space</span><br>uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  uint64 addr;<br>  <span class="hljs-keyword">if</span>( argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> )&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">si</span>;</span><br>  si.nproc = notunusedproc();<br>  si.freemem = freemem();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">if</span>( copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)(&amp;(si)), <span class="hljs-keyword">sizeof</span>(si)) &lt; <span class="hljs-number">0</span> )&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>统计 不是 UNUSED 的 进程数量，只需要遍历 proc 数组即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">notunusedproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NPROC; i++)&#123;<br>    <span class="hljs-keyword">if</span>(proc[i].state != UNUSED)&#123;<br>      num++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><p>统计 free memory，需要读一下 <code>kalloc.c</code> 的代码，会发现 在<code>kalloc</code> 函数中，如果 <code>kmem.freelist</code>不为空的话就会分配一个 <code>PGSIZE</code> 的内存空间，所以只需要统计<code>kmem.freelist</code> 链表长度即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">freemem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>* <span class="hljs-title">r</span> =</span> kmem.freelist;<br>  <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(r)&#123;<br>    r = r-&gt;next;<br>    num++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> num * PGSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212340499.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 6.S081-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab1 Utilities</title>
      <link href="/2024/03/05/6.S081/6.S081-lab1-utils/"/>
      <url>/2024/03/05/6.S081/6.S081-lab1-utils/</url>
      
        <content type="html"><![CDATA[<h3 id="搭建lab环境">1、搭建lab环境</h3><h4 id="安装工具包">1、安装工具包</h4><p>使用的是之前跑在 VirtualBox 上的 Ubuntu 虚拟机 版本 20.04.5 TLS</p><p>然后按照<ahref="https://pdos.csail.mit.edu/6.828/2021/tools.html">官网</a>上的指令下载对应的工具包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></code></pre></td></tr></table></figure><p>完成之后可以测试一下</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212121280.png" /></p><p>然后到<ahref="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">lab页</a>clone相应的代码</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212134633.png" /></p><p>最后执行 <code>make qemu</code>，出现</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212150813.png" /></p><p>即为搭建成功</p><h4 id="gdb调试过程">2、gdb调试过程</h4><p>1、打开两个cmd窗口</p><p>2、其中一个输入：make qemu-gdb</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212206029.png" /></p><p>3、另一个输入：gdb-multiarch kernel/kernel</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212223488.png" /></p><p>4、可以使用gdb命令进行调试了</p><h3 id="book-riscv-chapter-one">2、book-riscv Chapter One</h3><h3 id="sleepeasy">3、sleep（easy）</h3><p>这个函数比较简单，使用系统调用 sleep</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;too few arguments...&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pingpongeasy">3、pingpong（easy）</h3><p>这个函数的实现需要重点理解<code>pipe</code>函数（xv6-book的ChapterOne）</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212234931.png" /></p><p>感性的理解，<code>pipe</code>就是创建了一个管道，使得两个进程之间可以通信（互相读取到对方写的数据）</p><p>实际上，<code>pipe</code>在传入的数组<code>p</code>里存放一个<code>read file descriptor</code>(<code>p[0]</code>)和<code>write file descriptor</code>(<code>p[1]</code>)</p><p>就像管道的一头一尾，从"头部"写入数据，可以从"尾部"读取数据</p><p>而由于<code>fork</code>创建的子进程也会带着这个数组<code>p</code>，从而可以实现父子进程的通信</p><p>（具体细节参见<ahref="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6-book</a>的相应部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-type">char</span> * parent_msg = <span class="hljs-string">&quot;p&quot;</span>;<br>    <span class="hljs-type">char</span> * child_msg  = <span class="hljs-string">&quot;c&quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">2</span>];<br><br>    pipe(p);<br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br>        close(p[<span class="hljs-number">0</span>]);<br>        write(p[<span class="hljs-number">1</span>], child_msg, <span class="hljs-number">1</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        write(p[<span class="hljs-number">1</span>], parent_msg, <span class="hljs-number">1</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>        read(p[<span class="hljs-number">0</span>], buffer, <span class="hljs-number">1</span>);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="primesmoderatehard">4、primes（moderate/hard）</h3><p><code>primes</code>函数是借助<code>pipeline</code>实现了一个素数筛。</p><p>需要好好理解下面<ahref="https://swtch.com/~rsc/thread/">这幅图</a>和上面的<code>pipe</code></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029212246450.png" /></p><p>思想：在每个进程中，选取一个素数<code>N</code>（就是通过管道读到的第一个数），然后把所有读到的数中不能被整除<code>N</code>的数继续通过管道写进下一个进程中，而把可以整除的数<code>drop</code>掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> * p)</span>&#123;<br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>    p1[<span class="hljs-number">0</span>] = p[<span class="hljs-number">0</span>]; p1[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>];<br><br>    pipe(p); <span class="hljs-comment">// create the new pipeline connect the it and the it&#x27;s child</span><br><br>    <span class="hljs-type">char</span> num[<span class="hljs-number">1</span>];<br>    close(p1[<span class="hljs-number">1</span>]); <span class="hljs-comment">// close the old write</span><br>    <span class="hljs-keyword">if</span>( read(p1[<span class="hljs-number">0</span>], num, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> )&#123;<br>        <span class="hljs-type">int</span> prime = num[<span class="hljs-number">0</span>]; <span class="hljs-comment">// the first number is the prime</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, prime);<br><br>        <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>            func(p); <span class="hljs-comment">// recursion</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// close the read</span><br>            <span class="hljs-keyword">while</span> ( read(p1[<span class="hljs-number">0</span>], num, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> )&#123;<br>                <span class="hljs-type">int</span> n = num[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span>(n % prime != <span class="hljs-number">0</span>)&#123;<br>                    write(p[<span class="hljs-number">1</span>], num, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            close(p1[<span class="hljs-number">0</span>]);<br>            close(p[<span class="hljs-number">1</span>]);<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// no data avaliable</span><br>        close(p[<span class="hljs-number">0</span>]);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br><br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>      func(p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> num[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++)&#123;<br>            num[<span class="hljs-number">0</span>] = i;<br>            write(p[<span class="hljs-number">1</span>], num, <span class="hljs-number">1</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="findmoderate">5、find（moderate）</h3><p><code>find</code>函数的实现需要先去学习一下<code>ls</code>函数的实现，主要是学习如何读取目录的，读懂了之后难度不是很大，需要注意一些细节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">// Look at user/ls.c to see how to read directories.</span><br>    <span class="hljs-comment">// Use recursion to allow find to descend into sub-directories.</span><br>    <span class="hljs-comment">// Don&#x27;t recurse into &quot;.&quot; and &quot;..&quot;.</span><br>    <span class="hljs-comment">// Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</span><br>    <span class="hljs-comment">// You&#x27;ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</span><br>    <span class="hljs-comment">// Note that == does not compare strings like in Python. Use strcmp() instead.</span><br>    <span class="hljs-comment">// Add the program to UPROGS in Makefile. </span><br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *dir, <span class="hljs-type">char</span> *file)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br><br>    <span class="hljs-comment">// put the dir_name into the buf</span><br>    <span class="hljs-comment">// buf : dir_name/</span><br>    <span class="hljs-built_in">strcpy</span>(buf, dir);<br>    p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span>( (fd = open(dir, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span> )&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span> )&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, dir);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(st.type != T_DIR)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: %s is not a dir\n&quot;</span>, dir);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// read the every file or dir in the `dir` sequentially</span><br>    <span class="hljs-keyword">while</span>( read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>        <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">char</span> *name = de.name;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// not consider the . and ..</span><br><br>        memmove(p, name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, name);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(st.type == T_DIR)&#123;<br>            find(buf, file);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(name, file) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>        &#125;<br>    &#125;<br>    close(fd);<br>&#125;<br><br><span class="hljs-comment">// find &lt;dir_name&gt; &lt;file_name&gt;</span><br><span class="hljs-comment">// find all the &lt;file_name&gt; in the &lt;dir_name&gt;</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;the arguments is too few...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xargsmoderate">6、xargs（moderate）</h3><p>首先需要知道这个命令是干什么的。</p><blockquote><p>Run COMMAND with arguments INITIAL-ARGS and more arguments read frominput.</p></blockquote><p>总的来说就是<strong>用来跑其他命令的，而参数从输入中读取</strong>。</p><p>从实验手册上的要求和例子来看，实现的是一个只带<code>-n</code>参数且参数值只为1的<code>xargs</code>命令</p><p>这里的<code>-n</code>的意思是执行命令最大能够从输入读取的参数个数，如果<code>-n 1</code>就意味着只能从输入读取一个参数执行命令，所以就意味着会执行多次命令（需要把读取的参数用完）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> hello too | xargs <span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span></span><br>bye hello too<br><span class="hljs-meta prompt_">$</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="hljs-built_in">echo</span> line</span><br>line 1<br>line 2<br><span class="hljs-meta prompt_">$</span><br></code></pre></td></tr></table></figure><p>理解了<code>xargs</code>的作用和实现的细节，就可以开始写代码了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">author: zhhc</span><br><span class="hljs-comment">date:   2022-10-09</span><br><span class="hljs-comment">time-spent: about 3 hours</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> seq_num = MAXARG;  <span class="hljs-comment">// the max_args per cmd</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">exec1</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span>&#123;<br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>        exec(argv[<span class="hljs-number">0</span>], argv);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;too few arguments...&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>]; <span class="hljs-comment">// store the input from the previous cmd</span><br>    <span class="hljs-type">int</span> read_n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> read_total = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// attention: if exits &#x27;\n&#x27;, just a read can not read all</span><br>    <span class="hljs-keyword">while</span>( (read_n = read(<span class="hljs-number">0</span>, buf + read_total, <span class="hljs-number">512</span>)) &gt; <span class="hljs-number">0</span> )&#123;<br>        read_total += read_n; <span class="hljs-comment">// stat the number of input</span><br>    &#125;<br>    <span class="hljs-type">int</span> len = read_total;<br><br>    <span class="hljs-comment">// switch all the &#x27;\n&#x27; to &#x27; &#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>) buf[i] = <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> cmd_ptr = <span class="hljs-number">1</span>; <span class="hljs-comment">// the ptr to cmd</span><br>    <span class="hljs-type">bool</span> is_set_n = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// set the max args</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-n&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>        is_set_n = <span class="hljs-literal">true</span>;<br>        cmd_ptr = <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span>* cmd_argv[MAXARG]; <span class="hljs-comment">// the cmd argv</span><br>    <span class="hljs-comment">// put the arg into the cmd_argv</span><br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cmd_ptr; i &lt; argc; i++) &#123;<br>        <span class="hljs-type">char</span> *arg = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(argv[i])+<span class="hljs-number">1</span>); <span class="hljs-comment">// attention: must use malloc, put the data in heap</span><br>        <span class="hljs-comment">// if use char arg[MAXARG] will cause the error</span><br>        <span class="hljs-built_in">strcpy</span>(arg, argv[i]);<br>        cmd_argv[idx] = arg;<br>        idx ++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(is_set_n)&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> arg[MAXARG];<br>        <span class="hljs-built_in">memset</span>(arg, <span class="hljs-number">0</span>, MAXARG); <span class="hljs-comment">// clear the space</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// can spilt out a arg</span><br><br>                arg[index++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                cmd_argv[idx++] = arg;<br><br>                <span class="hljs-comment">// run</span><br>                exec1(cmd_argv);<br><br>                index = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">memset</span>(arg, <span class="hljs-number">0</span>, MAXARG); <span class="hljs-comment">// clear the space</span><br><br>                idx --;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            arg[index ++] = buf[i];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// should spilt the args with &#x27; &#x27;</span><br>        <span class="hljs-comment">// and put them into cmd_argv sequentially</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(buf[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-type">char</span>* add_arg = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(i - prev);<br>                <span class="hljs-built_in">memcpy</span>(add_arg, buf+prev, i - prev);<br>                prev = i+<span class="hljs-number">1</span>; <span class="hljs-comment">// attention</span><br>                cmd_argv[idx++] = add_arg;<br>            &#125;<br>        &#125;<br>        exec1(cmd_argv);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>记录一个小问题</p><p>发生在将argv里的参数拷贝到cmd_argv的过程中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>    <span class="hljs-type">char</span> agr[<span class="hljs-number">32</span>]; <span class="hljs-comment">// 每次分配到的地址都是一样的！！！</span><br>    cmd_argv[idx ++] = <span class="hljs-built_in">strcpy</span>(arg, argv[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>数组空间是分配在栈中的，而且一次迭代之后空间失效，再次分配时就会分配相同的地址空间，导致cmd_argv中的指针值都是一样的，然后strcpy就是在不断地改变那块地址中的内容。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 6.S081-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次重装Ubuntu双系统</title>
      <link href="/2023/11/01/Linux/%E9%87%8D%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/11/01/Linux/%E9%87%8D%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>原因是在写ics2023的pa2时，遇到了问题始终无法解决，由于当时的系统版本是ubuntu21.04，而手册是ubuntu22.04，所以认为可能是系统版本的问题，于是想要更换系统版本。按理说只需要升级一下Ubuntu即可，但是尝试了若干种方式都无法成功升级，于是只能删掉原有的ubuntu21.04，装上新的ubuntu22.04.</p><h2 id="删除双系统">删除双系统</h2><blockquote><p><ahref="https://blog.csdn.net/yldmkx/article/details/103949640">Windows和ubuntu双系统“彻底”删除ubuntu系统_ubuntu系统删除microsoft基本数据-CSDN博客</a></p></blockquote><h2 id="安装双系统">安装双系统</h2><p>绝世好文，两次安装双系统都是参考这篇文章</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/407175785">Win10 下安装Ubuntu21.04桌面版 双系统 并设置win10为默认启动系统 详细教程</a></p></blockquote><p>不过在进入系统启动菜单的时候，按<code>F2</code>或者<code>F12</code>都没用，结果是关机之后戳耳机孔边上的小洞才会进入系统启动菜单。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/16988307940501.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="配置新环境">配置新环境</h2><blockquote><p>遇到了两个比较棘手的问题</p></blockquote><h3 id="apt-get-install的unmet-dependencies-error">apt-getinstall的Unmet Dependencies Error</h3><p>在使用<code>apt-get install</code>安装依赖包的时候，总是会出现<code>unmeet dependencies</code>。就是要安装这个包，这个包的依赖包没有装上，所以这个包装不上。</p><blockquote><p>https://appuals.com/fix-unmet-dependencies-error-ubuntu/</p></blockquote><p>最后是使用<code>aptitude</code>这个工具，它会针对出现的依赖问题，给出解决方案，最后能够成功装上依赖包。</p><h3 id="git的openssl编译">git的openssl编译</h3><blockquote><p>gnutls_handshake() failed: The TLS connection was non-properlyterminated</p></blockquote><p>经常会在装完ubuntu系统之后<code>git clone</code>出现这种错误，无论是虚拟机还是真机。一查解决方案，大都是不痛不痒的<code>git config</code>一些东西。然而真正的原因是<code>gnutls</code>这个包的效果不够好，应该换成<code>openssl</code>。</p><blockquote><p><ahref="https://askubuntu.com/questions/186847/error-gnutls-handshake-failed-when-connecting-to-https-servers">"error:gnutls_handshake() failed" when connecting to https servers</a></p></blockquote><p>那么如何用openssl重新编译git呢？有大佬制作好了<code>shell</code>脚本放在了Github上</p><blockquote><p>https://github.com/paul-nelson-baker/git-openssl-shellscript</p></blockquote><p>但是，由于前面<code>apt-get install</code>的问题，需要对脚本进行一些修改，即<code>apt-get</code>-&gt;<code>aptitude</code>，并且去掉后面<code>-y</code>，这样就能在安装依赖包的时候选择想要的解决方案（因为<code>aptitude</code>大部分情况下默认解决方案是啥都不干）</p><blockquote><p>所幸，安装完新系统之后，问题得到了解决！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为git添加ssh</title>
      <link href="/2023/03/08/others/%E5%A2%9E%E5%8A%A0ssh/"/>
      <url>/2023/03/08/others/%E5%A2%9E%E5%8A%A0ssh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>应项目要求，需要为<code>Git</code>配置<code>SSH</code>密钥</p></blockquote><h3 id="生成ssh密钥">生成SSH密钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 2048 -C &quot;201250150@smail.nju.edu.cn&quot;<br></code></pre></td></tr></table></figure><p>输入命令后，会在对应的<code>.ssh</code>文件夹下生成两个文件<code>id_rsa</code>和 <code>id_rsa.pub</code></p><h3 id="将公钥拷贝到gitlab账户">将公钥拷贝到GitLab账户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub | clip # 将公钥拷贝至剪贴版<br></code></pre></td></tr></table></figure><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230308104505040.png" /></p><h3 id="配置git">配置Git</h3><blockquote><p>注意对Git版本有要求：&gt;= 2.34.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git update-git-for-windows<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config [--global] gpg.format ssh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config [--global] user.signingkey ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h3 id="使用ssh密钥签署提交">使用ssh密钥签署提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -S -m &quot;My commit msg&quot; # -S 表示签署提交时使用标志<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web前端复习</title>
      <link href="/2023/02/22/nju-course-review-notes/web%E5%89%8D%E7%AB%AF/"/>
      <url>/2023/02/22/nju-course-review-notes/web%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="密码加密">密码加密</h2><ul><li>可逆加密算法：加密后可以解密得到密码原文</li><li>对称加密：加密、解密使用相同的密钥<ul><li>加密速度快；不安全；AES；DES</li></ul></li><li>非对称加密：加密使用公钥、解密使用私钥<ul><li>安全性高；加密时间长；RSA；DSA</li></ul></li><li>不可逆加密算法：加密后不能反向解密<ul><li>存储密码等用户敏感信息；MD5；SHA</li></ul></li></ul><h2 id="前端鉴权">前端鉴权</h2><blockquote><p>认证、授权、鉴权和权限控制是一个前后依次发生、上下游的关系</p><p>1.认证 =》2.授权=》3.鉴权=》4.权限控制</p></blockquote><ul><li>认证：根据声明者所特有的识别信息确认声明者的身份</li><li>授权：资源所有者赋予执行者指定范围的资源操作权限，以便对资源的相关操作</li><li>鉴权：对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程</li><li>权限控制：将可执行的操作定义为权限列表并判断操作是否允许/禁止</li></ul><h3 id="http基本鉴权">HTTP基本鉴权</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219161544843.png" /></p><ul><li>优点：简单</li><li>缺点：不安全（用户名密码裸露）；无法主动撤销</li><li>使用场景：对安全要求不高的网络（内部网络）</li></ul><h3 id="session-cookie鉴权">Session-Cookie鉴权</h3><blockquote><p>服务端的Session和浏览器端的Cookie</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219161844528.png" /></p><ul><li>优点：Cookie简单易用；Session相较于JWT方便管理；后端操作即可</li><li>缺点：依赖Cookie（禁用就会失效）；Cookie不安全；Session增大服务端开销；</li><li>使用场景：中大型的网站</li></ul><h3 id="token">Token</h3><blockquote><p>访问资源接口需要的资源凭证</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219162244318.png" /></p><ul><li>优点：服务端无状态化、可扩展性好；支持APP移动端设备；不需要Cookie，安全性好，支持跨程序调用；</li><li>缺点：需要前后端配合；占带宽（比sid更大）；有效期短；性能问题（需要对token加密解密）</li></ul><h3 id="refresh-token">Refresh Token</h3><blockquote><p>用来获取Access Token，有效期比Access Token长一些</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219163335945.png" /></p><h3 id="jwt鉴权">JWT鉴权</h3><blockquote><p>对用户信息组成JSON对象然后进行加密签名实现授权验证的方案</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219163533415.png" /></p><ul><li>优点：不需要在服务端保存会话信息</li><li>缺点：加密问题；到期问题（无法废止Token或更改Token）</li></ul><h3 id="cookie和session">Cookie和Session</h3><ul><li>安全性：Cookie保存在客户端，可以被随意篡改</li><li>存取值的类型：Cookie只支持字符串数据；Session可以存放任意数据</li><li>有效期不同：Cookie可以设置长时间保持；Session一般失效时间短</li><li>存储大小不同：Cookie保存数据不能超出4K</li></ul><h3 id="token和session">Token和Session</h3><ul><li>存储位置不同：Token存储在前端，Session存储在后端</li><li>安全性：Token安全性更好，因为每个请求都有签名</li><li>支持性不同：Session-Cookie认证需要浏览器的Cookie机制实现；Token验证机制丰富了客户端类型</li></ul><h3 id="登录方案">登录方案</h3><ul><li>单点登录（SSO: Single SignOn）登录一次就可以访问其他相互信任的应用系统</li><li>OAuth2.0：允许用户授权第三方网站访问他们存储在另外的服务提供者的信息，而不需要将用户名和密码提供给第三方网站</li><li>联合登录和信任登录</li><li>唯一登录：禁止多人同时登录统一账号</li><li>扫码登录</li><li>一键登录：短信验证码</li></ul><h2 id="前端性能优化">前端性能优化</h2><blockquote><p>要点，常用术语，浏览器渲染机制，性能分析方法，最佳实践</p></blockquote><blockquote><p><strong>看PPT</strong></p></blockquote><h3 id="浏览器页面渲染机制">浏览器页面渲染机制</h3><ul><li>DNS查询 =》TCP握手 =》TLS（Transport Layer Security）协商=》TCP慢启动（14KB规则）</li><li>第一步：处理HTML标记并构造DOM树，HTML解析涉及到 tokenization和树的构造（<code>&lt;script&gt;</code>标签会阻塞HTML的解析）</li><li>第二步：处理CSS并构建CSSOM树，遍历CSS中每个规则集，根据选择器创建具有父、子和兄弟关系的节点数</li><li>第三步：将DOM和CSSOM组合成一个Render树，计算样式树或渲染树从DOM树的根节点开始构建，遍历每个可见节点</li><li>第四步：在渲染树上运行布局以计算每个节点的几何体<ul><li>第一次确定节点大小和位置称为布局；随后对节点大小和位置的重新计算称为回流</li></ul></li><li>最后一步：将各个节点绘制到屏幕上，将在布局阶段计算的每个框转换为屏幕上的实际像素</li><li>TTI（Time To Interactive）第一个请求导致DNS和SSL 到 页面可交互所用的时间</li><li>关键渲染路径（Critical RenderPath）优化策略使浏览器能够通过确定优先加载的资源以及资源加载的顺序来尽可能快地加载页面</li></ul><h3 id="性能优化">性能优化</h3><ul><li>延迟与带宽：传播/传输/处理/排队延迟</li><li>web性能要点<ul><li>延迟和带宽对web性能的影响</li><li>传输协议（TCP）对HTTP的影响</li><li>HTTP协议自身的缺陷</li><li>Web应用的发展趋势及性能需求</li><li>浏览器局限性和优化思路</li></ul></li><li>性能要素：计算、渲染、网络<ul><li>三个任务：获取资源、页面布局和渲染、js执行</li><li>更多带宽并不重要；延迟是性能瓶颈</li></ul></li><li>性能监控指标<ul><li>首屏时间</li><li>用户可交互时间</li><li>总下载时间</li><li>FP（First Paint）、FCP（First Content Paint）（DOM内容）、FMP（FirstMeaningful Paint）（关键元素）</li></ul></li><li>浏览器优化<ul><li>基于文档的优化：提前获取资源，提前解析</li><li>推测性优化：预先解析DNS、预先连接可能的目标</li></ul></li><li>（<strong>最佳实践</strong>）两个准则<ul><li>消除或减少不必要的网络延迟</li><li>将需要传输的数据压缩至最少</li></ul></li><li>性能准则<ul><li>减少DNS查找</li><li>重用TCP连接</li><li>减少HTTP重定向</li><li>使用CDN（Content Distributed Network 内容分发网络）</li><li>去掉不必要的资源</li></ul></li><li>其他准则<ul><li>在客户端缓存资源</li><li>传输压缩过的内容</li><li>消除不必要的请求开销</li><li>并行处理请求和响应</li><li>针对协议版本采取优化措施<ul><li>针对HTTP1.x优化建议<ul><li>采用HTTP管道</li><li>采用域名分片</li><li>打包资源以减少HTTP请求</li><li>嵌入小资源</li></ul></li><li>针对HTTP2的优化<ul><li>少发数据，减少请求，减少传输数据量和不必要网络延迟，调整资源供给</li><li>每个来源一个链接，去掉不必要资源打包，利用服务器推送</li></ul></li></ul></li></ul></li></ul><h2 id="http">HTTP</h2><blockquote><p>基本原理、为何演进、常见的请求方法、头域、状态码</p></blockquote><h3 id="头域">头域</h3><p>由主键/值对组成，描述客户端或者服务器的属性、被传输的资源以及应该实现的连接</p><p>四种不同类型的头标</p><ul><li>通用头标：即可用于请求，也可以用于响应，是作为一个整体而不是特定资源与事务相关联</li><li>请求头标：允许客户端传递关于自身的信息和希望的响应形式</li><li>响应头标：服务器用于传递自身信息的响应</li><li>实体头标：定义被传送资源的信息，即可用于请求，也可以用于响应</li></ul><h3 id="状态码">状态码</h3><ul><li>1xx：信息响应</li><li>2xx：成功响应</li><li>3xx：重定向消息<ul><li>301：永久重定向</li></ul></li><li>4xx：客户端错误响应<ul><li>400：请求错误</li><li>401：未认证</li><li>403：未授权禁止访问</li><li>404：找不到</li></ul></li><li>5xx：服务端错误响应<ul><li>500：服务器内部错误</li></ul></li></ul><h3 id="请求方法">请求方法</h3><ul><li>GET：从服务器获取URL对应资源</li><li>POST：修改URL对应资源</li><li>PUT：修改或创建资源</li><li>DELETE：删除资源</li><li>HEAD：获取少量信息</li></ul><h3 id="http的演进">HTTP的演进</h3><ul><li>HTTP/1.x：报文有一些性能上的缺点：Header无法压缩；相似header的报文重复传输；无法复用</li><li>HTTP/2：通过启用完整的请求和响应多路复用来减少延迟，通过有效压缩HTTP标头字段来最小化协议开销，并增加对请求优先级和服务器推送的支持</li><li>HTTP/3：TCP队头阻塞问题、TCP握手时长问题、移动场景的网络切换成本</li></ul><h3id="影响http常见的与tcp相关的延迟">影响HTTP常见的与tcp相关的延迟</h3><ul><li>TCP连接握手</li><li>TCP慢启动拥塞控制</li><li>Nagle的数据聚合算法</li><li>TCP用于承载确认的延迟确认算法</li><li>TIME_WAIT的延迟和端口耗尽</li></ul><h3 id="http1.x的连接管理">HTTP/1.x的连接管理</h3><ul><li>短连接：每一次HTTP请求之前都会有一次TCP握手</li><li>长连接：长连接会保持一段时间</li><li>HTTP流水线：在同一条长连接上发出连续的请求，而不用等待应答返回</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219174647488.png" /></p><h2 id="node.js">Node.js</h2><blockquote><p>客户端与服务端编程、静态网页和动态网页、Nodejs优势/特点/应用/原理，事件驱动模型，同步IO和异步IO，阻塞与非阻塞，模块，ES6与CommonJS模块</p></blockquote><h3 id="静态网页与动态网页">静态网页与动态网页</h3><ul><li>静态网页：写死的HTML文件，每次通过url获取到的都是一样的页面，可以直接在浏览器上显示</li><li>动态网页：由程序/脚本生成HTML文件然后返回给前端，每次获取的都可能是不同的页面，不能直接在浏览器上显示</li></ul><h3 id="客户端与服务端编程">客户端与服务端编程</h3><ul><li>客户端编程：JS编程？所见即所得？（及时展示反馈）<ul><li>好处：（不用和服务端交互）效率高、事件驱动、平台独立性</li></ul></li><li>服务端编程：使用web编程语言之一编写的程序。定制用户体验<ul><li>好处：安全性、兼容性、功能全</li></ul></li></ul><h3 id="node.js概述">Node.js概述</h3><ul><li>Node.js是一个开源的、跨平台的运行时环境。开发人员可以使用JavaScript创建各种服务端工具和应用程序</li><li>特点：事件驱动、异步IO框架</li><li>应用：网站、即时聊天、前端构建工具、命令行工具、反向代理<ul><li>适用于数据密集型实时程序（DIRT data-intensivereal-time）IO密集型</li></ul></li><li>优势：卓越的性能表现；切换成本低；可移植；活跃的社区</li></ul><h3 id="事件驱动模型">事件驱动模型</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230219182900853.png" /></p><ul><li>维护了一个 event queue 事件队列</li><li>有一个 event loop 事件循环不断读取 event queue 中的事件<ul><li>对于非阻塞事件，处理完调用回调函数向上一层返回结果</li><li>对于阻塞事件，委托后台线程池处理；完成后将执行结果与提供的回调函数一起再被放入事件队列中；当eventloop 再次读到这个事件时会执行回调函数，将结果返回给上一层。</li></ul></li></ul><h3 id="同步io与异步io">同步IO与异步IO</h3><table><thead><tr class="header"><th>同步IO（阻塞式）</th><th>异步IO（非阻塞式）</th></tr></thead><tbody><tr class="odd"><td>利用多线程提供吞吐量</td><td>单线程即可实现高吞吐量</td></tr><tr class="even"><td>通过时间片分割和线程调度利用多核CPU</td><td>通过功能划分利用多核CPU</td></tr><tr class="odd"><td>需要操作系统调用多线程使用多核CPU</td><td>可以将单进程绑定到单核CPU</td></tr><tr class="even"><td>难以充分利用CPU资源</td><td>可以充分利用CPU资源</td></tr><tr class="odd"><td>内存轨迹大，数据局部性弱</td><td>内存轨迹小，数据局部性强</td></tr><tr class="even"><td>符合线性编程思维</td><td>不符合传统编程思维</td></tr></tbody></table><h3 id="阻塞与非阻塞">阻塞与非阻塞</h3><ul><li>阻塞是指在Node.js程序中，其他JS语句的执行，必须等待一个非JS操作完成，因为当阻塞发生时，事件循环无法继续运行JS</li><li>非阻塞是指程序先注册一个回调函数（callback），当操作完成后，触发该回调函数执行后续逻辑，但是不阻碍后面代码的执行。</li></ul><h3 id="es6与commonjs模块">ES6与CommonJS模块</h3><blockquote><p>模块：两种模块，不兼容；esm和cjs</p></blockquote><ul><li>语法<ul><li>CommonJS模块使用<code>require()</code>加载和<code>module.exports</code>输出</li><li>ES6模块使用<code>import</code>和<code>export</code></li></ul></li><li>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用</li><li>CommonJS模块是运行时加载，ES6模块是编译时输出接口</li><li>循环加载<ul><li>对于CommonJS：加载时执行，脚本在<code>require</code>的时候就会全部执行<ul><li>require全部执行；加载多少输出多少；循环加载只输出执行部分</li></ul></li><li>对于ESM：<u>遇到模块加载命令只是生成一个引用</u>，等真的需要再去模块里取值</li></ul></li></ul><h2 id="express">Express</h2><blockquote><p>路由、中间件、模板引擎</p></blockquote><h3 id="express概述">express概述</h3><ul><li>最流行的node web框架</li><li>特点：精简、灵活</li><li>express不是固执己见的，是高度包容的</li></ul><h3 id="路由">路由</h3><ul><li>把需要支持的请求（以及请求URL中包含的任何信息）转发到适当的控制器函数</li><li>路由用于确定应用程序如何响应对特定端点的客户机请求，包括一个URI（或路径）和一个特定的HTTP请求方法（GET、POST等）</li><li>每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行</li><li>路由路径<ul><li>可以是正则表达式</li><li>可以包含参数：<code>/users/:userId</code> =》可以匹配<code>/users/11</code> 的URL，其中userId保存在req.params对象中。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;GET it&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="中间件">中间件</h3><ul><li>中间件是一种功能的封装方式，具体来说就是封装在程序中处理HTTP请求的功能</li><li>中间件是在管道中执行的，通过<code>app.use</code>向管道中插入中间件</li><li>中间件中要调用<code>next()</code>，将控制权传递给下一个中间件</li><li>中间件的装入顺序十分重要</li></ul><h3 id="模板引擎">模板引擎</h3><p>选用模板引擎需要考虑的因素</p><ul><li>进入生产状态的时间</li><li>流行度和活跃度</li><li>风格</li><li>性能/渲染时间</li><li>功能</li></ul><h2 id="javascript">JavaScript</h2><blockquote><p>基本概念，基本语法等、DOM、BOM、事件、事件驱动编程、事件处理模型、作用域、词法作用域、作用域链、闭包、提升、最佳实践、正则、原型对象、class、this、框架优缺点</p></blockquote><h3 id="js概述">JS概述</h3><ul><li>一种脚本语言，由js解释器/引擎计算和执行</li><li>解释型语言，更加宽松的语法和规则，关键类型是函数，包含在网页中</li><li>基本语法：略</li></ul><h3 id="dom和bom">DOM和BOM</h3><ul><li>DOM：文档对象模型，是获取、更改、添加或者删除HTML元素的标准；<ul><li>通过该模型，js可以获取创建动态html所需的所有功能</li></ul></li><li>BOM：浏览器对象模型<ul><li>通过该模型，赋予了js程序与浏览器交互的能力</li></ul></li><li>window对象：document对象、location对象（当前URL信息）、navigator对象（浏览器信息）、screen对象、history对象，还可以通过window.cookie使用cookie</li></ul><h3 id="事件">事件</h3><ul><li>使web应用程序的响应性、动态性和交互性更强，一般通过回调函数处理</li><li>允许脚本去响应用户与网页上元素的交互，允许通过事件进行对页面的修改</li></ul><h3 id="事件驱动编程">事件驱动编程</h3><ul><li>事件驱动编程是一种编程范式，其中程序流由事件决定，执行特定的操作来响应用户输入</li><li>在事件驱动的应用程序中，通常有一个主循环监听事件，然后在检测到其中一个事件时触发回调函数</li><li>事件处理程序可用于处理和验证用户输入、用户操作和浏览器操作</li></ul><h3 id="事件处理模型">事件处理模型</h3><ul><li>DOM0：内联模型：事件处理程序作为<u>元素的属性</u>添加；传统模型：可以通过脚本（js）添加/删除事件处理程序</li><li>DOM2：通过<code>addEventListener</code>和<code>removeEventListener</code>来添加和删除事件</li><li>DOM事件流：捕获阶段 =》目标阶段 =》冒泡阶段（处理事件）</li></ul><h3 id="作用域">作用域</h3><ul><li>作用域是当前执行上下文，可见或者可被访问的值和表达式，即有权访问的变量集合<ul><li>全局作用域</li><li>模块作用域</li><li>函数作用域</li><li>块级作用域（const和let）</li></ul></li></ul><h3 id="闭包">闭包</h3><p>闭包是一个函数及其捆绑的周边环境状态的引用的组合；闭包让开发者可以从内部函数访问外部函数的作用域，会随着函数的创建而创建</p><p><strong>词法作用域</strong>：（静态作用域）根据源代码中声明变量的位置来确定该变量在何处可用</p><p>闭包的应用场景：</p><ul><li>实现私有成员</li><li>保护命名空间</li><li>避免污染全局变量</li><li>变量需要长久驻留在内存</li></ul><h3 id="作用域链">作用域链</h3><p>作用域链包含了一个函数被创建的作用域中对象的集合，决定了哪些数据可以被函数访问，用于在处理标识符的时候进行变量查询</p><h3 id="提升">提升</h3><ul><li>可以先使用变量，再进行声明而不会引发异常，感觉像是 声明被提升到了使用语句的前面</li><li>只有使用var声明的变量才能被提升</li><li>类和函数表达式不能被提升，函数声明可以被提升</li><li>let先声明后使用会引起暂时性死区（TDZ）</li></ul><h3 id="最佳实践">最佳实践</h3><ul><li>避免全局变量，始终声明局部变量</li><li>使用严格模式</li><li>在顶部声明，声明变量时初始化</li><li>使用<code>===</code>比较</li><li>减少循环活动</li></ul><blockquote><p>严格模式：<code>use strict</code></p><p>消除js语法的一些不合理、不严谨之处，减少一些怪异行为；消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度；为未来新版本的js做好铺垫</p></blockquote><h3 id="框架优缺点">框架优缺点</h3><ul><li>优点<ul><li>封装了复杂困难的代码</li><li>加快开发速度，更快完成项目</li><li>专注于产品内容的价值，而不是实现过程</li><li>让合作更简单</li></ul></li><li>缺点<ul><li>如果遇到问题需要钻研框架</li><li>框架更新快速，升级更新是问题</li></ul></li></ul><h3 id="正则表达式">正则表达式</h3><ul><li>以<code>/</code>开始和结束</li><li><code>.</code>匹配单一字符</li><li><code>i</code>：对大小写不敏感</li><li><code>|</code>选择、<code>()</code>子表达式、<code>^</code>匹配开始、<code>$</code>匹配结束、<code>\</code>转义</li><li><code>*</code>：0+次；<code>+</code>：1+次；<code>?</code>：0/1次</li><li><code>&#123;min,max&#125;</code>：min-max次</li><li><code>[]</code>：字符集</li></ul><h3 id="class">class</h3><blockquote><p>JS中声明类的关键字</p></blockquote><h3 id="this">this</h3><ul><li>全局环境下的this：严格模式下是undefined；非严格模式下是window</li><li>上下文对象调用中的this：绑定到该对象上</li><li>bind、call、apply改变this指向：指定参数上</li><li>构造函数和this：构造函数内的this绑定到新创建对象上</li><li>箭头函数中的this：由外层作用域来决定</li></ul><h3 id="原型对象">原型对象</h3><ul><li>每一个对象都有它的原型对象，它可以使用自己原型对象上的属性和方法</li><li>可以通过原型对象扩展对象</li><li>原型链：任何对象都有原型对象=》形成原型链</li></ul><h2 id="css">CSS</h2><blockquote><p>基本概念、选择器、层叠排序、CSS3新特性、CSSSprites、布局、盒模型、BFC、响应式web设计、移动优先设计、渐进渐强</p></blockquote><h3 id="css概述">CSS概述</h3><ul><li>Cascading Style Sheets 层叠样式表，用于设计风格和布局</li><li>CSS优势：丰富的样式定义、简洁、清晰、易于修改和使用</li></ul><h3 id="选择器">选择器</h3><p>语法：<code>selector &#123; property: value; [...] &#125;</code></p><p>例如：<code>h1 &#123; color: blue; &#125;</code></p><ul><li>id(<code>#</code>)/class(<code>.</code>)/标签(<code>p</code>)/属性(<code>[title]</code>)/伪类(<code>:hover</code>)/伪元素(<code>:first-line</code>)/选择器</li><li>组合选择器：<ul><li>后代选择器：<code>div p</code> （对div标签下的所有p标签生效）</li><li>子元素选择器：<code>div&gt;p</code>（对div标签下的<strong>子</strong>p标签生效）</li><li>相邻兄弟选择器：<code>div+p</code>（对div标签相邻的p标签生效）</li><li>普通兄弟选择器：<code>div-p</code>（对div标签同一层级的p标签生效）</li></ul></li></ul><h3 id="层叠排序">层叠排序</h3><ul><li>内联样式 &gt; 嵌入样式（头部style） &gt; 外部样式 &gt;浏览器缺省样式</li><li>优先级计算：a(是否来自style属性即是否是内联样式)-b(ID)-c(属性/伪类)-d(元素/伪元素)</li></ul><h3 id="css3">CSS3</h3><ul><li>被分成若干个相互独立的模块：有利于规范及时更新和发布，及时调整模块的内容；厂商可以有选择地支持一部分模块，有利于CSS3推广。</li><li>新特征：圆角效果、图形化边界、块阴影与文字阴影、渐变效果、定制字体（<spanclass="citation" data-cites="font-face">@font-face</span>）</li><li><strong>CSS Sprites</strong>：是单个图像中包含的图像集合<ul><li>优点：减少服务器请求节约带宽；更换风格方便</li><li>缺点：维护麻烦；图片合成费时费力</li></ul></li></ul><h3 id="布局">布局</h3><p><strong>盒模型</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230220214046314.png" /></p><p><strong>BFC</strong>：（块级格式化上下文）是一个独立的布局环境，其中的元素布局不受外界的影响，并且在一个BFC中，块盒与行盒都会垂直地沿着其父元素的边框排列，只有Block-levelbox参与，规定了内部的Block-levelBox如何布局，并且与这个局域外部毫不相干</p><h3 id="响应式web设计">响应式web设计</h3><p>（RWD）是一种网页设计方法，该设计可以使网站在多种浏览设备上阅读和导航，同时减少缩放、平移和滚动</p><ul><li><p>优点：可用性得到提升；简化服务器端；更易维护；支持未知设备</p></li><li><p>缺点：性能较差；限制应用的复杂性；用户混淆</p></li><li><p>流畅或灵活的页面布局，根据浏览器窗口大小成比例缩放</p></li><li><p>灵活、比例适中的图像和试听媒体</p></li><li><p>使用CSS3媒体查询，确定浏览器屏幕的宽度并作出相应调整</p></li></ul><h3 id="移动优先">移动优先</h3><ul><li>优先内容和功能</li><li>好处：通用访问，即使没有js也能看到一个拥有基本功能的网站</li><li>移动优先是渐进渐强理念的良好范例，所有用户都能访问核心内容和功能</li></ul><p><strong>渐进渐强</strong>：首先基于一个具有广泛兼容性的核心方案，创建一个基线版本，然后再根据可能用到的浏览器特性，慢慢添加一些特性和功能。</p><h2 id="html">HTML</h2><blockquote><p>基本标签、块内元素和行内元素、HTML5、优势、应用、新元素、新功能、语义化</p></blockquote><h3 id="html概述">HTML概述</h3><ul><li>HyperText Markup Language，超文本标记语言，定义了网页内容和结构</li><li>块级元素占据父元素（容器）的整个水平空间，垂直空间等于内同高度；行内元素只占据元素边框所包含的空间</li><li><code>&lt;title&gt;</code>：用于定义浏览器工具栏中的标题；提供页面被添加到收藏夹的标题；显示在搜索引擎结果中的页面标题</li><li><code>&lt;meta&gt;</code>：用于提供HTML文档元数据；只出现在head里；用于给出网页描述、关键词、文档作者、最后修改日期等信息</li><li>em vs i，strong vs b：i和b都是无强调或着重意味的</li><li>table 不要用于布局：结构混乱不清晰；机器难以理解，不利于SEO；</li><li>表单中的隐藏字段：目的在于收集或发送信息，以利于被处理表单的程序所使用；帮助确认用户身份；保存全局变量；</li></ul><h3 id="html5">HTML5</h3><ul><li><p>HTML5是最新的稳定版本</p></li><li><p>优势：跨浏览器兼容性、<u>大道至简</u>（各种简化）、语义化、可用性和用户体验的改进、无插件范式、安全、大量用于移动应用和游戏，对SEO友好</p></li><li><p>应用：本地数据存储、访问本地文件、本地SQL数据、缓存引用</p></li><li><p>新元素/新功能</p><ul><li><p>新元素：article、section、header、footer等语义化标签、</p></li><li><p>更多原生功能，原生支持音视频</p></li><li><p>完全支持CSS3</p></li><li><p>提供原生的绘图功能（svg和canvas对比）</p><table><thead><tr class="header"><th>canvas</th><th>svg</th></tr></thead><tbody><tr class="odd"><td>依赖分辨率</td><td>不依赖分辨率</td></tr><tr class="even"><td>不支持事件处理器</td><td>支持事件处理器</td></tr><tr class="odd"><td>弱文本渲染能力</td><td>强文本渲染能力</td></tr><tr class="even"><td>最适合图像密集型游戏</td><td>不适合游戏</td></tr></tbody></table></li><li><p>web存储：相比cookie更加安全快速；localStorage（整个网站数据）sessionStorage（当前会话数据）</p></li><li><p>其他新特性：缓存、数据库、web worker、webSocket</p></li></ul></li><li><p><strong>语义化</strong>：根据结构化的内容选择合适的标签；有利于SEO、开发维护体验好、用户体验更好、更好的可访问性，方便任何设备对代码进行解析。</p><ul><li>帮助实现ARIA（Accesible RIA）无障碍富网络应用</li></ul></li><li><p>无插件范式：过去很多功能只能通过插件实现，但是在HTML5中提供了原生实现</p><ul><li>插件的问题：安装可能失败；被禁用或者屏蔽；被攻击</li></ul></li><li><p>CORS：Cross-Origin Resource Share 跨域资源共享 SOP：Same OriginPolicy 同源政策</p></li><li><p>RIA：Rich Internet Applications 富网络应用</p></li></ul><h2 id="概述">概述</h2><blockquote><p>DNS、URL/URI/URN、web发展历程、Web3.0</p></blockquote><h3 id="web发展历程">web发展历程</h3><ul><li>web1.0 =》web2.0 =》web3.0</li><li>web2.0的局限性：用户缺乏自主权（数字身份、个人数据、算法）</li><li><strong>web3.0</strong>的特征：语义化、3D、人工智能、去中心化</li></ul><h3 id="dns">DNS</h3><ul><li>Domain Name System</li><li>其出现之前使用 hosts.txt保存name-to-IP的映射关系</li><li>应用程序（DNS客户端）——解析器——DNS服务器</li><li>DNS名称树形层次结构</li><li>FQDN：Fully Qualified Domain Name 全限定域名</li><li>主名称服务器和辅名称服务器</li><li><strong>递归和迭代查询</strong></li><li>DNS服务器有缓存</li></ul><h3 id="uriurnurl">URI/URN/URL</h3><ul><li>RR：Resource Records 资源记录</li><li>URI：Uniform Resource Identifier ⽤于标识某⼀互联⽹资源名称的字符串（最大 是后面两个超集）</li><li>URL：Uniform Resource Location 属于URI 标识互联网资源<ul><li>URL协议：http https file mailto</li><li>超链接：绝对URL、相对URL、同一网页内</li><li>URL编码：<strong>只能使用 ASCII 字符集</strong><ul><li>%20/+ =&gt; 空格</li><li>%xx =&gt; 中文</li></ul></li></ul></li><li>URN：Uniform Resource Name 仅用于命名 位置无关 通过名称指定</li></ul><h2 id="级web前端期末考试2022">2020级web前端期末考试（2022）</h2><h3 id="名词解释">名词解释</h3><ul><li>URN</li><li>CSSOM</li><li>SVG</li><li>CANVAS</li><li>ES6</li><li>WebAssembly</li><li>Cookie</li><li>Session</li><li>Render Tree</li><li>RWD</li></ul><h3 id="简答题">简答题</h3><ol type="1"><li>web3.0核心技术</li><li>对闭包的理解、优缺点和应用</li><li>前端智能化的理解和典型应用</li><li>JavaScript的数据类型</li><li>JavaScript的动态和弱类型是什么意思</li><li>状态码的解释：200、301、303、404、500</li><li>箭头函数和普通函数的区别</li><li>Nodejs如何实现高并发</li></ol><h3 id="问答题">问答题</h3><ol type="1"><li>流行的前端框架？Vanilla JavaScript是什么？为什么要推广？</li><li>HTTP1.0-3.0的发展过程？HTTP/3相比之前的HTTP协议解决了什么问题？</li><li>简述四种前端鉴权方案？</li></ol>]]></content>
      
      
      <categories>
          
          <category> nju-course-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab6 Multithreading</title>
      <link href="/2023/02/21/6.S081/6.S081-lab6-thread/"/>
      <url>/2023/02/21/6.S081/6.S081-lab6-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="线程切换">线程切换</h2><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212104346281.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212105840373.png" /></p><h2 id="uthread-switching-between-threads">Uthread: switching betweenthreads</h2><blockquote><p>针对用户级的线程系统设计并实现一个上下文切换</p></blockquote><p>理解了<code>lecture</code>中的线程切换就比较简单，基本上模仿内核模式写就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>&#123;</span><br>    <span class="hljs-type">char</span> <span class="hljs-built_in">stack</span>[STACK_SIZE];<br>    <span class="hljs-type">int</span>state;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span>  <span class="hljs-title">context</span>;</span> <span class="hljs-comment">// 增加一个线程上下文 内容和kernel下的context一致</span><br>&#125;;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_create</span><span class="hljs-params">(<span class="hljs-type">void</span> (*func)())</span><br>&#123;<br>...<br>    <span class="hljs-comment">// 设置该线程运行的函数</span><br>  t-&gt;context.ra = (uint64)func;<br>    t-&gt;context.sp = (uint64)(t-&gt;<span class="hljs-built_in">stack</span> + PGSIZE);<br>&#125;<br><br><span class="hljs-comment">// thread_schedule</span><br>thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;current_thread-&gt;context);<br><br><span class="hljs-comment">// thread_switch内容和kernel下的swtch一致</span><br></code></pre></td></tr></table></figure><blockquote><p>疑难点：设置线程运行函数那一个地方还是需要理解一下（当然<code>lecture</code>中以及<code>xv6</code>中也有相应的部分可以参考），就是为什么设置了两个寄存器就可以了？<font color='red'>因为每次切换上下文之后返回的都是当前<code>ra</code>寄存器指向的位置，所以想要使函数可以运行在对应线程上，只要设置该线程<code>context</code>里的<code>ra</code>寄存器。<code>sp</code>寄存器是为函数的运行分配栈空间。</font></p></blockquote><h2 id="using-threads">Using threads</h2><blockquote><p>解决多线程读写哈希表（数组+链表）引发的<code>race-condition</code></p></blockquote><p>现象产生的原因：阅读<code>ph.c</code>中代码可以发现，针对一个新的key，是会插入这个key对应桶中链表的头部。但是一旦有两个进程并发执行，而不加措施，就会有<code>entry</code>丢失。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, <span class="hljs-keyword">struct</span> entry **p, <span class="hljs-keyword">struct</span> entry *n)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> entry));<br>  e-&gt;key = key;<br>  e-&gt;value = value;<br>  e-&gt;next = n; <span class="hljs-comment">// 如果两个线程都在执行完这条语句之后中断，之后无论哪个进程执行下一条语句，都会有一个entry丢失。因为此时两个entry同时指向原链表的表头。</span><br>  *p = e;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方案：<strong>加锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 全局声明</span><br><span class="hljs-type">pthread_mutex_t</span> lock;<br><br><span class="hljs-comment">// main函数里 初始化lock</span><br>pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// 在 put 函数的 调用insert函数的语句前后 加锁和解锁</span><br>pthread_mutex_lock(&amp;lock);<br>insert(...);<br>pthread_mutex_unlock(&amp;lock);<br></code></pre></td></tr></table></figure><blockquote><p>加锁的粒度：经过思考可以发现，很多情况下是不需要加锁的，真正产生冲突的原因是insert函数，所以最小的锁粒度应该针对每一次的<code>insert</code>函数。</p></blockquote><h2 id="barrier">Barrier</h2><blockquote><p>实现一个同步点：所有的线程要等待其他线程到达该点</p></blockquote><blockquote><p>需要学习一下<code>xv6</code>中的<code>sleep</code>和<code>wakeup</code>函数（lecture13）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Block until all threads have called barrier() and</span><br>  <span class="hljs-comment">// then increment bstate.round.</span><br>  <span class="hljs-comment">//</span><br>    <br>  <span class="hljs-comment">// 首先需要获取锁，因为需要修改bstate.nthread</span><br>  <span class="hljs-comment">// 这个场景和lecture中解决lost wakeup问题的场景很像</span><br>  <span class="hljs-comment">// 都是在外面获取锁，在sleep(wait)里面释放锁，从而避免了一个时间窗口使得先wakeup然后sleep</span><br>  pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>  bstate.nthread++;<br>  <span class="hljs-keyword">if</span> (bstate.nthread != nthread) &#123;<br>    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 注意: 由于是if-else结构，所以只有最后一个到达barrier的线程才会执行else部分</span><br>      <span class="hljs-comment">// 其他都被阻塞，唤醒之后直接释放锁退出了</span><br>    bstate.nthread = <span class="hljs-number">0</span>;<br>    bstate.round ++;<br>    pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>  &#125;<br>  pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 6.S081-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需求与商业模式创新</title>
      <link href="/2023/02/15/nju-course-review-notes/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/02/15/nju-course-review-notes/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>新浪微博——便利蜂——蔚来汽车</p></blockquote><h2 id="第1题商业模式画布">第1题（商业模式画布）</h2><p>分析微博的商业模式，并画出商业模式画布</p><p>根据材料画商业模式画布及各部分元素。写出一个“约束”需求</p><p>分析蔚来电动车的商业模式，并画出商业模式画布，写出约束三大来源+本系统的一条约束需求</p><h2 id="第2题商业模式特点">第2题（商业模式特点）</h2><p>分析微博如何体现多边平台商业模式的特点，并指出微博存在的问题</p><p>属于哪一个商业模式？这个模式有什么要点？再结合材料谈谈</p><p>对比传统车和用户，分析蔚来电动车体现何种商业模式，该商业模式具有什么特点</p><h2 id="第3题客户洞察场景讲故事">第3题（客户洞察、场景、讲故事）</h2><p>对微博的普通用户进行客户洞察，主要特点是想要进行社交和追踪时事热点</p><p>从公司和客户角度分别讲一个故事</p><p>App商城内的题面，对客户的讲故事和场景有什么区别？给出一个场景，并阐述为什么适用？</p><h2 id="第4题商业模式分析">第4题（商业模式分析）</h2><p><font color="red"></font></p><p>对微博的商业模式进行SWOT评估（不需要打分，概要评估）</p><p>SWOT评估包括哪些要点？结合材料和画布里的每个元素，简要分析（不需要打分）</p><p>对蔚来电动车的商业模式进行环境评估（不需要打分，概要评估）</p><h2 id="第5题目标模型">第5题（目标模型）</h2><p>结合微博存在的问题，进行目标分析（尽可能多地使用目标分析的元素）</p><p>想要在2021年大规模扩张，画出目标模型</p><p>结合蔚来电动车的车友社区，进行目标分析（尽可能多地使用目标分析的元素）</p><h2 id="第6题涉众分析">第6题（涉众分析）</h2><p>使用power-interest和power-attribute模型，阐述如何化解微博的涉众风险</p><p>有店员因为数学不好而离职，老店长认为计算机不能代替人类决策；通过实验证明数据模型更有效；老店长培养新店长；减少店员数量，增加店员收入。结合材料，用stakeholder-issue模型进行涉众共赢分析</p><p>使用stakeholder/issue模型进行共赢分析</p><h2id="第7题需求获取三大手段面谈原型观察">第7题（需求获取三大手段：面谈、原型、观察）</h2><p>假设你想要开发直播带货，结合三种需求获取方法，简述你将如何进行需求获取</p><p>想搞社区团购，有个人懂，并且还会直播带货。需求获取有哪3个方法？结合材料谈如何需求获取</p><p>面谈问题的两大类型，和一个传统燃油车用户面谈，探讨服务和让这些客户选择电动车，构思一个问题列表</p><h2 id="第8题需求管理与验证">第8题（需求管理与验证）</h2><p>简述需求管理的三种方法和流程</p><p>让你做小程序和App，需求管理包括哪些要点？结合着谈谈</p><p>简述需求管理的三种方法和管理变更的五大原则</p><h2id="第9题需求分析画图概念类图顺序图状态图">第9题（需求分析画图：概念类图、顺序图、状态图）</h2><p>微博有一系列的封号规则，根据规则画出状态图</p><p>买优惠券包、查看优惠券、优惠券包退款、优惠券包过期换积分。画出用例的系统顺序图</p><p>蔚来电动车有一系列的升级（类似）规则，根据规则画出状态图</p><h2 id="商业模式画布">商业模式画布</h2><ul><li><strong>客户细分</strong><ul><li>目标人群、取舍与细分</li><li>群体划分：<u>大众市场、小众市场、求同存异的客户群体、多元化的客户群体、多变平台</u></li></ul></li><li><strong>价值主张</strong><ul><li>为某一客户群体能够为其创造价值的产品和服务</li><li>让事情更简单（<u>保姆式服务</u>、<u>便利性</u>、<u>价格</u>）、更复杂（<u>定制</u>）、更透明（<u>风控</u>）、<u>创新</u>、<u>性能</u>、<u>设计</u>、<u>品牌/地位</u>、<u>缩减成本</u>、<u>可获得性</u></li></ul></li><li><strong>关键业务</strong><ul><li><u>生产、解决方案、平台/网络</u></li></ul></li><li><strong>核心资源</strong><ul><li>保证商业模式运行的最重要资产（品牌也算）</li><li><u>实物资源、知识型资源、人力资源、金融资源</u></li></ul></li><li><strong>渠道通路</strong><ul><li>如何和客户群体达成沟通并建立联系，以向对方传递自身的价值主张</li><li><u>知名度-评价-购买-传递-售后</u></li></ul></li><li><strong>重要合作</strong><ul><li>供应商和合作伙伴网络</li><li>非竞争者的战略同盟、竞争者的战略同盟（合作）、为新业务建立合资公司、稳定供应关系的供应商和采购商</li><li>动机：优化及规模效应、降低风险和不确定性、特殊资源及活动的获得</li></ul></li><li><strong>收入来源</strong><ul><li>用户真正愿意付费的点</li><li><u>资产销售、使用费、会员费、租赁、许可使用费、经纪人佣金、广告费</u></li><li>固定价格、浮动价格</li></ul></li><li><strong>成本结构</strong><ul><li><u>固定成本、可变成本、规模经济、范围经济</u></li></ul></li><li><strong>客户关系</strong><ul><li><u>私人服务、专属私人服务、自助服务、自动化服务、社区、协作/共同创造</u></li></ul></li></ul><h2 id="商业模式类型">商业模式类型</h2><h3 id="分拆商业模式">分拆商业模式</h3><ul><li>企业从事活动的三种不同类型：<strong>客户关系管理</strong>、<strong>新产品开发</strong>、<strong>基础设施管理</strong></li><li>对应着三种价值信条：<strong>亲近客户</strong>、<strong>产品领先</strong>、<strong>运营卓越</strong></li></ul><h3 id="多边平台商业模式">多边平台商业模式</h3><ul><li>平台将两个或更多独立但相互依存的客户群体连接在一起，平台通过促进不同群体之间的互动而创造价值</li><li>价值主张：吸引用户、群体配对、利用平台交易渠道降低交易成本</li><li>客户群体相互依存，无法独立</li><li>核心是补贴正确的客户群</li></ul><h3 id="长尾商业模式">长尾商业模式</h3><ul><li>致力于提供相当多种类的小众产品，而其中的每种卖出量相对很少，但总销售额可以与传统模式销售媲美</li><li>图书：以畅销书为中心的出版模式=》为任何需要的人出版</li><li>乐高：传统的积木制作=》用户定制+在线售卖</li><li>出现的原因：<ul><li>生产工具的普及</li><li>销售渠道的普及</li><li>连接供需双方搜寻成本的降低</li></ul></li></ul><h3 id="免费商业模式">免费商业模式</h3><ul><li>至少有一个关键的客户群体是可以持续免费地享受服务，不付费客户所得到地财务支持来自于另一个客户群体</li><li>广告模式<ul><li>免费的形式：基于多边平台的免费商品</li></ul></li><li>免费增值<ul><li>免费的形式：免费的基本服务，可选的增值服务</li></ul></li><li>诱饵&amp;陷阱<ul><li>以一个免费或者很便宜的初始价格吸引客户，引诱客户进入重复购买状态</li></ul></li></ul><h3 id="开放商业模式">开放商业模式</h3><ul><li>系统性与外部伙伴合作</li><li>由内到外：将外部的理论、技术或知识产权引入内部</li><li>由外到内：将内部的知识产权或技术，特别是闲置资产向外出售</li></ul><h2 id="商业模式设计">商业模式设计</h2><h3 id="客户洞察">客户洞察</h3><ul><li><strong>看到什么</strong>：描述这个客户在她所在的环境中<strong>所看到的东西</strong>，同类产品、朋友、看我们的产品</li><li><strong>听到什么</strong>：描述环境如何影响到这个客户</li><li><strong>想&amp;感受</strong>：尝试勾勒你的<strong>客户思维</strong>的过程，重要、打动</li><li><strong>说&amp;做</strong>：想象客户可能出现的<strong>言辞</strong>，或公共场合的<strong>行为</strong></li><li><strong>痛点</strong>：已遭受的挫折、正遇到的阻碍、怕承担的风险</li><li><strong>收益</strong>：预期成就、成功衡量标准、实现目标所采用的策略</li></ul><h3 id="构思">构思</h3><ul><li>灵感、构思、实施</li><li>生成大量创意=》对创意进行整合筛选</li><li>头脑风暴</li><li>资源驱动、供给驱动、客户驱动、财务驱动、多点驱动</li><li>从画布寻找创新点、如果...会怎样</li></ul><h3 id="视觉化思考">视觉化思考</h3><ul><li>抽象=》具体</li><li>两项技术：如何使用便利贴+如何将草图与商业模式画布结合</li><li>四个流程：理解、对话、探索、沟通</li><li>作用：加深理解、提高对话效率、探索创意、提升沟通</li></ul><h3 id="模型构建">模型构建</h3><ul><li>抽象概念具体化，帮助探索新的创意，有助于实际商业模式的探索</li><li>设计态度：专注探索、全面考虑、快速放弃、选出值得优化的想法、接收不确定性</li><li>控制规模<ul><li>随手素描</li><li>精心描绘的画布</li><li>商业案例</li><li>实地验证</li></ul></li></ul><h3 id="讲故事">讲故事</h3><ul><li>理想的热身工具，为深度讨论商业模式与其内在逻辑做好准备</li><li>为什么要讲故事<ul><li>介绍新想法</li><li>向投资人推荐</li><li>吸引员工</li><li>让未来触手可及</li></ul></li><li>故事的不同视角：客户、公司、未来</li></ul><h3 id="场景">场景</h3><ul><li>将模型构建中明确的方向具体化，从而给出有见地的设计</li><li>两种场景<ul><li>不同的客户结构：结合客户洞察描绘处独特、具体的图景</li><li>未来可能的竞争环境：想象未来可能的具体细节，品味特定条件下商业模式如何演进</li></ul></li><li>为一个故事设计并补充一个场景</li><li>了解评估=》购买与传递=》交互=》售后=》评价与复购</li></ul><h2 id="商业模式战略">商业模式战略</h2><h3 id="商业模式环境">商业模式环境</h3><ul><li><strong>市场影响力</strong>：<ul><li>市场问题：</li><li>市场分类：识别客户群体</li><li>需求和诉求：</li><li>切换成本：</li><li>收入吸引力：</li></ul></li><li><strong>行业影响力</strong><ul><li>竞争对手</li><li>新进入者（挑战者）</li><li>替代产品和服务：潜在替代品</li><li>供应商和价值量链上的其他厂商：市场价值链中的关键玩家</li><li>利益相关者：影响组织和商业模式的人</li></ul></li><li><strong>关键趋势</strong>：<ul><li>技术趋势：威胁/推动商业模式的技术</li><li>行业管理趋势：</li><li>社会和文化趋势：价值观？</li><li>社会经济趋势：</li></ul></li><li><strong>宏观经济影响</strong>：<ul><li>全球市场情况</li><li>资本市场</li><li>大宗商品和其他资源：商业模式所需资源的价格和价格趋势（人才、原料）</li><li>经济基础设施</li></ul></li></ul><h3 id="swot分析">SWOT分析</h3><ul><li><strong>SW</strong><ul><li>价值主张<ul><li>用户需求、网络效应、产品服务强耦合、用户满意</li></ul></li><li>成本/收入<ul><li>利润高、收入可预期、收入可持续、收入多样化、支出前有进账、抓住客户的意愿、客户想要的和提供的一致</li><li>成本可预测、成本匹配商业模式、运营成本效率高、规模经济中获益</li></ul></li><li>基础设施（核心资源、关键业务、重要合作）<ul><li>对手难复制、资源需求可预测、合适时间部署合适资源</li><li>有效执行关键业务、难以复制、执行质量高、自有活动和外包活动平衡</li><li>必要合作、关系融洽</li></ul></li><li>客户界面（客户细分、渠道通路、客户关系）<ul><li>客户流失率低、很好地分类用户、不断获得用户</li><li>渠道有效率、渠道有效果、连接客户效果好、客户轻易接触渠道、高度整合、规模经济、匹配客户群体</li><li>客户关系强、匹配客户群体、切换成本高绑定关系、品牌很强</li></ul></li></ul></li><li><strong>O</strong><ul><li>价值主张：产品服务化？整合产品服务？额外需求？价值主张外延？额外工作？</li><li>成本/收入：<ul><li>重复收入？内部或合作伙伴交叉销售？增加创造收入来源？提价？</li><li>削减成本？</li></ul></li><li>基础设施：<ul><li>资源成本更低？转移给合作伙伴？开发不足？对他人有用的知识资产</li><li>关键业务标准化？提高效率？IT帮助？</li><li>外包？扩大合作？交叉销售？帮助连接客户？补充价值主张？</li></ul></li><li>客户界面：<ul><li>增长的市场？新客户？更细致的分类？</li><li>提升效率效益？整合渠道？补充性渠道伙伴？去中间商？匹配渠道客户？</li><li>提升客户跟进效果？紧密客户关系？改进定制化？提升切换成本？舍弃无利润客户？客户关系自动维护？</li></ul></li></ul></li><li><strong>T</strong><ul><li>价值主张：存在可替代品？</li><li>成本/收入：<ul><li>利润的威胁？收益来源单一？收益来源消失？</li><li>成本无法预测？成本超过收入？</li></ul></li><li>基础设施<ul><li>资源供应不足、资源质量保证？</li><li>关键业务干扰？业务质量被威胁？</li><li>失去合作伙伴？和对手合作？过分依赖伙伴？</li></ul></li><li>客户界面<ul><li>市场饱和？威胁市场份额？转投竞争对手？竞争白热化？</li><li>威胁渠道？渠道用户不相关？</li><li>客户关系恶化？</li></ul></li></ul></li></ul><h3 id="蓝海战略">蓝海战略</h3><ul><li>增加价值+减少成本</li><li>三个视角：客户群体视角、价值主张视角、成本的视角</li><li>四项行动：删除、削减、提升、创造</li><li>太阳马戏团：价值主张：增加艺术元素，放弃动物表演</li><li>任天堂的wii：客户群体：铁杆玩家=》休闲玩家</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230205120635021.png" /></p><h2 id="需求基础">需求基础</h2><blockquote><p>第一题可能会涉及一些需求基础</p></blockquote><ul><li>需求的层次性：<ul><li>业务需求：解决方案与系统特性</li><li>用户需求：用户可以使用系统完成xx任务</li><li>系统级需求：用户对系统行为的期望，具体的</li></ul></li><li>需求分类<ul><li>软件需求</li><li>硬件需求</li><li>其他需求</li></ul></li><li>软件需求<ul><li>功能需求</li><li>性能需求</li><li>质量需求</li><li>对外接口</li><li><strong>约束</strong>：限制开发人员设计和构建系统时的选择范围<ul><li>系统开发及运行的环境</li><li>问题域标准：法律法规</li><li>商业规则</li><li>社会性因素</li></ul></li><li>其他需求</li></ul></li></ul><h2 id="目标模型">目标模型</h2><h3 id="目标规格的基本模式">目标规格的基本模式</h3><blockquote><p>（需要记住这些名词在画图的时候会用到）</p></blockquote><table><thead><tr class="header"><th>模式</th><th>符号描述</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>实现(Achieve)</td><td><span class="math inline">\(P \Rightarrow \Diamond Q\)</span></td><td>如果将来某一时刻Q为真(被满足)，则目标实现</td></tr><tr class="even"><td>终止(Cease)</td><td><span class="math inline">\(P \Rightarrow \Diamond \negQ\)</span></td><td>如果将来某一时刻Q为假(被终止)，则目标实现</td></tr><tr class="odd"><td>保持(Maintain)</td><td><span class="math inline">\(P \Rightarrow \Box Q\)</span></td><td>将来任一时刻Q都为真，则目标实现</td></tr><tr class="even"><td>避免(Avoid)</td><td><span class="math inline">\(P \Rightarrow \Box \neg Q\)</span></td><td>将来任一时刻Q都为假，则目标实现</td></tr><tr class="odd"><td>优化(Optimize)</td><td>-</td><td>最大化Maximize(目标功能) 或 最小化Minimize (目标功能)</td></tr></tbody></table><h3 id="目标模型的关系">目标模型的关系</h3><ul><li><strong>精化</strong><ul><li><u>AND精化</u>：任一子目标的完成都有助于父目标的完成<ul><li>完备AND精化：子目标的完成可以直接保证父目标的完成</li></ul></li><li><u>OR精化</u>：任一子目标都是父目标的替代方案</li></ul></li><li><strong>阻碍</strong>：子目标达成会使得父目标失败；可以对阻碍目标继续精化</li><li><strong>支持与冲突</strong><ul><li>support：一个目标对其他目标的支持促进作用，可以被处理为<strong>OR精化关系</strong></li><li>conflict：一个目标对其他目标的实现有阻碍作用</li></ul></li></ul><h3 id="目标分析过程">目标分析过程</h3><ul><li><strong>从高层目标描述中发现关系</strong><ul><li>AND精化关系<ul><li>同一个目标有不同场景</li><li>完成目标有连续过程</li><li>完成目标需要多个方面精密配合</li><li>目标有不同质量环境及表现</li></ul></li><li>OR精化关系：多种可以相互替代的“候选方法”</li></ul></li><li><strong>考虑阻碍目标实现的情况</strong><ul><li>考虑使得子目标失败的阻碍</li><li>考虑主体行为导致目标失败的阻碍</li><li>考虑预防失败的情况</li><li>重新处理太理想化的目标</li></ul></li><li><strong>考虑已有目标之间的支持与冲突关系</strong></li><li><strong>对高层目标问how，对低层目标问why</strong></li><li><strong>目标的实现</strong><ul><li>1、将最底层目标分配给主体</li><li>2、设计实现最底层目标的操作</li><li>目标与主体的关系：OR和AND</li><li>目标与操作的关系：OR和AND（没有箭头 目标间关系有箭头）</li></ul></li></ul><h3 id="示例">示例</h3><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book5/37.png" /></p><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book5/38.png" /></p><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book5/69.png" /></p><h2 id="涉众分析">涉众分析</h2><h3 id="涉众识别之adm模型">涉众识别之ADM模型</h3><blockquote><p>主体依赖模型</p></blockquote><ul><li><font color='red'><strong>目标依赖</strong></font>：依赖者希望被依赖者满足一个条件，但是不规定怎样满足该条件</li><li><font color='#f4df15'><strong>软目标依赖</strong></font>：一种特殊类型的目标依赖，无法量化描述</li><li><font color='green'><strong>任务依赖</strong></font>：依赖者希望被依赖者执行特定任务，比目标依赖更加具体</li><li><font color='blue'><strong>资源依赖</strong></font>：依赖者希望被依赖者提供资源实体（抽象信息或者实物材料）为自己所用</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210154032835.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210155251866.png" /></p><h3 id="涉众分析power-interest模型">涉众分析—Power-Interest模型</h3><p><strong>优先级评估</strong>：有些涉众就是会更加重要一点，具有更高优先级，体现在和系统的联系上</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/11.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/12.png" /></p><p><strong>化解涉众风险的策略</strong></p><ul><li>提高环境设定者对系统的关注，转变为参与者</li><li>消除强反对者的反对原因，变为强支持者</li><li>给予被影响者发表实现自身意愿的权利，化解弱反对者忧虑</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/13.png" /></p><h3id="共赢分析stakeholder-issue模型">共赢分析—Stakeholder-Issue模型</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/15.png" /></p><ol type="1"><li>列出所有涉众类别</li><li>发现涉众们背后涉及的共同问题（issue）</li><li>建立涉众类别和问题的关联</li><li>表明stakeholder-issue关系所寄予的期望</li></ol><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210171728451.png" /></p><h2 id="需求获取手段">需求获取手段</h2><h3 id="面谈">面谈</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211102941016.png" /></p><h4 id="问题类型">问题类型</h4><ul><li>开放式问题<ul><li>“请解释你是如何做进度决策的”</li><li>优点：细节丰富；被会见者自在</li><li>缺点：信息率低；</li><li>需求获取的初期，掌握的信息优先，希望提供丰富的信息</li></ul></li><li>封闭式问题<ul><li>回答的形式受限制</li><li>优点：节省时间；切中要点</li><li>缺点：细节不够；被厌烦</li><li>需求获取的后期，已经对事实和问题的范围比较明确</li></ul></li><li>诱导性问题</li><li>探究式问题</li><li>双筒式问题</li><li>元问题</li></ul><h4 id="面谈的问题准备示例">面谈的问题准备示例</h4><ul><li>前期</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211103950830.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211104035259.png" /></p><ul><li>后期</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211104114828.png" /></p><h3 id="原型">原型</h3><blockquote><p>获取不确定需求：可能法僧的需求变更；存在冲突的地方；信息不充分...</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211110400104.png" /></p><ul><li>确定原型需求：为什么要开发原型，拥有的起始点是什么，期望的结束标准是什么</li><li>原型开发：依据原型的需求特点和开发目的，以最低的成本建立初始原型</li><li>原型评估：对上一阶段产生的原型进行评估，根据评估者（用户和开发者）的反馈判断原型是否满足结束标准</li><li>原型修正：如果已经达到了目的就结束；否则根据评估者反馈进行原型调整</li></ul><h3 id="观察">观察</h3><blockquote><p>事件的情境性：某些事件只有和具体的情境联系起来才能得到很好的理解</p></blockquote><h4 id="采样观察">采样观察</h4><ul><li>时间采样：指定时间间隔来观察用户的活动情况<ul><li>在7个8小时工作日内随机指定5个10分钟间隔来观察用户</li><li>优点：减少偶然偏差；节省时间成本</li><li>缺点：不能提供全面的信息；忽视重要但是频率低的事务</li></ul></li><li>事件采样：有目的地选取整个事件进行观察<ul><li>不会遗漏重要事件</li><li>事件成本高；漏掉频发发生事件的代表性样本</li></ul></li></ul><h4 id="民族志">民族志</h4><blockquote><p>民族志可以很好地处理复杂的协同工作，例如航空调度、证券交易等</p></blockquote><p>优点：能够深度理解信息；让真实事件的社会性因素可见化</p><p>缺点：时间成本高；产生的数据过于广泛，数据抽取存在一定难度</p><p>实施：</p><ul><li>针对复杂协同问题的民族志（关注以下3方面）<ul><li>分布式协同：用户的活动是一个有组织的整体活动的一部分，而不是单纯的个体活动</li><li>计划和程序：产生的资料、记录任务完成得细节步骤和过程</li><li>工作的意识：活动对协同中的其他人可见或者可理解</li></ul></li><li>普通民族志的规则<ul><li>定期记录发现</li><li>尽快记录可能发生的面谈</li><li>定期复查和更新自己的想法</li><li>及时对信息进行总结索引分类</li></ul></li></ul><h2 id="需求分析">需求分析</h2><p><strong>需求分析的根本任务</strong>：</p><ul><li>建立分析模型，达成开发者和用户对需求信息的共同理解<ul><li>模型是对事务的抽象：抽象、分解、投影</li><li>两种世界与三种模型<ul><li>计算世界与计算模型</li><li>问题世界与业务模型</li><li>软件分析模型（分析视图）</li><li>业务模型=》软件分析模型=》计算模型</li></ul></li></ul></li><li>依据共同的理解，发挥创造性，创建软件系统解决方案</li></ul><h3 id="对象模型">对象模型</h3><h4 id="对象">对象</h4><ul><li><strong>独立可确认</strong>：<u>相对于问题域</u>是可界定的，具有==标识符==来唯一地标识自己</li><li><strong>有明确的角色</strong>：要求对象具有一定<u>状态和行为</u><ul><li>==状态==：对象的特征描述</li><li>==行为==：对象在其状态发生改变或者接收到外界消息时所采取的行动</li></ul></li><li>对象间的关系：对象间互相协作的关系称为<u>链接</u>，建立a指向b的链接的途径有：<ul><li>b是全局对象</li><li>b是a的一部分</li><li>b是被a创建的</li><li>b的引用被作为消息的一部分传递给了a</li></ul></li></ul><h4 id="类">类</h4><ul><li><p>类的概念：共享相同属性和行为的对象的集合</p></li><li><p>类的产生——分类：</p><ul><li>数据驱动：以对象的属性为标准</li><li>职责驱动：结合对象的状态和行为 考虑概念之间的相似性</li></ul></li><li><p>类的产生——抽象：</p><ul><li>水平层次忽略：忽略不重要的属性</li><li>垂直层次忽略：将值忽略，抽象为属性</li></ul></li><li><p>类的封装：</p><ul><li>信息隐藏</li><li>只公开对象为履行职责所必需的协议</li></ul></li><li><p><strong>类之间的关系</strong></p><ul><li><p><strong>关联</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212140305004.png" /></p></li><li><p><strong>聚合和组合</strong></p><ul><li>聚合：表示整体与部分之间的关系</li><li>组合：除了包含关系，还对部分有完全的管理职责（一旦部分属于某个整体，改部分不能属于其他整体，也不能单独存在）</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212140340175.png" /></p></li><li><p><strong>继承</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212140447249.png" /></p></li><li><p>多态</p></li></ul></li></ul><h4 id="领域模型">领域模型</h4><p>领域模型中的类大多是<strong>概念类</strong>：</p><ul><li>概念类间存在指明语义联系的关联，这些关联通常不标记方向，也不比较关联端的可见性</li><li>概念类会显式描述自己的一些重要属性，但是不是全部的详细属性，属性没有类型的约束</li><li>概念类不显示地标记类的行为，即不包含明确的方法</li></ul><h4 id="建立领域模型概念类图">建立领域模型（概念类图）</h4><blockquote><p>学习教材中的几个例子（P349）</p></blockquote><ol type="1"><li><strong>识别候选对象与类</strong><ul><li>概念类分类列表</li><li>名词分析</li><li>行为分析：识别系统行为中的被动对象和主动对象</li></ul></li><li><strong>确定概念类</strong><ul><li>确定为概念类的对象需要既维持一定的状态、又依据状态表现一定的行为</li><li>属性的复杂度，例如“图书”和“作者”</li><li>武断地将单值状态类抽象为其他类的属性，例如“商品”和“价格”</li></ul></li><li><strong>建立类之间的关系</strong></li><li><strong>添加类的重要属性</strong></li></ol><h3 id="行为模型">行为模型</h3><h4 id="顺序图">顺序图</h4><ul><li>顺序图示例</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212154449638.png" /></p><ul><li><p>系统顺序图：将整个系统看作一个黑箱的对象，强调外部参与者和系统的交互行为，重点展示系统级事件（<u>和设计的区别：设计会将系统拆成一个个模块</u>）</p></li><li><p>顺序图的组合片段</p><ul><li><code>seq</code>：同一根生命线上的操作需要按顺序执行，不同生命线的操作是并发的</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212155122180.png" /></p></li><li><p>系统顺序图示例</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230212155445497.png" /></p></li></ul><h4 id="状态图">状态图</h4><p><strong>建立状态图</strong></p><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/59.png" /><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/60.png" />UML状态图示例 <imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/61.png" /></p><ul><li>确定上下文环境</li><li>识别状态</li><li>建立状态转换</li><li>补充详细信息</li></ul><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book14/35.png" /></p><h2 id="需求管理与验证">需求管理与验证</h2><h3 id="需求管理的三个活动">需求管理的三个活动</h3><ol type="1"><li><p><strong>维护需求基线</strong></p><ul><li>需求基线：已经通过正式评审和批准的规格说明或产品，可以作为进一步开发的基础，并且只有通过正式的变更控制过程才能修改它</li><li>需求基线的维护：<ul><li>配置管理：1、标识配置项；2、版本控制；3、变更控制；4、访问审计；5、状态报告</li><li>状态维护：反映项目的实际进展状况<ul><li>已提议；已批准；已实现；已验证；已删除；已否决</li></ul></li></ul></li></ul></li><li><p><strong>实现需求跟踪</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230213093320780.png" /></p><ul><li>在涉众需求变化中协调系统的演化，保持各项开发工作对需求的一致性</li><li>前向跟踪：涉众需要=》软件需求；软件需求=》涉众需要</li><li>后向跟踪：软件需求=》后续开发物件；后续开发物件=》软件需求</li><li>需求跟踪的实现方法：矩阵、实体关系模型和交叉引用3种</li></ul></li><li><p><strong>变更控制</strong></p><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book17/8.png" /></p><ul><li>需求的变化是正当的和不可避免的</li><li>以可控、一致的方式进行需求基线中需求变更处理，包括对变化的评估、协调、批准或拒绝、实现和验证</li><li>5个注意事项（5大原则？）<ul><li>认识到变更的必要性，并为之制定计划</li><li>维护需求基线，审计变更记录</li><li>管理范围蔓延</li><li>灵活应对变请求</li><li>使用辅助工具</li></ul></li></ul></li></ol><h3 id="需求验证">需求验证</h3><p><imgsrc="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Demand-and-business-model-innovation/需求/img/book16/1.png" /></p><ul><li>需求的验证：以正确的方式建立需求</li><li>需求的确认：建立的需求是正确的</li><li>验证方法：评审、原型与模拟、测试用例开发、用户手册编制、利用跟踪关系和自动化分析</li><li><strong>评审</strong>：静态分析；作者之外的人</li><li><strong>原型</strong>：涉及复杂的动态动作，成本较高</li></ul>]]></content>
      
      
      <categories>
          
          <category> nju-course-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> demand and business model innovation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>处理器管理</title>
      <link href="/2023/02/15/nju-course-review-notes/os/processor-management/"/>
      <url>/2023/02/15/nju-course-review-notes/os/processor-management/</url>
      
        <content type="html"><![CDATA[<h2 id="处理器">2.1 处理器</h2><h3 id="处理器与寄存器">2.1.1 处理器与寄存器</h3><ul><li><strong>用户程序可见寄存器</strong>：减少访问主存储器</li><li><strong>控制与状态寄存器</strong></li><li><strong>程序状态字</strong></li></ul><h3 id="指令与处理器模式">2.1.2 指令与处理器模式</h3><ul><li><strong>机器指令</strong>：计算机系统执行的基本命令，中央处理器执行的基本单位</li><li>指令执行过程：取指——解码——执行</li><li>特权指令和非特权指令</li><li>模式切换</li></ul><h2 id="中断管理">2.2 中断管理</h2><h3 id="中断与中断源">2.2.1 中断与中断源</h3><ul><li><strong>==中断==</strong>：程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行的程序，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或者调度其他程序执行的过程</li><li>操作系统是中断驱动的，中断是激活操作系统的唯一方式</li><li>狭义的中断：来源于处理器之外的中断事件，与当前执行指令无关的中断事件</li><li>异常：<u>当前运行指令</u>引起的中断事件=》非正常</li><li>系统异常：执行陷入指令出发系统调用：请求设备、请求I/O、创建进程等</li><li><strong>中断源</strong>：<ul><li>硬件故障</li><li>程序性中断——异常</li><li>自愿性中断——系统调用、陷入指令</li><li>I/O中断事件——IO处理</li><li>外部中断事件——设备引起的中断（时钟、键盘）</li></ul></li></ul><h3 id="中断系统">2.2.2 中断系统</h3><ul><li><p><strong>中断系统</strong>是计算机系统响应并处理中断的系统</p><ul><li>硬件子系统=》中断响应</li><li>软件子系统=》中断处理</li></ul></li><li><p>中断响应处理 =》在每个指令周期的最后进行</p></li><li><p>中断装置：计算机系统发现并相应中断的硬件装置</p><ul><li>处理器以外的中断：中断控制器发现并响应</li><li>处理器以内的异常：指令的控制逻辑和实现线路发现并响应</li><li>请求OS服务的<u>系统异常</u></li></ul></li><li><p>中断控制器：控制部件，中断控制逻辑线路+中断寄存器</p><ul><li>外部设备发出IRQ=》在中断寄存器中设置已发生的中断</li><li>在指令处理结束前，检查中断的产生</li></ul></li><li><p>中断响应过程</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215113158382.png" /></p></li></ul><h3 id="多中断的响应与处理">2.2.3 多中断的响应与处理</h3><ul><li>中断屏蔽可以使中断装置不响应某些中断</li><li>中断优先级决定了中断装置响应中断的次序</li><li>中断嵌套有层数限制</li><li>中断的嵌套处理改变了中断处理的次序（先响应后处理）</li></ul><h2 id="进程管理">2.3 进程管理</h2><h3 id="进程及其状态">2.3.1 进程及其状态</h3><ul><li><p><strong>进程</strong>：一个具有一定独立功能的程序关于某个数据集合的一次运行活动</p></li><li><p>进程是操作系统进行资源分配和调度的一个独立单位</p></li><li><p>一个进程包括五个实体部分：P（管理运行程序的数据结构）、C（内存代码）、D（内存数据）、R（通用寄存器信息）、PSW（程序状态字信息）</p></li><li><p>代码、数据、运行时间的不同都意味着不同的进程</p></li><li><p><strong>状态</strong></p><ul><li><strong>运行态</strong>：进程占有处理器</li><li><strong>就绪态</strong>：进程具备运行条件等待被处理器选中运行</li><li><strong>等待态</strong>：等待资源、输入输出、信号等而不具备运行条件</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215090607700.png" /></p></li><li><p><strong>挂起态</strong>：某些进程被剥夺了内存及其他资源，调入OS管理的对换区，不参加进程调度，等待适当时候再调入内存、恢复资源、参与运行=》 进程挂起（不占据任何资源）</p></li></ul><h3 id="进程的数据描述">2.3.2 进程的数据描述</h3><ul><li><strong>进程控制块</strong>：<code>PCB</code>，OS用于记录和刻画进程状态及环境信息的数据结构，借以全面管理进程的物理实体，刻画进程的执行现状，控制进程的执行<ul><li>标识信息：唯一标识进程</li><li>现场信息：用户可见寄存器、控制与状态寄存器、栈指针内容</li><li>控制信息</li></ul></li><li><strong>进程映像</strong>：某一时刻进程的内容及其执行状态集合。进程映像是内存级的物理实体，又称为进程的内存映像<ul><li>进程控制块</li><li>进程程序块</li><li>进程数据块</li><li>核心栈（内核模式）</li></ul></li><li><strong>进程上下文</strong>：进程物理实体+支持进程运行的环境=》进程上下文<ul><li>用户级上下文</li><li>寄存器上下文</li><li>系统级上下文</li></ul></li></ul><h3 id="进程管理的实现">2.3.3 进程管理的实现</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215105222086.png" /></p><ul><li><p>建立多个进程队列=》就绪队列和等待队列=》先进先出队列和优先队列</p></li><li><p>进程的控制和管理</p></li><li><p>进程控制过程中涉及对OS核心数据结构的修改需要使用原语</p></li><li><p>进程切换</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215111124677.png" /></p></li><li></li></ul><h3 id="多线程技术">2.4 多线程技术</h3><h3 id="多线程环境概述">2.4.1 多线程环境概述</h3><ul><li>单线程结构进程的问题：<ul><li>进程切换开销大</li><li>进程通信开销大</li><li>限制了并发进程的粒度</li><li>降低了并行计算的效率</li></ul></li><li>多线程环境下，<u>进程是OS进行保护和资源分配的基本单位</u>；<u>线程是调度的基本单位</u>，同一个进程中的所有线程共享进程获得的主存空间和资源。</li><li>多线程优点：线程切换快速；减少管理开销；通信易于实现；并行程度提高；节省内存空间</li><li>多线程应用：前后台工作、C/S应用模式、加快执行速度、设计用户接口</li></ul><h3 id="多线程的实现技术">2.4.2 多线程的实现技术</h3><ul><li><p><strong>内核级多线程（KLT）</strong>：线程管理的所有工作由OS内核来做</p><ul><li>线程切换需要内核参与=》模式切换=》系统开销大</li><li>物理并行性问题</li></ul></li><li><p><strong>用户级多线程（ULT）</strong>：线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在</p><ul><li>线程切换不需要内核参与；但是不能利用多处理器的优点，线程的阻塞会引起整个进程的阻塞</li><li>逻辑并行性问题</li></ul></li><li><p><strong>Jacketing技术</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215101225878.png" /></p><ul><li>解决ULT中一个线程的阻塞引起整个进程阻塞的问题</li><li>线程不是直接进行系统调用，而是调用jacketing程序，由jacketing程序来检查线程所需资源是否空闲，如果不空闲的话就进行线程切换（如果不使用jacketing技术，该线程就会陷入系统调用然后被阻塞），当该线程再次被赋予时间片的时候，jacket程序会再次检查资源是否空闲<ul><li>阻塞式系统调用=》非阻塞式</li></ul></li></ul></li><li><p><strong>混合式策略</strong>：组合用户级线程和内核级线程</p><ul><li><p>一个应用中的ULT会被映射到一个或多个KLT上</p></li><li><p>线程的创建、调度和同步完全是在用户空间完成的</p></li><li><p>调度图</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215101829462.png" /></p></li></ul></li></ul><table><thead><tr class="header"><th>内核级线程</th><th>用户级线程</th><th>混合式线程</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215100240015.png" /></td><td><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215100254822.png" /></td><td><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215100312478.png" /></td></tr></tbody></table><h2 id="处理器调度">2.5 处理器调度</h2><h3 id="处理器调度层次">2.5.1 处理器调度层次</h3><ul><li><strong>高级调度（长程/作业调度）</strong>：决定能否加入到执行的进程池中<ul><li>新建态=》就绪态/就绪挂起态</li><li>是否新建？是否加入进程池中？运行前的准备</li></ul></li><li><strong>中级调度（平衡负载调度）</strong>：决定主存中可用的进程集合（挂起相关）<ul><li>为了提高内存利用率和作业吞吐量</li><li>决定哪些进程留在主存中参与处理器竞争，哪些进程换出主存</li></ul></li><li><strong>低级调度（短程/进程调度）</strong>：决定哪个可用进程可以占用处理器执行（核心三态模型之间的调度）</li></ul><h3 id="处理器调度算法">2.5.2 处理器调度算法</h3><ul><li><strong>优先数调度算法</strong>：根据分配给进程的优先数<ul><li>抢占式/非抢占式</li><li>优先数确定准则：任务紧迫程度、交互性、使用外设频率、进入系统时间长短</li><li>计算时间短、剩余计算时间短、响应比（等待时间/进入时间）高优先、先来先服务</li></ul></li><li><strong>时间片轮转调度算法</strong>：根据进入就绪队列的时间先后轮流占有CPU一个时间片</li><li><strong>分级调度算法</strong>：多级队列策略<ul><li><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230215103848868.png" /></li></ul></li><li><strong>彩票调度算法</strong>：随机？根据优先级发放彩票数量（优先级高彩票数量多）调度=》随机抽彩票</li></ul>]]></content>
      
      
      <categories>
          
          <category> nju-course-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件管理</title>
      <link href="/2023/02/13/nju-course-review-notes/os/file-management/"/>
      <url>/2023/02/13/nju-course-review-notes/os/file-management/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统概述">5.1 文件系统概述</h2><h3 id="文件的概念">5.1.1 文件的概念</h3><h4 id="文件概念">文件概念</h4><p><strong>文件是具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列</strong></p><blockquote><p>文件的命名：<文件名><code>.</code><扩展名></p><p>文件名用于设别文件，扩展名用于识别文件特性</p></blockquote><h4 id="引入文件的优点">引入文件的优点</h4><ol type="1"><li>用户使用方便：实现了==按名存取==，知道文件名就可存取信息。</li><li>文件安全可靠：通过文件系统实现对文件的访问</li><li>文件可备份：文件可以组织转储或备份</li><li>文件可共享：文件可共享，提高利用率</li></ol><h3 id="文件系统及其功能">5.1.2 文件系统及其功能</h3><h4 id="文件系统">文件系统</h4><p>文件系统是操作系统中负责存取和管理信息的模块，它用统一的方式管理用户和系统信息的存储、检索、更新、共享和保护，并为用户提供一整套方便有效的文件使用和操作方法</p><p>功能：</p><ul><li>文件的按名存取</li><li>文件的共享和保护</li><li>文件的操作和使用</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221124234708050.png" /></p><h2 id="文件的组织">5.2 文件的组织</h2><h3 id="文件的存储">5.2.1 文件的存储</h3><h4 id="卷和块">卷和块</h4><ul><li>文件存储介质：磁带、光盘和磁盘</li><li>==卷==：存储介质的物理单位，对应于一盘磁盘、一块软盘、一个光盘片、一个硬盘分区</li><li>==块==：存储介质上连续信息所组成的一个区域，也叫物理记录<ul><li><strong>是主存储器和辅助存储器进行数据交换的<u>物理单位</u>，每次交换一块或整数块信息</strong></li><li>存储文件的设备一般都是块设备</li></ul></li><li>块的大小和<u>用户使用方式</u>、<u>数据传输效率</u>和<u>存储设备类型</u>相关<ul><li>外围设备中相邻块之间必须留有间隙：<u>启停机械动作</u>和<u>识别不同块</u>的要求=》需要时间<ul><li>磁盘</li></ul></li></ul></li></ul><h4 id="存取存储方式">存取存储方式</h4><h5 id="顺序存取存储设备">顺序存取存储设备</h5><ul><li>磁带机（同心圆）、光盘（螺旋线）都是一种顺序存取存储设备</li><li><u>严格依赖信息的物理位置次序进行定位和读写</u>的存储设备</li><li>磁带机<ul><li>存储容量大、稳定可靠、卷可装卸和便于保存，广泛用作存档</li><li>磁带的块长的变化范围可以较大，没有限制</li></ul></li></ul><h5 id="直接存取存储设备">直接存取存储设备</h5><ul><li>==磁盘==是一种直接（随机）存取存储设备</li><li><u>移臂+旋转</u>来定位，存储速度高，存取任意一个物理块所需时间几乎不依赖于信息的位置</li></ul><h3 id="文件的逻辑结构">5.2.2 文件的逻辑结构</h3><h4 id="逻辑文件">逻辑文件</h4><p>==逻辑文件==：又称文件的逻辑结构</p><ul><li>独立于物理环境的，用户概念中的抽象信息组织方式</li><li>用户能观察到的，并加以处理的数据集合</li></ul><p>分为两种形式：1、流式文件；2、记录式文件</p><h4 id="流式文件">流式文件</h4><p>文件内的数据不再组成记录，只是由一串依次的字节组成的信息流序列，常常按长度来读取所需信息。</p><h4 id="记录式文件">记录式文件</h4><ul><li>记录式文件：有结构的文件，若干逻辑记录信息所组成的记录流文件</li><li>逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</li><li>例如：每个职工的工资信息构成一个逻辑信息，所有职工的工资信息便组成了记录式文件。</li></ul><blockquote><p>和数据库之间的区别：</p><ol type="1"><li>数据库中的记录之间可以通过数据冗余<strong>构成某种联系</strong></li><li>数据库管理系统支持基于联系的<strong>数据查询</strong></li><li>数据库支持<strong>事务管理</strong></li></ol></blockquote><h3 id="记录组成与分解">5.2.3 记录组成与分解</h3><blockquote><p>上课没讲</p></blockquote><h3 id="文件的物理结构">5.2.4 文件的物理结构</h3><ul><li>文件的物理结构和组织是指文件在物理存储空间中的存放方法和组织关系</li><li>文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等许多问题，其优劣直接影响文件系统的性能</li></ul><h4 id="顺序文件">顺序文件</h4><p>顺序（连续）文件：将一个文件中逻辑上连续的信息存放到存储介质的依次相邻的块中的文件</p><p>例如：磁带文件、光盘文件</p><ul><li>优点：顺序存取记录时速度较快</li><li>缺点：<ul><li>建立文件前需要预先确定文件长度以分配存储空间</li><li>修改、插入增加文件记录有困难</li></ul></li></ul><h4 id="连接文件">连接文件</h4><ul><li>连接（串联）文件：使用连接字来表示文件中各个物理块之间的先后次序</li><li>输入井和输出井都使用此类文件</li></ul><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125003450926.png"alt="连接文件" /><figcaption aria-hidden="true">连接文件</figcaption></figure><p>优点：易于对文件记录做增、删、改，易于动态增长记录；不必预先确知文件长度；存储空间利用率高。</p><p>缺点：存放指针需要额外的存储空间；需要通过缓冲区获得连接字后才能找到下一物理块地址，仅适用于顺序存取。</p><h4 id="直接文件">直接文件</h4><p>又称散列文件，通过计算记录的关键字建立与物理存储地址之间的对应关系（散列表，可能出现冲突）</p><h4 id="索引文件">索引文件</h4><p>索引文件为每个文件都建立了一张索引表，其中，每个表目包含一个记录的键（或逻辑记录号）及其存储地址。索引表的地址可由文件目录指出，查阅索引表先找到相应记录键（或逻辑记录号），然后获得数据存储地址。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125161841819.png"alt="索引文件" /><figcaption aria-hidden="true">索引文件</figcaption></figure><p>访问方式：1、查找索引表；2、获得记录的物理地址</p><p>优点：克服了连接文件只能顺序存取的缺点，具有直接读写任意一个记录的能力，便于文件的增、删、改。</p><p>缺点：增加了索引表的空间开销和查找时间。</p><p>==多级索引==</p><p>优点：节省inode的存储空间（使得inode号容量尽可能大）；对小文件有较高的性能</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125162119490.png"alt="多级索引" /><figcaption aria-hidden="true">多级索引</figcaption></figure><blockquote><p>第一列的13个地址为：10个直接地址的索引+1个一级间接索引+1个二级间接索引+1个三级间接索引</p></blockquote><h2 id="文件目录">5.3 文件目录</h2><h3 id="文件目录结构">5.3.1 文件目录结构</h3><h4 id="文件目录-1">文件目录</h4><ul><li>文件目录是实现文件按名存取的关键数据结构</li><li>文件目录的建立维护和检索是文件系统的基本功能之一</li><li>文件目录需要永久保存，组织成文件放在磁盘中，称为目录文件</li></ul><h4 id="一级目录结构">一级目录结构</h4><p><u>构造一张线性表</u>，每个文件的相关属性占用一个目录项，构成一级目录结构</p><p>容易重名，不利于记忆</p><h4 id="二级目录结构">二级目录结构</h4><p>第一级为主文件目录，管理所有用户文件目录，目录项登记了系统接受的<u>用户的名字</u>及<u>该用户文件目录的地址</u>。</p><p>第二级为用户的文件目录，目录项登记一个文件的相关属性，每个用户只能查看自己的文件目录。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221124154232094.png"alt="二级目录结构" /><figcaption aria-hidden="true">二级目录结构</figcaption></figure><p>优点：通过主文件目录使得用户文件私密性得到保证，实现了对文件的保密和保护；不同用户可以具有同名文件，不会混乱。</p><p>缺点：同一个用户还是存在文件多、易重名问题。</p><h4 id="树形目录结构">树形目录结构</h4><ul><li>层次文件目录结构通常使用 树形目录结构</li><li>可以较好地反映现实世界中具有<u>层次关系的数据集合</u>和<u>较确切地反映系统内部文件的组织结构</u></li><li>易于规定不同层次或子树中文件的不同存取规格，便于文件的保护、保密和共享。</li><li>只要不位于同一末端的子目录中，不同文件可以重名</li></ul><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125163457307.png"alt="树形目录结构" /><figcaption aria-hidden="true">树形目录结构</figcaption></figure><h2 id="文件的共享保护与保密">5.4 文件的共享、保护与保密</h2><h3 id="文件的安全与保护">5.4.1 文件的安全与保护</h3><ul><li>文件共享：不同用户共同使用某些文件</li><li>文件保护：防止文件被破坏</li><li>文件保密：防止文件及其内容被其他用户窃取<ul><li>隐蔽文件目录</li><li>设置口令</li><li>使用密码</li></ul></li></ul><h3 id="文件的保护">5.4.2 文件的保护</h3><ul><li>文件副本：防止软硬件故障、保存信息完整性的能力<ul><li>动态多副本技术：在多个介质上维护同一内容的文件，并保持同步更新</li><li>转储、备份与恢复：定时把文件复制转储到其他介质上，当某介质出现故障时，复原转储文件<ul><li>一定时间间隔或一个单位处理结束后，系统自动复写更新过的文件和数据</li><li>二是每天或每周把文件信息全部复写一遍</li></ul></li></ul></li><li>文件存取矩阵与文件存取表：系统为每个用户设置访问每个文件对象的存取属性组成的二维矩阵<ul><li>文件存取矩阵是稀疏矩阵 =》存取控制表</li><li>用户、文件、存取属性</li><li>存取控制表仅登记对文件拥有存取属性的部分</li><li>存取属性：访问、读、写、执行、创建、删除、授权等</li></ul></li><li>文件属性<ul><li>用户分类：属主、合作者、其他</li><li>文件属性：读、写、执行；放在文件目录项中</li><li>用户使用文件时，通过核对文件属性，实现保护</li></ul></li></ul><h2 id="补充内容">5.5 补充内容</h2><p>如何在线性地址空间实现非线性层次目录结构——按名存取</p><p>按名存取——按号存取（存在一个数据结构保存：名和号的映射关系）</p><p>（含路径的文件名）名——目录项【名 | indoe号】——inode号</p><p>文件的存取方法</p><ul><li>顺序存取</li><li>直接存取</li><li>索引存取：索引文件</li></ul><p>文件系统的实现层次</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230225112534129.png" /></p><h3 id="inode">Inode</h3><p>Linux系统的FCB中的文件名和其他管理信息分开，其他信息单独组成一个数据结构，称为索引节点<code>inode</code>，由<code>inode号</code>标识。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230225100907302.png"alt="FCB结构" /><figcaption aria-hidden="true">FCB结构</figcaption></figure><p>文件系统中的每个文件都有一个磁盘<code>inode</code>与之对应，这些<code>inode</code>被集中存放在磁盘上的<code>inode区</code>。</p><p>为了避免不断来回于内外存引用磁盘inode表，在内存区开辟一张活动inode表，磁盘inode反映文件静态特性，活动inode表反映文件动态特性</p><h3 id="层次目录结构">层次目录结构</h3><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230225101609127.png"alt="Linux和Windows层次目录结构" /><figcaption aria-hidden="true">Linux和Windows层次目录结构</figcaption></figure><ul><li>纯树型目录结构：每个文件都只有一个父目录</li><li>有向无环图目录：允许文件有多个父目录而破坏树的特性</li></ul><p><strong>Linux支持多父目录，但其中一个是主父目录，它是文件拥有者</strong>，文件被物理存放在该目录下，其他父目录通过link的方式来连结和引用文件，允许任一父目录删除共享文件。（Windows中的快捷方式）</p><h3 id="文件系统的实现">文件系统的实现</h3><p>文件系统的磁盘结构</p><ul><li>超级块：占用1#号块；存放文件系统结构和管理信息，既有盘位示图的功能，又记录整个文件卷的控制数据</li><li>索引节点区：2#—k+1#块；存放在inode表</li><li>数据区：k+2#—n#块：文件内容保存在这个区域中</li></ul><p>重要数据结构</p><ul><li>用户打开文件表</li><li>系统打开文件表：为了解决多用户进程共享文件、父子进程共享文件而设置的，通过此表项将<u>用户打开文件表的表项</u> 和 <u>文件活动inode表的表项</u>联接起来，以实现数据的访问和信息的共享。</li><li>主存活动<code>inode表</code></li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/82705ca69201a804478a2a214a987d67.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/543d71fd2007f6df381df780b979bac0.png" /></p><h3 id="文件系统调用">文件系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = create(file_name_p, mode);<br>unlink(file_name_p);<br>fd = open(file_name_p, mode);<br>close(fd);<br></code></pre></td></tr></table></figure><ul><li><code>f_count</code>：反映不同进程通过<strong>同一个系统打开文件表项</strong>共享一个文件的情况</li><li><code>i_count</code>：反映不同进程通过<strong>不同系统打开文件表项</strong>共享同一个文件的情况</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-built_in">count</span>);<br><span class="hljs-built_in">write</span>(fd, buf, <span class="hljs-built_in">count</span>);<br></code></pre></td></tr></table></figure><h3 id="文件共享">文件共享</h3><ul><li><p>静态共享</p><ul><li><code>linke(old_name_p, new_name_p)</code></li><li>找到<code>old_name_p</code>所指向的文件索引节点inode编号，检索到<code>new_name_p</code>所指文件的父目录文件，把以存在文件的索引节点<code>inode</code>编号和别名构成一个新的目录项，放在该目录文件中去，以存在文件索引节点<code>inode</code>的连接计数<code>i_link</code>加<code>1</code>。</li></ul></li><li><p>动态共享</p><ul><li><p>使用同一位移指针的文件共享：先打开文件，再<code>fork</code></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/a9e4a3c7e96f8cf5e91b8dedbaede05a.png" /></p></li><li><p>使用不同位移指针的文件共享：先<code>fork</code>，再打开文件</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/e34f5e74a7701f774f2c11aebd51d06e.png" /></p></li></ul></li><li><p>符号链接共享：符号链接又称软链接，是一种只有文件名，不指向inode的文件，通过名称引用文件。通过名称查找可以实现链接计算机系统中不同文件系统的文件。</p></li></ul><h3 id="磁盘空闲空间管理">磁盘空闲空间管理</h3><ul><li>位示图：1表示块已占用，0表示块空闲</li><li>空闲区表：（类似于存储管理中的可变分区存储管理）</li><li>空闲链表：将所有空闲块链接在一起</li></ul><h3 id="主存映射文件">主存映射文件</h3><blockquote><p>将文件映射到进程地址空间，使得进程可以通过读写虚存内容来实现文件读写操作</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230225112807801.png" /></p><h2 id="相关习题">相关习题</h2><ul><li>文件目录的主要作用是 <strong>按名存取</strong></li><li>在文件系统中，文件的不同物理结构有不同的优缺点。在下列文件的物理结构中，<strong>索引结构</strong>具有直接读写文件任意一个记录的能力，又提高了文件存储空间的利用率</li><li>在文件系统中，位示图可用于 <strong>磁盘空间的管理</strong></li><li>Unix系统中，通过 <strong>目录项</strong>实现文件系统的按名存取功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> nju-course-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储管理</title>
      <link href="/2023/02/13/nju-course-review-notes/os/memory-management/"/>
      <url>/2023/02/13/nju-course-review-notes/os/memory-management/</url>
      
        <content type="html"><![CDATA[<h2 id="存储管理基础">3.1 存储管理基础</h2><h3 id="存储管理主要模式">3.1.1 存储管理主要模式</h3><p>==逻辑地址==：相对地址，即用户程序所使用的地址空间。从0开始编号，有两种形式：一维逻辑地址（地址）；二维逻辑地址（段号：段内地址）</p><blockquote><p>段式程序设计：把一个程序设计成多个段：代码段、数据端、堆栈段等</p><p>用户可以自己应用 <strong>段覆盖技术</strong> 扩充内存空间使用量</p></blockquote><p>==物理地址==：绝对地址，即程序执行所使用的地址空间，处理器执行指令时按照物理地址进行。</p><h4 id="主存储器">主存储器</h4><p>多道程序设计需要复用主存</p><ul><li>按照分区复用：一个程序/程序段占用一个分区</li><li>按照页架复用：一个程序/程序段占用多个页架</li></ul><p>存储器管理的基本模式</p><ol type="1"><li>单连续存储管理：<u>一维逻辑地址空间</u>的程序占用<u>一个主存固定分区或可变分区</u></li><li>段式存储管理：<u>段式二维逻辑地址空间</u>的程序占用<u>多个主存可变分区</u></li><li>页式存储管理：<u>一维逻辑地址空间</u>的程序占用<u>多个主存页架区</u></li><li>段页式存储管理：<u>段式二维逻辑地址空间</u>的程序占用<u>多个主存页架区</u></li></ol><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221123201329326.png"alt="存储管理模式示意图" /><figcaption aria-hidden="true">存储管理模式示意图</figcaption></figure><h3 id="存储管理的功能">3.1.2 存储管理的功能</h3><h4 id="地址转换">地址转换</h4><ul><li>地址转换：又称重定位，即把逻辑地址转换为绝对地址</li><li>静态重定位：==程序装入内存时==进行地址转换</li><li>动态重定位：==在CPU执行程序时==进行地址转换</li></ul><h4 id="分配与去配">分配与去配</h4><ul><li>分配：进程装入主存时，存储管理软件进行具体的主存分配操作，并设置一个表格记录主存空间的分配情况</li><li>去配：当某个进程撤离或者主动归还主存资源时，存储管理软件要收回它所占用的全部或者部分存储空间，调整主存分配表信息</li></ul><h4 id="主存储器空间的共享">主存储器空间的共享</h4><p><u>多道程序设计技术</u>使若干个程序同时进入主存储器，各自占用一定数量的存储空间，<u>共同使用一个主存储器</u>，若干个协作进程有共同的主存程序块或者主存数据块</p><blockquote><p>存储保护问题，软硬件协同完成</p><ul><li>私有主存区中的信息：可读可写</li><li>公共区中的共享信息：看授权</li><li>非本进程信息：不可读写</li></ul></blockquote><h4 id="主存储器空间的扩充">主存储器空间的扩充</h4><ul><li>存储扩充：磁盘作为主存扩充，只把部分进程或者进程的部分内容装入内存。<ul><li>对换技术：把部分不运行的进程调出</li><li>虚拟技术：只调入进程的部分内容</li></ul></li></ul><h3 id="虚拟存储器的概念">3.1.3 虚拟存储器的概念</h3><h4 id="虚拟存储器">虚拟存储器</h4><blockquote><p>程序局部性原理：指程序在执行过程中的一个较短时间内，<u>所执行的指令地址</u><u>或操作数地址分别局限于一定的存储区域中</u></p></blockquote><p>1、原因：</p><ul><li>主存容量存在限制，使得用户编写程序受限，多道程序设计道数受限</li><li>存在空间局部性和时间局部性，使得某一阶段只需要部分进程内容</li></ul><p>2、基本思想：</p><ul><li>进程信息全部放在辅存，执行时==随用随调入==</li><li>把主存中暂时不用的信息调到辅存上去</li></ul><p>3、实现思路：</p><ul><li>建立两个地址空间<ul><li>（辅存）虚拟地址空间：容纳进程装入</li><li>（主存）实际地址空间：承载进程执行</li></ul></li><li>虚拟存储器是一种地址空间扩展技术，对用户透明，用户编程时以为可以操纵整个内存</li></ul><p>4、覆盖与交换</p><ul><li>覆盖：按照程序逻辑结构让那些不需要同时执行的程序段共享同一块内存区，使得后面的程序段可以调入内存覆盖前面的程序段。</li><li>交换：把处于等待状态的进程换出内存。</li></ul><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221123204556880.png"alt="虚拟存储器" /><figcaption aria-hidden="true">虚拟存储器</figcaption></figure><h3 id="存储管理的硬件支撑">3.1.4 存储管理的硬件支撑</h3><h4 id="存储器的组织层次">存储器的组织层次</h4><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221123204656005.png"alt="存储器金字塔层次" /><figcaption aria-hidden="true">存储器金字塔层次</figcaption></figure><p>存储管理涉及的存储对象：</p><ol type="1"><li>主存储器</li><li>Cache</li><li>为了获得更大的虚拟地址空间，存储管理需要对存放在硬盘、固态硬盘、甚至网络硬盘上的虚拟存储器文件进行管理</li></ol><h4 id="cache">Cache</h4><p>1、介于CPU和主存之间的高速缓冲存储器，SRAM组成，接近CPU速度。（主存DRAM）</p><p>2、CPU往往需要重复读取同样的数据块，时间局部性和空间局部性</p><p>3、组成：高速存储器、联想存储器、地址转换部件、替换逻辑</p><ul><li>联想存储器：根据内容进行寻址的存储器。</li><li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换。命中时直接访问Cache，未命中时从内存读取放入Cache。</li><li>替换部件：在Cache已满时按一定策略进行数据块替换，并修改地址转换部件。</li></ul><p>4、组织：L1、L2、L3三级</p><ul><li>L1 Cache：数据缓存和指令缓存；内置；32KB-256KB</li><li>L2 Cache：内置和外置；512KB—8MB</li><li>L3 Cache：多为外置</li></ul><h3 id="伙伴系统">伙伴系统</h3><ul><li>伙伴系统，又称buddy算法，是一种固定分区和可变分区折中的主存管理算法</li><li>任何尺寸为2<sup>i</sup>的空闲块都可以被分为两个尺寸为2<sup>i-1</sup>的空闲块，这两个空闲块称作伙伴</li><li>SunOS操作系统中首创的基于伙伴系统的<code>slab</code>分配器</li><li><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127151706379.png" /></li><li><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127151731055.png" /></li></ul><h3 id="分段和分页">分段和分页</h3><h4 id="分段">分段</h4><ul><li>分段是信息的物理单位，由源程序的逻辑结构所决定，用户可见</li><li>段长可以根据用户需要来规定，段起始地址可以从任何主存地址开始</li><li>分段方式下，源程序（段号，段内地址）经连结装配后地址仍保持二维结构</li><li><strong>段是不定长连续的</strong></li></ul><h4 id="分页">分页</h4><ul><li>分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见</li><li>页长由系统决定，页面只能以页大小的整数倍地址开始</li><li>分页方式中，源程序（页号，页内地址）经连结装配后地址变成了一维结构</li></ul><h2 id="单连续分区存储管理">3.2 单连续分区存储管理</h2><h3 id="单连续分区存储管理-1">3.2.1 单连续分区存储管理</h3><p>每个进程占用一个物理上完全连续的存储空间（区域）</p><h4 id="单用户连续分区管理存储">单用户连续分区管理存储</h4><ul><li>主存区域划分为系统区和用户区</li><li>设置一个栅栏寄存器界分两个区域，硬件用它在执行时进行地址转换</li><li>一般采用静态重定位进行地址转换</li><li>硬件实现代价低</li><li>适用于单用户单任务操作系统（DOS）</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126232350828.png" /></p><h4 id="固定分区存储管理">固定分区存储管理</h4><ul><li>支持多个分区</li><li>分区数量固定、大小固定</li><li>可用静态重定位</li><li>硬件实现代价低</li><li>早期OS采用</li></ul><p>主存分配：采用主存分配表记录主存的分配信息</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126232531636.png" /></p><p>地址转换</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126232815963.png" /></p><h4 id="可变分区存储管理">可变分区存储管理</h4><ul><li>固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存零头，有浪费</li><li>可变分区存储管理：允许按照进程实际内存需求动态划分分区，并允许分区个数可变</li></ul><h3 id="可变分区存储管理-1">3.2.2 可变分区存储管理</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126234630035.png" /></p><p>主存分配表：已分配区表和未分配区表，采用链表结构</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126234732011.png" /></p><p>分配算法：</p><ul><li>最先适配分配算法：空闲分区以<strong>地址递增</strong>的次序连接，分配内存时<strong>顺序查找</strong>，找到大小能满足要求的第一个空闲分区</li><li>邻近适配分配算法：循环首次适应算法，由首次适应算法演变而成，不同的是，分配内存时<strong>从上次查找结束的位置</strong>开始继续查找</li><li>最优适配分配算法：空闲分区按<strong>容量递增的方式</strong>形成分区链，找到第一个满足要求的空闲分区</li><li>最坏适配分配算法：空闲分区以<strong>容量递减的次序</strong>连接，找到第一个能满足要求的空闲分区</li></ul><p>地址转换</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126234915421.png" /></p><p><strong>内存零头</strong></p><ul><li>固定分区方式会产生<u>内存内零头</u></li><li>可变分区方式会产生<u>内存外零头</u></li><li>分段方式会产生内存外零头</li><li>分页方式会产生内存内零头</li><li>最优适配算法最容易产生外零头，<u>外零头是不可避免的</u></li></ul><p><strong>移动技术（程序浮动技术）</strong></p><ul><li>移动分区以解决内存外零头</li><li>需要动态重定位的支撑</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126235242772.png" /></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126235315170.png"alt="工作流程" /><figcaption aria-hidden="true">工作流程</figcaption></figure><h2 id="页式存储管理">3.3 页式存储管理</h2><h3 id="页式存储管理的基本原理">3.3.1 页式存储管理的基本原理</h3><ul><li>分页存储器将主存划分成多个大小相等的==页架==</li><li>受页架尺寸限制，程序的逻辑地址也自然分成==页==</li><li>不同的页可以放在不同的页架中，不需要连续</li><li>页表用于维系进程的主存完整性</li><li>可用一张位示图来记录主存分配情况</li></ul><p>地址转换</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127000913182.png" /></p><p>页的共享</p><ul><li>页式存储管理能够实现多个进程共享程序和数据</li><li>数据共享：不同进程可以使用不同页号共享数据页</li><li>代码共享：不同进程必须使用相同页号共享代码页（JMP指令在不同页号是做不到的）</li></ul><h3 id="页式存储管理的地址转换">3.3.2 页式存储管理的地址转换</h3><h4 id="转换代价">转换代价</h4><ul><li>每次地址转换需要访问两次主存<ul><li>读取页表</li><li>读写数据</li></ul></li><li>降低存取速度</li><li>利用Cache存放部分页表</li></ul><h4 id="快表">快表</h4><ul><li>这种高速存储器是联想存储器，即按内容寻址，而非按照地址寻址</li></ul><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127002107339.png"alt="地址转换" /><figcaption aria-hidden="true">地址转换</figcaption></figure><h3 id="页式虚拟存储管理">3.3.3 页式虚拟存储管理</h3><p>把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后，根据执行行为，动态调入不在主存中的页，同时进行必要的页面调出。</p><p><strong>现代OS的主流存储管理技术</strong></p><p>首次只把进程的第一页信息装入主存，称为==请求页式存储管理==</p><p>需要扩充页表</p><ul><li><p>原本是：只存放主存块号</p></li><li><p>现在需要：<u>标志位</u>（主存驻留标志，写回标志，保护标志、引用标志、可移动标志）+<u>主存块号</u>+<u>辅助存储器地址</u></p></li></ul><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127132726430.png"alt="地址转换" /><figcaption aria-hidden="true">地址转换</figcaption></figure><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127132805046.png"alt="缺页中断" /><figcaption aria-hidden="true">缺页中断</figcaption></figure><h3 id="页面调度">3.3.4 页面调度</h3><p>当主存空间已满但是有需要装入新页时，页式虚拟存储管理必须按照一定的算法把已在主存的一些页调出去</p><ul><li>页面调度：选择淘汰页的工作</li><li>页面调度算法：选择淘汰页的算法</li><li>如果页面调度算法设计不当，会出现==抖动/颠簸==现象，即刚被淘汰的页面立即又要调入，如此反复</li></ul><h4 id="缺页中断率">缺页中断率</h4><ul><li><p>定义：不成功访问的次数 / 访问的总次数</p></li><li><p>影响缺页中断率的因素</p><ul><li><u>分配给进程的页架数</u>：可用页架数越多，缺页中断率就越低</li><li><u>页面的大小</u>：尺寸越大，缺页中断率就越低</li><li><u>用户的程序编制方法</u></li></ul></li><li><p>经典例子</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127133944658.png" /></p></li></ul><h4 id="调度算法">调度算法</h4><ul><li>OPT页面调度算法：<u>理想的调度算法</u>，当要调入新页面时，<u>首先淘汰以后不再访问的页，然后选择距离现在最长时间后再访问的页</u><ul><li>Belady算法，又称最佳算法</li><li>OPT只可模拟，不可实现</li></ul></li><li>先进先出FIFO页面调度算法<ul><li>总是淘汰<u>最先调入主存的那一页</u>（主存驻留时间最长的那一页）</li><li>思想：模拟的是程序执行的顺序性</li><li><strong>Belady异常</strong>：增加可用物理页框的数量会导致更多的缺页异常。</li></ul></li><li>最近最少使用LRU页面调度算法<ul><li>淘汰<u>最近一段时间较久未被访问的那一页</u></li><li>思想：那些刚刚被使用过的页面，可能马上还要被用到</li><li>需要维护特殊队列</li><li><strong>时间间隔中断，中断时页引用标志位置0</strong></li><li>地址转换时，页引用标志位置1</li><li>淘汰页面时，从页引用标志位为0的页中随机淘汰</li></ul></li><li>最不常用LFU页面调度算法<ul><li>淘汰<u>最近一段时间内访问次数最少的页面</u></li><li><strong>基于时间间隔中断</strong>，给每一页设置一个计数器</li><li><strong>时间间隔中断发生后，所有计数器清0</strong></li><li>每访问页1次就给计数器加1</li><li>选择计数值最小的页面淘汰</li></ul></li><li>时钟CLOCK页面调度算法<ul><li>采用循环队列机制构造页面队列</li><li>工作流程<ul><li>页面调入主存和访问主存页面时，引用标志位置1</li><li>淘汰页面时，从指针当前指向的页面开始扫描循环队列<ul><li>遇到引用标志位是1的页面将引用标志位清0</li><li>遇到引用标志位是0的页面淘汰，指针推进一步，算法停止</li><li><strong>如果引用标志位全部是1</strong>，指针会环绕整个循环队列一圈，把碰到的引用标志位清0，指针停在起始位置（开始遍历的位置），并淘汰该页，然后指针向前推进一步</li></ul></li></ul></li></ul></li><li>局部最佳页面替换算法（MIN）<ul><li>如果该页面在时间间隔<span class="math inline">\((t,t+\tau)\)</span>内未被引用，那么就移除；否则该页被保留在进程驻留集中</li></ul></li><li>工作集置换算法（WS）<ul><li>==进程工作集==：在某一段时间间隔内进程运行所需访问的页面集合<ul><li><span class="math inline">\(W(t, \Delta)\)</span>表示在时刻<spanclass="math inline">\(t-\Delta\)</span>到时刻<spanclass="math inline">\(t\)</span>之间所访问的页面集合，进程在时刻<spanclass="math inline">\(t\)</span>的工作集</li></ul></li><li>实现思想：不向前查看页面引用串，而是基于程序局部性原理向后看</li><li>定期地从进程驻留集中删去那些不在工作集中的页面。如果页面在时间间隔<spanclass="math inline">\((t-\Delta, t)\)</span>内未被引用，就要移除。</li></ul></li></ul><h3 id="反置页表">3.3.5 反置页表</h3><p><strong>针对内存中的每个页架建立一个页表，按照块号排序</strong></p><p>反置页表项</p><ul><li>页号：虚拟地址页号部分</li><li>进程标志符：使用该页的进程</li><li>控制位</li><li>链指针</li></ul><p>地址转换过程</p><ul><li>MMU通过哈希表把<u>进程标识</u>和<u>虚拟页号</u>转换成一个哈希值，指向IPT的一个表目</li><li>MMU<u>遍历哈希链</u>找到所需进程的虚页号，<u>该项的索引就是页架号</u>，通过拼接位移便可生成物理地址</li><li>若遍历整个反置页表中未能找到匹配页表项，说明该页不在内存，产生缺页中断，请求操作系统调入</li></ul><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127190347147.png"alt="地址转换" /><figcaption aria-hidden="true">地址转换</figcaption></figure><h3 id="多级页表">3.3.6 多级页表</h3><ul><li>系统为每个进程建一张页目录表，它的每个表项对应一个页表页，而页表页的每个表项给出了页面和页框的对应关系，页目录表是一级页表，页表页是二级页表</li><li>逻辑地址结构由三部分组成：页目录、页表页和位移</li><li><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127185029725.png" /></li></ul><h3 id="页的大小">页的大小</h3><blockquote><p>页的大小会影响很多因素</p></blockquote><h3 id="tlb快表">TLB快表</h3><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127212343408.png"alt="快表" /><figcaption aria-hidden="true">快表</figcaption></figure><h2 id="段式存储管理">3.4 段式存储管理</h2><h3 id="段式存储管理-1">3.4.1 段式存储管理</h3><h4 id="段式程序设计">段式程序设计</h4><ul><li>每个程序可有若干段组成，每一段都可以从“0”开始编址，段内地址是连续的</li><li>分段存储器的逻辑地址由两部分组成：<u>段号+单元号</u></li></ul><h4 id="基本思想">基本思想</h4><ul><li><p>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区</p></li><li><p>存储管理需要增加设置一个段表，每个段站占用一个段表项：段起址+段限长+标志位</p></li><li><p>转换流程</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127145627167.png" /></p></li><li><p>段的共享：通过不同进程段表中的项指向同一个段基址来实现，对共享段的信息必须进行保护。</p></li></ul><h3 id="段式虚拟存储管理">3.4.2 段式虚拟存储管理</h3><ul><li>进程的所有分段都存放在辅存中，进程运行时先把需要的段装入内存，执行过程中再动态装入</li><li><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127150229497.png"alt="地址转换" /><figcaption aria-hidden="true">地址转换</figcaption></figure></li></ul><h3 id="段页式存储管理">3.4.3 段页式存储管理</h3><ul><li>段式存储管理可以基于页式存储管理实现，每一段不必占据连续的存储空间，可以存放在不连续的主存页架中=&gt; 段页式存储管理，装入部分段或者装入段中的部分页面</li><li><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127150559962.png"alt="段表和页表" /><figcaption aria-hidden="true">段表和页表</figcaption></figure></li><li><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127150539225.png"alt="地址转换" /><figcaption aria-hidden="true">地址转换</figcaption></figure></li><li><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127150648346.png" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> nju-course-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备管理</title>
      <link href="/2023/02/12/nju-course-review-notes/os/device-management/"/>
      <url>/2023/02/12/nju-course-review-notes/os/device-management/</url>
      
        <content type="html"><![CDATA[<h2 id="设备管理基础">4.1 设备管理基础</h2><h3 id="设备管理概述">4.1.1 设备管理概述</h3><ul><li><p><strong>I/O设备</strong>：输入输出设备、外围设备、外部设备、外设。用于计算机系统与外部世界的信息交换或存储。</p></li><li><p><strong>I/O系统</strong>：I/O设备及其接口线路、控制部件、通道和管理软件</p></li><li><p><strong>I/O操作</strong>：内存和外设间的信息传送操作。</p><ul><li>影响计算机系统的<u>通用性</u>和<u>可扩充性</u></li><li>影响计算机系统的<u>综合处理能力及性价比</u></li></ul></li></ul><h4 id="io设备分类">I/O设备分类</h4><h5 id="信息传输视角">信息传输视角</h5><ul><li>输入设备：键盘、鼠标、扫描仪</li><li>输出设备：显示器、打印机</li><li>输入输出设备：磁盘驱动器、网卡</li></ul><h5 id="交互功能视角">交互功能视角</h5><ul><li>人机交互设备：鼠标、键盘、显示器</li><li>存储设备（==存储大量信息并快速检索==）：磁盘驱动器、光盘驱动器</li><li>机机通信设备：网卡、调制解调器</li></ul><h5 id="设备管理视角">设备管理视角</h5><ul><li>字符设备：鼠标、显示器，以==字符为单位==进行信息交换</li><li>块设备：磁盘，以固定大小的==数据块为单位==进行信息交换</li><li>网络设备：机机通信设备（网卡），即可抽象为 字符设备 也可抽象为块设备</li></ul><h4 id="设备管理的目标">设备管理的目标</h4><ol type="1"><li><strong>解决设备与CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率</strong></li><li>操作系统将所有设备都定义为文件，统一在文件系统之下</li><li>屏蔽设备的物理细节和操作过程，配置驱动程序，提供统一界面<ol type="1"><li>抽象为裸设备</li><li>抽象为设备文件</li></ol></li></ol><h4 id="设备管理的功能">设备管理的功能</h4><ol type="1"><li>设备中断处理</li><li>缓冲区管理</li><li>设备的分配和去配</li><li>设备驱动调度</li><li>虚拟设备的实现</li></ol><h4 id="设备管理的实现层次">设备管理的实现层次</h4><ul><li>I/O硬件<ul><li>I/O设备及其接口路线</li><li>控制部件</li><li>通道</li></ul></li><li>I/O软件<ul><li>系统I/O软件</li><li>用户空间I/O软件</li></ul></li></ul><h3 id="io控制方式">4.1.2 I/O控制方式</h3><h4 id="设备控制器">设备控制器</h4><p>优势：引入控制器后，通过传递简单参数就可进行I/O操作，大大简化系统的设计，有利于计算机系统对各类控制器和设备的兼容性</p><p>模块化和通用性的设计目标 =》机械部件 + ==电子部件==</p><p><strong>电子部件</strong>：==设备控制器==；<u>系统与设备控制器交互</u>；设备控制器具体控制设备进行I/O。</p><p>设备控制器是 CPU 和 设备之间的接口，具有以下功能：</p><ol type="1"><li>接收和识别 CPU或通道 发来的命令 =》控制寄存器</li><li>实现数据交换 =》 数据寄存器</li><li>发现和记录设备及自身的状态信息，供CPU处理时使用 =》状态寄存器</li><li>当连接多台设备时，识别设备地址 =》对寄存器寻址</li></ol><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E6%88%90.png"alt="设备控制器的组成" /><figcaption aria-hidden="true">设备控制器的组成</figcaption></figure><blockquote><p>注意：一个I/O控制器可能对应多个设备；数据寄存器、状态寄存器和控制寄存器也可能有多个。</p></blockquote><h4 id="io控制方式-1">I/O控制方式</h4><h5 id="轮询方式">轮询方式</h5><p>==CPU和I/O设备串行操作==</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230222163641779.png"alt="轮询方式" /><figcaption aria-hidden="true">轮询方式</figcaption></figure><blockquote><p>读写数据：1、从I/O模块中读取字 2、往存储器中写入字</p></blockquote><h5 id="中断方式">中断方式</h5><p>==CPU与I/O设备并行工作==</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230222163707920.png"alt="中断方式" /><figcaption aria-hidden="true">中断方式</figcaption></figure><p>处理器发送指令给控制器，然后继续执行指令=》I/O操作完成后，控制器发起中断请求 =》...</p><blockquote><p>一旦涉及大量数据传输，就会需要频繁的中断处理，消耗较多CPU的时间</p></blockquote><h5 id="dma方式">DMA方式</h5><blockquote><p>DMA：Direct Memory Access 直接存储器存取</p></blockquote><p>内存和设备之间有一条数据通路==成块==地传送数据，无须CPU干预，实际数据传输操作由DMA直接完成。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230222165648687.png"alt="DMA方式" /><figcaption aria-hidden="true">DMA方式</figcaption></figure><p>处理器向DMA发出I/O命令，继续自己的工作 =》DMA完成数据传输后，中断处理器</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230222165629970.png"alt="DMA控制器" /><figcaption aria-hidden="true">DMA控制器</figcaption></figure><blockquote><p>注意：DMA控制器并不是每次直接读入一整块的数据，也是一个字一个字的传输，从I/O设备 =》DR =》内存</p><p>一次读写一个或多个块（<strong>多个块必须是连续的</strong>）</p></blockquote><p>==周期窃取==：同时通过总线访问主存时，CPU让出总线占有权给DMA</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125185725792.png" /></p><p><strong>DMA的总线类型</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125185818229.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125185834509.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125185901377.png" /></p><h5 id="io通道">I/O通道</h5><p>==通道控制器==，用于完成逻辑上独立的I/O任务。</p><p>主机、通道、控制器和设备之间采用四级连接，实施三级控制，一个CPU连接若干个通道，一个通道连接若干个控制器，一个控制器连接若干个设备。</p><p><strong>处理器不再执行I/O指令，而是在主存中组织通道程序，由I/O通道执行，CPU与通道高度并行工作</strong></p><p>CPU启动指定通道上的设备，通道控制设备进行操作，CPU执行其他任务 =》I/O操作完成，中断处理器处理I/O操作结束事件。</p><table><thead><tr class="header"><th>CPU作用</th><th>等待设备</th><th>内存数据交换</th></tr></thead><tbody><tr class="odd"><td>轮询方式</td><td>需要</td><td>需要</td></tr><tr class="even"><td>中断方式</td><td>不需要</td><td>需要</td></tr><tr class="odd"><td>DMA方式</td><td>不需要</td><td>不需要</td></tr><tr class="even"><td>I/O通道</td><td>不需要</td><td>不需要</td></tr></tbody></table><h4 id="io功能的演化">I/O功能的演化</h4><ol type="1"><li><p>处理器直接控制外围设备</p></li><li><p>增加了控制器或I/O模块：<u>程序控制</u></p><blockquote><p>处理器开始从外围设备接口的具体细节中分离出来</p></blockquote></li><li><p>采用<u>中断方式</u>的控制器或I/O模块</p></li><li><p>I/O模块通过<u>DMA</u>直接控制存储器</p></li><li><p>I/O模块被增强为单独的处理器，有专门为I/O设计的指令集</p></li><li><p>I/O模块有自己的局部存储器，本身就是一台计算机</p></li></ol><h3 id="总线与io">4.1.3 总线与I/O</h3><h4 id="单总线结构">单总线结构</h4><p>将CPU、主存和I/O模块连接到同一总线</p><p>优点：结构简单，易于扩充</p><p>缺点：共用总线，设备多时总线压力大，传输时延长，且慢速外设占用带宽多</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230222165730821.png"alt="单总线结构" /><figcaption aria-hidden="true">单总线结构</figcaption></figure><blockquote><p>待补充</p></blockquote><h2 id="设备管理软件">4.2 设备管理软件</h2><h3 id="io软件的实现层次">4.2.1 I/O软件的实现层次</h3><h4 id="io软件的设计目标">I/O软件的设计目标</h4><ul><li>设计目标<ul><li>高效性：最关注磁盘I/O的效率</li><li>通用性：用统一标准的方法来管理所有设备</li></ul></li><li>设计思路：层次结构，低层软件屏蔽硬件细节，高层软件与用户友好交互</li><li>主要问题<ul><li>设备无关性<ul><li>访问设备的程序与具体物理设备无关</li></ul></li><li>出错处理<ul><li>数据传输中的错误应该尽可能在靠近硬件的地方处理，尽量在低层次处理</li></ul></li><li>同步（阻塞）——异步（中断驱动）传输<ul><li>异步传输：CPU启动I/O后可以继续执行其他工作，直到中断到达</li><li>同步传输：阻塞方式，让启动I/O的进程阻塞等待，直到数据传输完成</li></ul></li><li>独占型外围设备和共享型外围设备<ul><li>建立数据缓冲区，让数据到达与离去率相匹配，提高系统吞吐率</li></ul></li></ul></li></ul><h4 id="io软件的层次结构">I/O软件的层次结构</h4><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126103415450.png"alt="I/O设备层次结构" /><figcaption aria-hidden="true">I/O设备层次结构</figcaption></figure><h3 id="io软件的实现">4.2.2 I/O软件的实现</h3><h4 id="io中断驱动程序">I/O中断驱动程序</h4><ul><li>位于操作系统底层，与硬件密切相关</li><li>设备向CPU提出中断请求时，CPU响应并转入中断处理程序执行，通常做的工作<ul><li>检查设备状态寄存器，判断中断原因</li><li><u>若传输有错</u>：向上层软件报告设备的出错信息，实施重新执行</li><li><u>若正常结束</u>：唤醒等待传输的进程，使其转换为就绪态</li><li><u>若有等待传输的I/O命令</u>：通知相关软件启动下一个I/O请求</li></ul></li></ul><h4 id="设备驱动程序">设备驱动程序</h4><ul><li>包括与设备密切相关的所有代码</li><li><strong>把用户提交的逻辑I/O请求转化为物理I/O操作的启动和执行</strong>，如设备名=》端口地址，逻辑记录=》物理记录，逻辑操作=》物理操作</li></ul><h4 id="独立于设备的io软件">独立于设备的I/O软件</h4><ul><li>对设备驱动程序的统一接口</li><li><strong>设备命名</strong><ul><li><u>设备都被看作文件</u>，通过路径名进行寻址</li><li>设备不仅具有文件名，<u>且支持与文件相关的所有系统调用</u>，open、close、read等</li><li>设备文件依赖于inode来实现，文件目录并不能区分文件名是代表一个磁盘文件或设备文件。但是inode中的内容是不一样的，磁盘文件的inode包含指向数据块的指针，而设备文件的inode则包含指向内核设备驱动程序的指针，用来控制设备的I/O</li></ul></li><li><strong>设备保护</strong><ul><li>设备保护需要检查用户是否有权访问所申请的设备（I/O指令是特权指令，通过系统调用间接供用户使用）</li><li>Unix/Linux中对I/O设备的特别文件采用rwx保护机制，对文件的保护规则也适用于I/O设备</li></ul></li><li>提供与设备无关的块尺寸<ul><li>屏蔽不同磁盘扇区大小并向高层软件提供统一大小的逻辑块</li></ul></li><li>缓冲区管理<ul><li>通过缓冲区来消除填满速率和清空速率之间的影响，块设备和字符设备都需要缓冲技术，可在主存建立缓冲区的方式解决</li></ul></li><li>分配与状态跟踪<ul><li>静态、动态、虚拟分配</li></ul></li><li>出错处理和报告<ul><li>错误处理多数由驱动程序完成，低层软件完成不了的情况，交给高层软件处理</li></ul></li></ul><h4 id="用户空间的io软件">用户空间的I/O软件</h4><ul><li>库函数实现的I/O系统调用</li><li>库函数将与应用程序链接在一起，形成可执行代码装入主存，库函数也是I/O系统的一部分</li><li><strong>库函数所做的工作只是将系统调用所需要的参数放在合适的位置，然后陷入内核，由内核函数实现真正的I/O操作</strong></li></ul><h3 id="io缓冲">I/O缓冲</h3><h4 id="目的">目的</h4><ol type="1"><li>解决CPU与设备之间速度不匹配的矛盾</li><li>协调逻辑记录大小与物理记录大小不一致的问题</li><li>提高CPU和设备的并行性</li><li>减少I/O操作对CPU的中断次数</li><li>放宽对CPU中断响应时间的要求</li></ol><blockquote><p>面向块：数据存储和传送以块为单位，块的大小通常固定，可以通过块号访问数据（磁盘和磁带）</p><p>面向流：设备以字节流的方式传输数据（终端、打印机、通信端口、鼠标和<u>其他指示设备</u>以及大多数<u>非辅存的其他设备</u>）</p></blockquote><h4 id="io缓冲区">I/O缓冲区</h4><p>在内存中开辟的存储区，专门用于临时存放I/O操作的数据</p><h4 id="单缓冲技术">单缓冲技术</h4><p>输入传送的数据放到缓冲区中，传送完成时，进程将该块移动到用户空间，并立即请求另一块，称为超前（预先输入）</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230222165818611.png"alt="单缓冲技术" /><figcaption aria-hidden="true">单缓冲技术</figcaption></figure><h4 id="双缓冲技术">双缓冲技术</h4><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230222165839461.png"alt="双缓冲技术" /><figcaption aria-hidden="true">双缓冲技术</figcaption></figure><h4 id="循环缓冲技术">循环缓冲技术</h4><p>使得I/O操作能够跟得上进程的执行</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230222165856069.png"alt="循环缓冲技术" /><figcaption aria-hidden="true">循环缓冲技术</figcaption></figure><h2 id="独占型外围设备的分配">4.3 独占型外围设备的分配</h2><blockquote><p>设备分配</p><ul><li>设备特性：独占设备、共享设备和虚拟设备三类</li><li>管理和分配外围设备的技术：独占方式、共享方式和虚拟方式</li></ul></blockquote><h3 id="设备独立性">4.3.1 设备独立性</h3><p>用户通常不指定物理设备，而是<u>指定逻辑设备</u>，使得用户进程和物理设备分离开来，再通过其他途径建立逻辑设备和物理设备之间的映射（系统需要提供逻辑设备名和物理设备名的对应表）</p><p>原因：如果直接指定某个物理设备的话，虽然会让设备分配变得简单，但是一旦该物理设备出现故障，即使系统中存在同类设备也不能运行</p><p>优点：1、<strong>应用程序和具体物理设备无关</strong>，变更设备时不需要修改源码。2、<strong>易于应对各种I/O设备故障</strong>，提高系统的可靠性。3、<strong>增加设备分配的灵活性</strong>，有利于更加有效地利用设备资源，实现多道程序设计。</p><h3 id="独占型外围设备的分配-1">4.3.2 独占型外围设备的分配</h3><p>独占型外围设备：一次只能由一个进程独占使用</p><p>分配方式：1、静态分配，运行前申请，实现简单，防止死锁，但是降低设备利用率</p><p>​ 2、动态分配，随用随分配，提高设备利用率</p><p>设备分配的数据结构：设备类表（记录各类设备的信息）设备表（记录某一类设备的信息）</p><p><strong>设备分配算法</strong>（不知道重不重要）</p><ol type="1"><li>根据设备类查找设备类表</li><li>若无空闲设备则等待设备</li><li>取得设备表首地址</li><li>查设备表发现空闲设备栏</li><li>若未发现空闲设备栏则等待设备</li><li>填占用进程号，逻辑设备名，分配设备</li></ol><h2 id="共享型外围设备的驱动">4.4 共享型外围设备的驱动</h2><h3 id="磁盘的物理结构">4.4.1 磁盘的物理结构</h3><h4 id="磁盘结构">磁盘结构</h4><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125165707732.png"alt="磁盘" /><figcaption aria-hidden="true">磁盘</figcaption></figure><ul><li>磁盘由多个盘片组成</li><li>每个盘片一般有两个盘面（上下两个）</li><li>盘面包括多个同心圆结构的磁道</li><li>不同盘面上位于相同位置的磁道构成柱面</li><li>每个磁道分为固定多个扇区，相邻扇区组合成簇</li><li>物理块地址：柱面号，磁头号（盘面号），扇区号</li></ul><h4 id="磁盘读写数据的方式">磁盘读写数据的方式</h4><ol type="1"><li>寻道：控制移动臂到达指定柱面</li><li>旋转：等待要读写的扇区旋转到磁头下</li><li>选择磁头号，进行数据读写</li></ol><h4 id="磁盘存取时间">磁盘存取时间</h4><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221125170404914.png"alt="磁盘存取时间" /><figcaption aria-hidden="true">磁盘存取时间</figcaption></figure><h3 id="磁盘的驱动调度">4.4.2 磁盘的驱动调度</h3><p>磁盘可能同时接收到若干I/O请求，OS进行磁盘的驱动调度策略：1、移臂调度；2、旋转调度</p><h4 id="移臂调度">移臂调度</h4><p>目的：使移动臂的移动时间最短，从而减少寻道总时间</p><ul><li>先来先服务（==FIFO/FCFS==）：移臂距离大，性能不好</li><li>优先级（==Priority==）<ul><li><u>比较短的批作业和交互作业的优先级较高，而较长计算时间的长作业优先级较低</u></li><li>长作业等待时间较长</li></ul></li><li>后进先出（==LIFO==）<ul><li>把设备资源优先提供给最后到来的用户</li><li>局部性好，提高吞吐率，资源利用率高</li><li>可能出现“饿死”</li></ul></li><li>最短服务时间优先（==SSTF==）：优先处理服务时间更短的请求（选择使磁头从当前位置开始移动的最少的请求），存在饥饿现象</li><li>扫描算法<ul><li>单向扫描：移动臂向一个方向扫描，归途不提供服务</li><li>双向扫描（==SCAN==）：移动臂每次向一个方向移动，遇到最近的I/O请求便进行处理，<strong>到达最后一个柱面后</strong>再向反方向移动<font color='red'>（<strong>双向到底</strong>）</font></li><li>电梯调度（==LOOK==）：双向扫描的改进，<strong>当前移动方向没有访问请求时</strong>，就改变移动方向<font color='red'>（<strong>双向不到底</strong>）</font></li><li>循环扫描（==C-SCAN==）：把扫描限定在一个方向，当访问到沿某个方向的最后一个磁道时，磁头臂返回到磁盘相反方向磁道的末端（<strong>归途不提供服务</strong>），再次开始扫描<font color='red'>（<strong>单向到底</strong>）</font></li><li>==C-LOOK==：循环电梯？循环扫描的改进，当移动方向没有访问请求的时候，改变移动方向（<strong>归途不提供服务</strong>）<font color='red'>（<strong>单向不到底</strong>）</font></li><li>==N-step-SCAN==<ul><li>进程如果重复请求同一个磁道就会垄断整个设备，故采用分布扫描避免此类问题</li><li><strong>把磁盘请求队列分成长度为N的子队列，每一次用SCAN处理一个子队列</strong>，处理一个队列时，新请求必须添加到其他某个队列中。</li></ul></li><li>==FSCAN==<ul><li>使用两个子队列</li><li>开始扫描时，所有请求处于一个队列中，另一个队列为空；扫描过程中，新到的请求放入另一个队列中</li></ul></li></ul></li></ul><h4 id="旋转调度">旋转调度</h4><p>目的：使得旋转延迟的总时间最少</p><ul><li>循环排序：在最少旋转圈数内完成位于同一柱面的访问请求<ul><li>旋转位置测定硬件 和 多磁头同时读写技术 有利于提高旋转调度的效率</li></ul></li><li>优化分布：通过信息在存储空间的排列方式来减少旋转延迟<ul><li>交替排序：由于磁盘匀速运转，可能处理当前扇区数据时，下个扇区已经跳过了。所以，对扇区间隔编号，如交叉因子<code>n:1</code>表示相邻编号间会间隔<code>n-1</code>个扇区，这样当处理完扇区数据之后可能正好达到下一个编号的扇区。</li></ul></li></ul><h3 id="raid">RAID</h3><ul><li><p>RAID0</p><p><u>并行交叉存取，适用于大数据量的I/O请求，无冗余校验</u></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126000256864.png"alt="RAID0" /><figcaption aria-hidden="true">RAID0</figcaption></figure></li><li><p>RAID1</p><p><u>容量下降一半，成本很高</u></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126000339022.png"alt="RAID1" /><figcaption aria-hidden="true">RAID1</figcaption></figure></li><li><p>RAID2</p><p><u>并行存取，海明校验码，成本较高</u></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126000536145.png"alt="RAID2" /><figcaption aria-hidden="true">RAID2</figcaption></figure></li><li><p>RAID3</p><p><u>只用一个冗余盘，采用奇偶校验技术</u></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126000626692.png"alt="RAID3" /><figcaption aria-hidden="true">RAID3</figcaption></figure></li><li><p>RAID4</p><p><u>独立存取磁盘阵列，数据条带交叉存放</u></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126000656448.png"alt="RAID4" /><figcaption aria-hidden="true">RAID4</figcaption></figure></li><li><p>RAID5</p><p><u>奇偶校验码循环分布在每个盘上使容错性更好</u></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126000713694.png"alt="RAID5" /><figcaption aria-hidden="true">RAID5</figcaption></figure></li><li><p>RAID6</p><p><u>双重冗余技术，且采用两种不同的数据校验算法</u></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126000736328.png"alt="RAID6" /><figcaption aria-hidden="true">RAID6</figcaption></figure></li></ul><h3 id="磁盘cache">磁盘Cache</h3><blockquote><p>主存中为磁盘扇区设置的一个缓冲区，利用局部性原理，减少存储器存取时间</p></blockquote><ul><li>LRU：替换Cache中未被访问的时间最长的块</li><li>LFU：替换Cache中访问次数最少的块</li></ul><h2 id="虚拟设备">4.5 虚拟设备</h2><h3 id="spooling-系统">4.5.1 SPOOLing 系统</h3><h4 id="虚拟设备技术">虚拟设备技术</h4><p>使用一类物理设备模拟另一类物理设备的技术，通常是使用共享型外围设备模拟独占型外围设备。</p><ul><li>内存卡模拟磁盘</li><li>块设备模拟字符设备</li><li>输入输出重定向</li></ul><h4 id="spooling设备">SPOOLing设备</h4><blockquote><p>外部设备联机并行操作（Simultaneous Peripheral OperationsOn-Line）</p><p>关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”</p></blockquote><p>一个经典的SPOOLing系统：<strong>用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间</strong></p><ul><li>“井”是用作缓冲的存储区域，采用井的技术能调节供求之间的矛盾，消除人工干预带来的损失。</li><li>“预输入程序”：预先把数据从输入设备传送到磁盘输入井</li><li>”缓输出程序“：把数据从磁盘输出井传送到输出设备</li><li>“井管理程序”：控制进程与井之间的数据交换（I/O重定向）</li></ul><p><u>全部的I/O都基于磁盘，加快进程周转时间，提高系统吞吐量</u></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126101616883.png"alt="SPOOLing系统" /><figcaption aria-hidden="true">SPOOLing系统</figcaption></figure><p>打印SPOOLing系统</p><ul><li>守护进程是唯一有特权使用打印机设备的进程</li><li>打印文件前，用户进程先产生完整的待输出文件，并存放在打印目录下</li><li>打印机空闲时，启动守护进程，打印待输出文件</li></ul><h3 id="批处理系统的作业管理">4.5.2 批处理系统的作业管理</h3><p>作业调度和进程调度的关系</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221126102228704.png"alt="作业调度和进程调度的关系" /><figcaption aria-hidden="true">作业调度和进程调度的关系</figcaption></figure><h2 id="相关习题">4.6 相关习题</h2><ul><li>CPU输出数据的速度远远高于打印机的打印速度，为了解决这一矛盾，可采用<strong>缓冲技术</strong></li><li>为了使多个进程能有效地同时处理输入和输出，最好使用<strong>缓冲池</strong> 结构的缓冲技术</li><li>在采用SPOOLing技术的系统中，用户的打印结果首先被送到<strong>磁盘固定区域</strong></li><li>采用假脱机技术，将磁盘的一部分作为公共缓冲区以代替打印机，用户对打印机的操作实际上是对磁盘的存储操作，用以代替打印机的部分是<strong>虚拟设备</strong></li><li>将系统中的每一台设备按某种原则进行统一的编号，这些编号作为区分硬件和识别设备的代号，该编号称为设备的<strong>绝对号</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> nju-course-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类</title>
      <link href="/2023/02/10/Java/java-collection/"/>
      <url>/2023/02/10/Java/java-collection/</url>
      
        <content type="html"><![CDATA[<h2 id="集合中的fail-fast">集合中的fail-fast</h2><blockquote><p><code>fail-fast</code>其实是一种设计思想，即在程序出现错误时不再继续向下执行，而是抛出异常退出。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String name : names) &#123;<br>    <span class="hljs-keyword">if</span> (...) &#123;<br>        names.remove(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码就会触发<code>fail-fast</code>错误，抛出异常<code>ConcurrentModificationException</code>。</p><p><strong>产生的原因</strong>：增强的for循环本质上是一个语法糖，实际上是通过迭代器实现。</p><p>通过查看报错位置可以发现，抛出异常的原因是<code>modCount</code>和<code>expectedModCount</code>两个变量不相同。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210202342425.png" /></p><ul><li><code>modCount</code>：成员变量，记录集合被修改的次数</li><li><code>expectedModCount</code>：内部类<code>Itr</code>的成员变量，表示这个迭代器预期该集合被修改的次数，在<code>Itr</code>被创建时被初始化为当前<code>modCount</code>值，只有通过迭代器修改集合才会更新该值</li></ul><p>而上面的<code>remove</code>代码的核心部分<code>fastRemove</code>更新了<code>modCount</code>，但是由于增强for循环创建了<code>Itr</code>，而没有使用迭代器去删除元素，就导致了<code>modCount</code>和<code>expectedModCount</code>不一致。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210202944702.png" /></p><p><strong>解决方法</strong>：使用普通for循环...</p><h2 id="arraylist">ArrayList</h2><h3 id="概述">概述</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211154139737.png" /></p><ul><li><code>RandomAccess</code>：标识类，并无实现，标识该类支持快速随机访问</li><li><code>Cloneable</code>：可以调用<code>clone()</code>方法克隆对象</li><li><code>java.io.Serializable</code>：可序列化</li></ul><h3 id="和-linkedlist-的比较">和 LinkedList 的比较</h3><ul><li>是否线程安全</li><li>底层数据结构</li><li>增删查的复杂度</li><li>内存空间占用</li></ul><h3 id="arraylist扩容机制">ArrayList扩容机制</h3><p>1、ArrayList提供了三个构造函数</p><blockquote><p>要注意的是如果使用无参构造，底层的数组是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，结合后面的扩容机制可以发现当<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>第一次add元素时就会将扩容至<code>DEFAULT_CAPACITY</code>(10)。</p><p>而<code>EMPTY_ELEMENTDATA</code>是真实空的数组（因为只有传进来的容量为0的时候才会赋该值）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    Object[] a = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = a.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c.getClass() == ArrayList.class) &#123;<br>            elementData = a;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            elementData = Arrays.copyOf(a, size, Object[].class);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、每次调用<code>add</code>函数都会经历一次"扩容"（可能没有真实发生）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>minCapacity</code>：完成add操作的最小扩容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// DEFAULTCAPACITY_EMPTY_ELEMENTDATA 扩容</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity); <span class="hljs-comment">// max(10, minCapacity);</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际进行扩容的函数是<code>grow(int)</code>，经过一系列的判断后通过<code>Arrays.copyOf()</code>进行扩容。</p><p><code>newCapacity</code>：扩容机制指定的扩容量（原容量1.5倍）</p><p><code>MAX_ARRAY_SIZE</code>：最大扩容量（<code>Integer.MAX_VALUE-8</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 新容量为原容量的1.5倍</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>        MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总的来说扩容机制比较简单，主要是存在多个<code>capacity</code>需要比较，需要弄清这些<code>capacity</code>所代表的含义。</p></blockquote><h3 id="几个重要的函数源码">几个重要的函数源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheckForAdd(index);<br><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 使用了System.arraycopy来实现元素的后移</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                     size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>提供给外部的显示扩容函数<code>ensureCapacity</code></p><blockquote><p>注意所有的扩容都出现了<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>（第一次扩容的特殊性）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>        <span class="hljs-comment">// any size if not default element table</span><br>        ? <span class="hljs-number">0</span><br>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>        <span class="hljs-comment">// supposed to be at default size.</span><br>        : DEFAULT_CAPACITY;<br><br>    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发程序设计</title>
      <link href="/2023/02/10/nju-course-review-notes/os/concurrent-programming/"/>
      <url>/2023/02/10/nju-course-review-notes/os/concurrent-programming/</url>
      
        <content type="html"><![CDATA[<h2 id="并发进程">6.1 并发进程</h2><h3 id="并发程序设计的概念">6.1.1 并发程序设计的概念</h3><h4 id="顺序程序设计">顺序程序设计</h4><ul><li>程序执行的内部顺序性：程序在处理器上的执行是严格有序的</li><li>程序执行的外部顺序性：将具体问题的求解过程设计为一个程序或者严格顺序执行的程序序列</li></ul><h4 id="顺序程序设计特性">顺序程序设计特性</h4><ol type="1"><li>程序执行的顺序性</li><li>计算环境的封闭性：独占资源</li><li>计算结果的确定性</li><li>计算过程的可再见性</li></ol><h4 id="进程的并发执行">进程的并发执行</h4><ul><li>多道程序设计允许多个程序同时进入内存竞争处理器</li><li>OS允许多个进程并发执行</li><li>OS保证<u>按照“顺序程序设计”思想编制的程序</u>在并发执行时不受影响，如同独占计算机</li><li><u>按照“顺序程序设计”思想编制的进程</u>在OS中并发执行属于无关的并发进程</li></ul><h4 id="并发程序设计">并发程序设计</h4><p>把一个具体问题求解设计成<strong>若干个可同时执行的程序模块</strong>的方法</p><h4 id="并发程序设计的特性">并发程序设计的特性</h4><ul><li>并发性</li><li>共享性：共享软件资源</li><li>交往性：并发执行时存在制约</li></ul><h3 id="并发进程的制约关系">6.1.2 并发进程的制约关系</h3><p>1、无关与交往的并发进程</p><ul><li><p>无关：分别在不同的变量集合上运行，满足<code>Bernstein</code>条件</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211185046857.png" /></p></li><li><p>交往：共享某些变量</p></li></ul><p>2、与时间有关的错误</p><p>交往的并发进程可能会由于设计不当出现（1）结果错误（2）永远等待</p><p>3、进程互斥与进程同步（竞争与协作）</p><blockquote><p>进程互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调</p></blockquote><ul><li>==进程互斥==：并发进程之间因相互<strong>争夺独占型资源</strong>而产生的竞争制约关系，引发死锁、饥饿问题</li><li>==进程同步==：为完成共同任务<strong>基于某个条件</strong>来协调执行先后关系而产生的协作制约关系</li></ul><h2 id="临界区管理">6.2 临界区管理</h2><h3 id="临界区">6.2.1 临界区</h3><ul><li>临界资源：互斥共享变量所代表的资源（一次只能被一个进程所使用）</li><li>临界区（criticalsection）：<u>并发进程中与互斥共享变量相关的<strong>程序段</strong></u></li><li>临界区管理的三个要求<ul><li>一次至多允许一个进程停留在临界区</li><li>不能无限停留在临界区</li><li>不能无限等待进入临界区</li></ul></li></ul><h3 id="临界区管理软件方法">6.2.2 临界区管理——软件方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">P1:<br><span class="hljs-keyword">while</span> flag2 &#123;&#125; <span class="hljs-comment">// 语句1</span><br>flag1 = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 语句2</span><br><span class="hljs-comment">// 临界区</span><br>flag1 = <span class="hljs-literal">false</span>;<br><br>P2:<br><span class="hljs-keyword">while</span> flag1 &#123;&#125;<br>flag2 = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 临界区</span><br>flag2 = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>语句1和语句2可以交换顺序，但是都是不可行的，本质是因为语句1和语句2是可以被中断的，就会导致同时进入或者同时等待</p><h4 id="dekker算法">Dekker算法</h4><blockquote><p><ahref="https://blog.csdn.net/Wang_Dou_Dou_/article/details/120467157">进程联系与临界区管理</a></p></blockquote><h4 id="peterson算法">Peterson算法</h4><blockquote><p>P0和P1使用临界区的次序变成了完全1:1的交替方式，并不符合临界区互斥使用的完全随机性</p></blockquote><h3 id="临界区管理硬件方法">6.2.3 临界区管理——硬件方法</h3><h4 id="ts指令">TS指令</h4><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230203114203042.png" /></p><h4 id="swap指令">SWAP指令</h4><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230203114232770.png" /></p><h4 id="开关中断">开关中断</h4><ul><li>TS和SWAP指令均为忙等式，效率低</li><li>【关中断】；【临界区】；【开中断】</li><li>不便交给用户进程使用（防止滥用）</li></ul><h2 id="pv操作">6.3 PV操作</h2><h3 id="pv操作与进程互斥">6.3.1 PV操作与进程互斥</h3><p>==信号量==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-type">int</span> value; <span class="hljs-comment">// 信号量值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcb</span>* <span class="hljs-title">list</span>;</span> <span class="hljs-comment">// 等待信号量的进程队列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>==PV操作==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">P(semaphore s)&#123;<br>    s -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>) W(s); <span class="hljs-comment">// 将进程加入等待队列</span><br>&#125;<br><br>V(semaphore s)&#123;<br>    s += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s &lt;= <span class="hljs-number">0</span>) R(s); <span class="hljs-comment">// 从等待队列中释放一个进程</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pv操作与进程同步生产者消费者问题">6.3.2PV操作与进程同步（生产者消费者问题）</h3><h4 id="消费者1生产者1缓冲区">1消费者1生产者1缓冲区</h4><p>需要两个信号量：1、生产者的空位；2、消费者的产品</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230203141237328.png" /></p><h4 id="消费者1生产者n缓冲区">1消费者1生产者N缓冲区</h4><p>需要为消费者和生产者增加两个指针</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230203141604601.png" /></p><h4 id="n消费者n生产者n缓冲区">N消费者N生产者N缓冲区</h4><p>需要增加两个信号量：N个消费者互斥使用getptr；N个生产者互斥使用putptr；</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230203141653802.png" /></p><h2 id="管程">6.4 管程</h2><h3 id="为什么要引入管程">为什么要引入管程?</h3><ul><li>把分散在各进程中的临界区集中起来进行管理</li><li>防止进程有意或无意的违法同步操作</li><li>便于用高级语言来书写程序</li></ul><h3 id="管程-1">管程</h3><p>管程是由<u>局部于自己的若干公共变量及其说明</u>和<u>所有访问这些公共变量的过程</u>所组成的软件模块。</p><ul><li>条件变量：用于阻塞进程的信号量</li><li>同步原语wait：阻塞进程</li><li>同步原语signal：释放进程</li></ul><blockquote><p>signal操作存在一个问题：<strong>会导致释放进程和被释放进程同时存在于管程中</strong></p><p>霍尔管程：<strong>执行signal进程等待，直到被释放进程退出管程或等待另一个条件</strong></p></blockquote><h3 id="霍尔管程">霍尔管程</h3><blockquote><p>霍尔管程基于PV操作原语实现，wait和signal可以是<u>程序过程</u>；可以使用语言机制实现霍尔管程。</p><p>不要求signal操作是过程题的最后一个操作，且wait和signal可以被中断</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 霍尔管程中的信号量</span><br>mutex; <span class="hljs-comment">// 调用管程过程的互斥信号量</span><br>next; <span class="hljs-comment">// 发出signal操作的进程挂起自己的信号量</span><br>next_count; <span class="hljs-comment">// 在next上等待的信号量</span><br><br><span class="hljs-comment">// 霍尔管程中的条件变量</span><br>x_sem; <span class="hljs-comment">// 与资源相关的信号量</span><br>x_count; <span class="hljs-comment">// 在x_sem上等待的进程数</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">procedure <span class="hljs-title function_">wait</span><span class="hljs-params">(var x_sem : semaphore, var x_count : integer, var IM)</span>&#123;<br>    x_count += <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 如果有在next上等待的进程，先释放在next上等待的进程</span><br>    <span class="hljs-comment">// 如果没有就释放等待进入管程的进程</span><br>    <span class="hljs-keyword">if</span> IM.next_count &gt; <span class="hljs-number">0</span> then V(IM.next) <span class="hljs-keyword">else</span> V(IM.mutex)<br>    P(x_sem)<br>    x_count -= <span class="hljs-number">1</span><br>&#125;<br><br>procedure signal(var x_sem : semaphore, var x_count : integer, var IM)&#123;<br><span class="hljs-keyword">if</span> x_count &gt; <span class="hljs-number">0</span> then<br>IM.next_count += <span class="hljs-number">1</span><br>V(x_sem)<br>P(IM.next) <span class="hljs-comment">// 执行signal操作的进程阻塞自己</span><br>IM.next_count -= <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">enter</span><span class="hljs-params">(InterfaceModule &amp;IM)</span>&#123;<br>    P(IM.mutex);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">leave</span><span class="hljs-params">(InterfaceModule &amp;IM)</span>&#123;<br>    <span class="hljs-keyword">if</span> (IM.next_count &gt; <span class="hljs-number">0</span>)<br>        V(IM.next);<br>    <span class="hljs-keyword">else</span> <br>        V(IM.mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哲学家问题">哲学家问题</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230205100248377.png" /></p><ul><li>等待叉子的方案：可能会产生死锁（先拿一个再拿一个）</li><li>等待盘子的方案：一次拿两个叉子</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230205102006154.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">process <span class="hljs-title function_">philosopher_i</span><span class="hljs-params">()</span>&#123;<br>    L: thinking();<br>    <span class="hljs-comment">// 进入管程的队列</span><br>    P(IM.mutex);<br>    dining_philosopers.pickup(i);<br>    <span class="hljs-keyword">if</span> IM.next_count &gt; <span class="hljs-number">0</span> then <span class="hljs-title function_">V</span><span class="hljs-params">(IM.next)</span>; <span class="hljs-keyword">else</span> V(IM.mutex);<br>    <br>    eating();<br>    <br>    P(IM.mutex);<br>    dining_philosophers.putdown();<br>    <span class="hljs-keyword">if</span> IM.next_count &gt; <span class="hljs-number">0</span> then <span class="hljs-title function_">V</span><span class="hljs-params">(IM.next)</span>; <span class="hljs-keyword">else</span> V(IM.mutex);<br>    <br>    <span class="hljs-keyword">goto</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读者写者问题">读者写者问题</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230205101343780.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230205101917064.png" /></p><h3 id="生产者消费者问题">生产者消费者问题</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211194335363.png" /></p><h3 id="苹果橘子问题">苹果橘子问题</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230211195116094.png" /></p><h2 id="进程通信">6.5 进程通信</h2><h3 id="进程通信-1">6.5.1 进程通信</h3><ul><li>交往进程通过信号量操作实现进程互斥和同步，这是一种低级通信方式</li><li>进程有时还需要交换更多的信息，可以引进高级通信方式——进程通信机制，实现进程间用==信件==来交换信息</li><li>进程通信扩充了并发进程的数据共享、</li><li>进程直接通信<ul><li>发送或接收信件的进程指出信件发给谁或从谁那里接收信件</li><li><code>send(P, 信件)</code>：把信件发送给进程P</li><li><code>receive(Q, 信件)</code>：从进程Q接收信件</li></ul></li><li>进程间接通信<ul><li>发送或者接收信件通过一个信箱来进行，该信箱有唯一标识符</li><li>多个进程共享一个信箱<ul><li><code>send(A, 信件)</code>：把信件发送给信箱A</li><li><code>receive(A, 信件)</code>：从信箱A接收信件</li></ul></li><li>信箱可以分成信箱特征和信箱体两部分<ul><li>信箱特征：指出信箱容量、信件格式、指针等</li><li>信箱体用来存放信件，分成若干个区，每个区容纳一封信</li></ul></li></ul></li><li>发送信件原语处理流程<ul><li>指定的信箱未满=》把信件送入信箱中指针所指示位置，释放等待该信箱中指针的等待者</li><li>否则=》发送信件者被置成<strong>等待信箱</strong>的状态</li></ul></li><li>接收信件原语处理流程<ul><li>指定信箱有信件=》取出一封信件，释放等待信箱的等待者</li><li>否则=》接收信件者被置成<strong>等待信箱中信件</strong>的状态</li></ul></li></ul><h3 id="高级进程通信机制">6.5.2 高级进程通信机制</h3><ul><li>基于字节流的进程信息规约</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230207153352490.png" /></p><ul><li>基于RPC（远程过程调用）/XDR（外部数据表示）的高级通信规约</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230207153541833.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230213141912210.png" /></p><h2 id="死锁">6.6 死锁</h2><h3 id="死锁的产生">6.6.1 死锁的产生</h3><ul><li>==死锁==：一组进程处于死锁状态是指：每一个进程都在等待被另一个进程所占有的、不能抢占的资源。</li><li>死锁的产生不仅与系统拥有的<u>资源数量</u>相关，而且与<u>资源分配策略</u>，<u>进程对资源的使用要求</u>以及<u>并发进程的推进顺序</u>有关</li><li>产生死锁的4个必要条件：<ol type="1"><li>==互斥条件==：进程应互斥使用资源，任一时刻一个资源仅为一个进程独占</li><li>==占有和等待条件==：一个进程请求不到资源得不到满足而等待时，不释放已占有的资源</li><li>==不剥夺条件==：任一进程不能从另一进程那里抢夺资源</li><li>==循环等待条件==：存在一个循环等待链，每一个进程分别等待它前一个进程所持有的资源</li></ol></li></ul><h3 id="死锁的防止">6.6.2 死锁的防止</h3><blockquote><p>破坏产生死锁的四个必要条件之一，就可以防止死锁</p></blockquote><ol type="1"><li>互斥条件：将独占型资源改成共享性资源，使资源可以同时访问而不是互斥使用<ul><li>部分资源是天生具有互斥性，不能被同时访问</li></ul></li><li>占有和等待条件：<strong>静态分配</strong>。一个进程必须在执行前就申请它所要的全部资源，并且直到它所要的资源都得到满足之后才开始执行<ul><li>实现简单，但是会严重降低操作系统资源利用率</li></ul></li><li>不剥夺条件：采用剥夺式调度方法</li><li>循环等待条件：<strong>层次分配</strong>，动态分配。资源被分成多个层次（排序）；<ul><li>一个进程得到某一层的一个资源后，只能再申请在较高层的资源；</li><li>一个进程要释放某一层的一个资源，必须先释放所占用的较高层的资源；</li><li>对于同一层的资源，只能一个一个地占有。</li></ul></li></ol><h3 id="死锁的避免">6.6.3 死锁的避免</h3><blockquote><p>在为申请者分配资源前先测试系统状态，若把资源分配给申请者会产生死锁的话，则拒绝分配，否则接受申请，分配资源</p></blockquote><p>==银行家算法==：检查申请者对资源的最大需求量，如果现存的资源可以满足它的最大需求量就允许当前的申请。</p><ul><li>给定四个集合：<spanclass="math inline">\(R、V、C、A\)</span>，分别表示资源总数、当前可用资源总数、进程声称需要的最大资源数、已经分配给进程的资源数</li><li>如果可以找到一个进程序列，按照该进程序列去分配资源，可以满足所有资源的需要，则称系统处于安全性状态</li></ul><h3 id="死锁的检测">6.6.4 死锁的检测</h3><blockquote><p>定时运行一个”死锁检测“程序，判断系统内是否已出现死锁，若检测到死锁则设法加以解除</p></blockquote><ul><li>建立两张表：等待资源表和占用资源表</li><li>列出所有的”等待占用关系“</li><li>用Warshall传递闭包算法检测是否有死锁发生</li><li>解决方法（死锁是一个小概率事件）<ul><li>重新执行</li><li>设置 <strong>校验点</strong>，回退到校验点开始执行</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> nju-course-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab7 networking</title>
      <link href="/2023/02/02/6.S081/6.S081-lab7-net/"/>
      <url>/2023/02/02/6.S081/6.S081-lab7-net/</url>
      
        <content type="html"><![CDATA[<h2 id="背景要求">1 背景要求</h2><ul><li><p>使用一个网络设备E1000来处理网络通信。</p></li><li><p>在模拟的LAN下，xv6的IP地址为<code>10.0.2.15</code>，主机的IP地址为<code>10.0.2.2</code></p></li><li><p>当xv6使用E1000发生一个报文到<code>10.0.2.2</code>，qemu会将该报文传递给真实主机的正确应用</p></li><li><p>要使用QEMU的<ahref="https://wiki.qemu.org/Documentation/Networking#User_Networking_.28SLIRP.29"><code>user-mode network stack</code></a></p></li><li><p>所有的来往packets都记录在<code>packets.pcap</code>文件中</p></li><li><p><code>kernel/e1000.c</code>包含了初始化代码以及发送和接收packets的空函数</p></li><li><p><code>kernel/e1000_dev.h</code>包含了<ahref="https://pdos.csail.mit.edu/6.828/2021/readings/8254x_GBe_SDM.pdf">寄存器和标志位的定义</a></p></li><li><p><code>kernel/net.c</code>和<code>kernel/net.h</code>包含了一个简单的网络栈，实现了IP、UDP、ARP协议；还包含了一个存放packet的数据结构<code>mbuf</code></p></li><li><p><code>kernel/pci.c</code>包含了在xv6启动时在PCI总线上搜索E1000网卡的代码</p></li><li><p>实现<code>e1000_transmit()</code>和<code>e1000_recv()</code>，使得驱动程序可以传输和接收packet</p></li><li><p><code>e1000_init()</code>函数配置E1000从RAM读取packet并将接收到的packet写进RAM（DMA方式）</p></li><li><p>由于packets突发到达的速度可能比驱动程序处理他们的速度更快，<code>e1000_init()</code>提供了多个buffer给E1000去写packets</p></li><li><p>E1000要求这些buffers由RAM中的描述符数组来描述，每个描述符包含了RAM的一个地址，E1000可以在其中写入接收到的packet</p></li><li><p><code>struct rx_desc</code>描述了描述符的格式，描述符的数组被称为接收循环队列</p></li><li><p><code>e1000_init()</code>使用<code>mbufalloc()</code>将E1000的<code>mbuf</code>数据包缓冲区分配到DMA中</p></li><li><p>还有一个传输循环队列用来存放需要发送的packet</p></li><li><p>这个两个循环队列的大小为<code>RX_RING_SIZE</code>和<code>TX_RING_SIZE</code></p></li><li><p>当<code>net.c</code>中的网络栈需要发送一个packet时，会调用<code>e1000_transmit()</code>带有一个存放了需要发送的packet的<code>mbuf</code>。</p></li></ul><p>完成 <code>e1000_transmit</code>：</p><ul><li>TDT寄存器：存放了传输描述符循环缓冲区的末尾指针，是一个偏移量。</li></ul><h2 id="实现">2 实现</h2><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230316235026877.png" /></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230316235343584.png"alt="Transmit Descriptor Ring Structure" /><figcaption aria-hidden="true">Transmit Descriptor RingStructure</figcaption></figure><ul><li>白色部分是由硬件管理的；灰色部分是由软件管理的，表示的是已经发送还未被回收的packet</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">e1000_transmit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mbuf *m)</span><br>&#123;<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// the mbuf contains an ethernet frame; program it into</span><br>  <span class="hljs-comment">// the TX descriptor ring so that the e1000 sends it. Stash</span><br>  <span class="hljs-comment">// a pointer so that it can be freed after sending.</span><br>  <span class="hljs-comment">//</span><br><br>  <span class="hljs-comment">// 1.acquire the lock</span><br>  acquire(&amp;e1000_lock);<br>  <span class="hljs-comment">// 2.reading the E1000_TDT control register =&gt; get the tail index of the tx ring</span><br>  uint32 tx_desc_tail_idx = regs[E1000_TDT];<br>  <span class="hljs-comment">// 3.check if the ring overflowing...</span><br>  <span class="hljs-keyword">if</span> ((tx_ring[tx_desc_tail_idx].status &amp; E1000_TXD_STAT_DD) == <span class="hljs-number">0</span>) &#123;<br>    release(&amp;e1000_lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// hasn&#x27;t finish last transmition</span><br>  &#125;<br>  <span class="hljs-comment">// 4. free the mbuf if needed</span><br>  <span class="hljs-keyword">if</span> (tx_mbufs[tx_desc_tail_idx]) &#123;<br>    mbuffree(tx_mbufs[tx_desc_tail_idx]);<br>  &#125;<br>  <span class="hljs-comment">// 5. fill the descriptor</span><br>  tx_mbufs[tx_desc_tail_idx] = m;<br>  tx_ring[tx_desc_tail_idx].length = m-&gt;len;<br>  tx_ring[tx_desc_tail_idx].addr = (uint64)m-&gt;head;<br>  tx_ring[tx_desc_tail_idx].cmd = (E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS); <span class="hljs-comment">// set the cmd flags</span><br>  <span class="hljs-comment">// 6. update the tail pointer</span><br>  regs[E1000_TDT] = (tx_desc_tail_idx + <span class="hljs-number">1</span>) % TX_RING_SIZE;<br>  <span class="hljs-comment">// 7.release the lock</span><br>  release(&amp;e1000_lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230316235048924.png" /></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230316235439080.png"alt="Receive Descriptor Ring Structure" /><figcaption aria-hidden="true">Receive Descriptor RingStructure</figcaption></figure><ul><li>白色部分是由硬件管理的；灰色部分是由软件管理的，表示被硬件接收但是还未被软件识别处理的packet</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">e1000_recv</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Check for packets that have arrived from the e1000</span><br>  <span class="hljs-comment">// Create and deliver an mbuf for each packet (using net_rx()).</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 1. acquire the lock</span><br>    <span class="hljs-comment">// acquire(&amp;e1000_lock);</span><br>    <span class="hljs-comment">// 2. get the position of the next received packet</span><br>    uint32 next_packet_idx = (regs[E1000_RDT] + <span class="hljs-number">1</span>) % RX_RING_SIZE;<br>    <span class="hljs-comment">// 3. check if new packet available</span><br>    <span class="hljs-keyword">if</span> ((rx_ring[next_packet_idx].status &amp; E1000_RXD_STAT_DD) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// release(&amp;e1000_lock);</span><br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// no available packet</span><br>    &#125;<br>    <span class="hljs-comment">// 4. set the length and deliver the packet to the networking stack</span><br>    rx_mbufs[next_packet_idx]-&gt;len = rx_ring[next_packet_idx].length;<br>    net_rx(rx_mbufs[next_packet_idx]);<br>    <span class="hljs-comment">// 5. refresh the mbuf</span><br>    <span class="hljs-keyword">if</span> ((rx_mbufs[next_packet_idx] = mbufalloc(<span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;e1000_recv&quot;</span>);<br>    <span class="hljs-comment">// 6. refresh the metadata in rx_ring</span><br>    rx_ring[next_packet_idx].addr = (uint64) rx_mbufs[next_packet_idx]-&gt;head;<br>    rx_ring[next_packet_idx].status &amp;= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 7. update the E1000_RDT</span><br>    regs[E1000_RDT] = next_packet_idx;<br>    <span class="hljs-comment">// 8. release the lock</span><br>    <span class="hljs-comment">// release(&amp;e1000_lock);</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意<code>e1000_recv</code>不需要获取锁，因为该函数是在处理中断时被调用的，应该已经在之前就获得过锁了。</p></blockquote><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230304194643726.png"alt="测试结果" /><figcaption aria-hidden="true">测试结果</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 6.S081-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab5 Copy-on-Write</title>
      <link href="/2023/01/31/6.S081/6.S081-lab5-cow/"/>
      <url>/2023/01/31/6.S081/6.S081-lab5-cow/</url>
      
        <content type="html"><![CDATA[<h2 id="cow机制介绍">COW机制介绍</h2><p>COW的机制其实非常简单，核心思想还是将内存的分配推迟：在<code>fork()</code>的时候只是将子进程的虚拟页映射到父进程的物理内存上；当之后发生了实际的写内存操作引发<code>page fault</code>后，再进行实际的内存分配。</p><h2 id="cow实现">COW实现</h2><blockquote><p>尽管COW的机制非常简单，实现起来也看似简单，但是非常易错，且调试难度也比较大（多核并发）</p><p>具体代码见：<ahref="https://github.com/zhc-njdx/6.S081-Labs/tree/cow">cow lab</a></p></blockquote><p>实现过程基本上参考手册的那几步就行：</p><p>1、修改 <code>uvmcopy()</code>函数，将<code>parent</code>的物理页映射到<code>child</code>的页表中，而不是分配新的物理页，并且清空<code>PTE_W</code>标志，设置<code>cow page</code>的标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// uvmcopy for cow fork</span><br><span class="hljs-comment">// it maps the parent&#x27;s physical pages into the child</span><br><span class="hljs-comment">// instead of allocating the new pages</span><br><span class="hljs-comment">// and clear the PTE_W flag and set the cow page sign</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>    pa = PTE2PA(*pte);<br>    flags = PTE_FLAGS(*pte);<br><br>    flags = (flags &amp; (~PTE_W)) | PTE_COW; <span class="hljs-comment">// clear the PTE_W and set the cow sign</span><br>    *pte = PA2PTE(pa) | flags; <span class="hljs-comment">// update the parent&#x27;s pte flags</span><br><br>    <span class="hljs-keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="hljs-number">0</span>)&#123;<br>      panic(<span class="hljs-string">&quot;uvmcopy: can&#x27;t map the parent&#x27;s physical pages into child.&quot;</span>);<br>      <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>    add_refcount(PGROUNDDOWN(pa));<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  err:<br>    uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在<code>usertrap()</code>中识别<code>page fault</code>，并进行相应的处理。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230131231225955.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scause == <span class="hljs-number">15</span> || scause == <span class="hljs-number">12</span>)&#123;<br>    <span class="hljs-comment">// page fault</span><br>    uint64 va = r_stval(); <span class="hljs-comment">// error va</span><br>    <span class="hljs-keyword">if</span> (cowcopy(p-&gt;pagetable, va) != <span class="hljs-number">0</span>) &#123;<br>      p-&gt;killed = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125; <br>...<br></code></pre></td></tr></table></figure><p><strong>3、对物理页设置引用计数机制</strong></p><blockquote><p>这一部分应该是最难的一块，需要考虑并发加锁。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>  uint8 page_references[(PHYSTOP-KERNBASE)/PGSIZE];<br>&#125; kmem;<br></code></pre></td></tr></table></figure><p>4、修改<code>copyout</code>，机制和处理<code>page fault</code>一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>va0 = PGROUNDDOWN(dstva);<br><br>   <span class="hljs-keyword">if</span> (cowcopy(pagetable, va0) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>   pa0 = walkaddr(pagetable, va0);<br>...<br></code></pre></td></tr></table></figure><h2 id="错误汇总">错误汇总</h2><p>1、报错 remap</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230201113935903.png" /></p><blockquote><p>原因是在建立新的映射之前，要先将原来的映射取消掉；</p></blockquote><p><strong>2、scause = 2 非法指令</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230201124453515.png" /></p><blockquote><p>思考排错的过程：</p><p>初步猜测是：在用户空间使用内核指令？</p><p>根据backtrace出错的位置：在用户空间是 <code>cowtest</code> 中的<code>simpletest</code>，在<code>wait(0)</code>后面的<code>print</code>语句引发了错误；在内核空间是<code>r_scause()</code> 引发了错误</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230202162913328.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230202163324569.png" /></p><p><strong>可能是地址空间出现错误！</strong>需要严格检查地址是否越界等！</p><p>但是 该错误一直没有得到解决</p></blockquote><p><font color='red'>经过长时间的debug，发现出现错误的原因是没有正确地实现引用计数机制，出现了并发的错误。</font>本来在实现的过程中，是想实现一点测试一点的，以为实现好了基本的功能应该能跑过简单测试，所以在排错的时候一直没有考虑是引用计数的问题！</p><p><strong>3、减少引用计数的位置</strong></p><p>在修改引用计数机制的时候，我是希望将引用的更新作为一个函数，然后当更新后的引用为<code>0</code>的时候再调用<code>kfree</code>释放物理内存，这个时候就会出现一个问题：这样实现相当于在<code>kfree</code>的前面加了一层引用更新函数，在<code>cow page</code>的相关实现中是可以正确调度内存的释放，但是系统的其他地方会有直接调用kfree的情况，就会导致即使该内存页的引用不为0该内存页还是被释放了的情况，所以减少引用计数的位置应该在<code>kfree</code>中。</p><h2 id="结果">结果</h2><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230210104747576.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 6.S081-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能Go语言发行版优化与落地实践</title>
      <link href="/2023/01/19/Go/Memory-Management/"/>
      <url>/2023/01/19/Go/Memory-Management/</url>
      
        <content type="html"><![CDATA[<h2 id="性能优化">性能优化</h2><h3 id="概述">概述</h3><ul><li>什么是性能优化：提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力</li><li>为什么要做性能优化<ul><li>用户体验：带来用户体验的提升</li><li>资源高效利用：降低成本，提高效率</li></ul></li></ul><h3 id="性能优化的层面">性能优化的层面</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119075809089.png" /></p><h3 id="性能优化的可维护性">性能优化的可维护性</h3><ul><li>保证接口稳定的前提下改进具体实现</li><li>测试用例：覆盖尽可能多的场景，方便回归</li><li>文档：做了什么，没做什么，能达到怎样的效果</li><li>隔离：通过选项控制是否开启优化</li><li>可观测：必要的日志输出</li></ul><h2 id="自动内存管理">自动内存管理</h2><h3 id="概念">概念</h3><ul><li><p>动态内存</p><ul><li>程序在运行时根据需求动态分配内存：<code>malloc()</code></li></ul></li><li><p>自动内存管理（垃圾回收）：有程序语言的运行时系统管理动态内存</p><ul><li>避免手动内存管理，专注于实现业务逻辑</li><li>保证内存使用的正确性和安全性：<code>double-free</code>、<code>use-after-free</code></li></ul></li><li><p>三个任务</p><ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul></li><li><p>相关概念</p><ul><li><p><code>Mutator</code>：业务线程，分配新对象，修改对象指向关系</p></li><li><p><code>Collector</code>：<code>GC</code>线程，找到存活对象，回收死亡对象的内存空间</p></li><li><p><code>Serial GC</code>：只有一个<code>collector</code></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119080759828.png" /></p></li><li><p><code>Parallel GC</code>：支持多个<code>collectors</code>同时回收的<code>GC</code>算法</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119080851305.png" /></p></li><li><p><code>Concurrent GC</code>：<code>mutator</code>和<code>collector</code>可以同时执行</p><ul><li><strong><code>collectors</code>必须感知对象指向关系的改变</strong></li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119080911240.png" /></p></li></ul></li><li><p>评价<code>GC</code>算法</p><ul><li>安全性：不能回收存活对象</li><li>吞吐率：花在<code>GC</code>上的时间</li><li>暂停时间：<code>stop the world</code> 业务是否感知</li><li>内存开销：<code>GC</code>元数据开销</li></ul></li></ul><h3 id="tracing-gc">Tracing GC</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119081945860.png" /></p><ul><li><p>对象被回收的条件：指针指向关系不可达的对象</p></li><li><p>标记跟对象</p><ul><li>静态变量、全局变量、常量、线程栈</li></ul></li><li><p>标记：找到可达对象</p><ul><li>求指针指向关系的传递闭包：从根对象出发，找到所有可达对象</li></ul></li><li><p>清理：所有不可达对象</p><ul><li><p>将存活对象复制到另外的内存空间（<code>Copying GC</code>）</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119081533782.png" /></p></li><li><p>将死亡对象的内存标记为“可分配”（<code>Mark-sweep GC</code>）</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119081739822.png" /></p></li><li><p>移动并整理存活对象（<code>Mark-compact GC</code>）</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119081843993.png" /></p></li></ul></li><li><p><strong>根据对象的生命周期，使用不同的标记和清理策略</strong></p></li></ul><h3 id="generational-gc">Generational GC</h3><ul><li>分代假说：<code>most objects die young</code></li><li><code>Intuition</code>：很多对象在分配出来后很快就不再使用了</li><li>每个对象都有年龄：经历<code>GC</code>的次数</li><li>目的：对于年轻和老年的对象，制定不同的<code>GC</code>策略，<strong>降低整体内存管理的开销</strong></li><li>不同年龄的对象处于<code>heap</code>的不同区域</li><li>年轻代（<code>Yong Generation</code>）<ul><li>常规的对象分配</li><li>由于存活对象很少（基于假说），可以采用<code>copying collection</code></li><li><code>GC</code>吞吐率高</li></ul></li><li>老年代（<code>Old Generation</code>）<ul><li>对象趋向于一直活着，反复复制开销较大</li><li>可以采用<code>mark-sweep collection</code></li></ul></li></ul><h3 id="reference-counting">Reference Counting</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119083041067.png" /></p><ul><li><p>每个对象都有一个与之关联的引用数目</p></li><li><p>存活条件：当且仅当引用数&gt;0</p></li><li><p>优点</p><ul><li>内存管理操作被平摊到程序执行过程中</li><li>内存管理不需要了解<code>runtime</code>的实现细节：<code>C++</code>智能指针（<code>smart pointer</code>）</li></ul></li><li><p>缺点</p><ul><li>维护引用计输的开销较大：通过<strong>原子操作</strong>保证对引用计数操作的<strong>原子性</strong>和<strong>可见性</strong>（多线程）</li><li>无法回收环形数据结构——<code>weak reference</code></li><li>内存开销：每个对象都引入额外内存空间存储引用数目</li><li>回收内存时依赖可能引发暂停：如果需要回收大量对象</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119083113960.png" /></p></li></ul><h2 id="go内存管理及优化">Go内存管理及优化</h2><h3 id="go内存分配">Go内存分配</h3><h4 id="分块">分块</h4><ul><li>目标：为对象在<code>heap</code>上分配内存</li><li>提前将内存分块<ul><li>调用系统调用<code>mmap</code>向<code>OS</code>申请一大块内存，例如<code>4MB</code></li><li>先将内存划分成大块，例如<code>8KB</code>，称作<code>mspan</code></li><li>再将大块继续划分成特定大小的小块，用于对象分配</li><li><code>noscan mspan</code>：分配不包含指针的对象——<code>GC</code>不需要扫描</li><li><code>scan mspan</code>：分配包含指针的对象——<code>GC</code>需要扫描</li></ul></li><li>对象分配：根据对象的大小，选择最合适的块返回</li></ul><h4 id="缓存">缓存</h4><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119093459144.png" /></p><ul><li>借鉴了<code>TCMalloc</code>的思想：<code>thread caching</code></li><li>每一个<code>p</code>包含一个<code>mcache</code>用于快速分配，用于为绑定于p上的g分配对象</li><li><code>mcache</code>管理一组<code>mspan</code></li><li>当<code>mcache</code>中的<code>mspan</code>分配完毕，再向<code>mcentral</code>申请带有未分配块的<code>mspan</code></li><li>当<code>mspan</code>中没有分配的对象，<strong><code>mspan</code>会被缓存在<code>mcentral</code>中，而不是立刻释放并归还给<code>OS</code></strong></li></ul><blockquote><p>当需要为对象分配空间时，首先会在<code>mcache</code>中寻找是否存在空闲的合适的内存块，有则返回指针；无则向下一层<code>mcentral</code>寻找内存块。</p></blockquote><h3 id="go内存管理优化">Go内存管理优化</h3><ul><li>对象分配是非常高频的操作：<strong>每秒分配<code>GB</code>级别的内存</strong></li><li>小对象占比较高</li><li><code>Go</code>内存分配比较耗时<ul><li>分配路径长：<code>g -&gt; m -&gt; p -&gt; mcache -&gt; mspan -&gt; memory block -&gt; return pointer</code></li><li><code>pprof</code>：对象分配的函数时最频繁调用的函数之一</li></ul></li></ul><h3 id="balanced-gc">Balanced GC</h3><ul><li><p>每个<code>g</code>都绑定一大块内存（<code>1KB</code>），称作<code>goroutine allocation buffer</code>(<code>GAB</code>)</p></li><li><p><code>GAB</code>用于<code>noscan</code>类型的小对象分配：&lt;128B</p></li><li><p>使用3个指针维护<code>GAB</code>：<code>base</code>、<code>end</code>、<code>top</code></p></li><li><p><code>Bump pointer</code>（指针碰撞）风格对象分配</p><ul><li>无须和其他分配请求互斥（每个<code>g</code>都绑定内存）</li><li>分配动作简单高效</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> top + size &lt;= end &#123;<br>    addr := top<br>    top += size <br>    <span class="hljs-keyword">return</span> addr<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>GAB</code>对于<code>Go</code>内存管理来说是一个小对象</p></li><li><p>本质：<strong>将多个小对象的分配合并成一次大对象的分配</strong></p></li><li><p>问题：<code>GAB</code>的对象分配方式会导致内存被延迟释放。</p></li></ul><blockquote><p><code>GAB</code>的分配还是要走之前那条很长的分配路径的，对于<code>GC</code>来说，一整个<code>GAB</code>才是一个对象。所以，当<code>GAB</code>中存在某一个小对象存活时，<code>GC</code>会将整个<code>GAB</code>标识为存活。</p></blockquote><ul><li>方案：移动<code>GAB</code>中存活的对象<ul><li><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119101254147.png" /></li><li>当<code>GAB</code>总大小超过一定阈值时，将<code>GAB</code>中存活对象复制到另外分配的<code>GAB</code>中</li><li>原先的<code>GAB</code>可以释放，避免内存释放</li><li>本质：<strong>用<code>copying GC</code>的算法管理小对象</strong></li></ul></li></ul><h2 id="编译器和静态分析">编译器和静态分析</h2><h3 id="基本介绍">基本介绍</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119101410988.png" /></p><h3 id="数据流和控制流">数据流和控制流</h3><ul><li>静态分析：不执行程序代码，推导程序的行为，分析程序的性质</li><li>控制流：程序执行的流程 =&gt; 控制流图</li><li>数据流：数据在控制流上的传递</li><li>通过分析控制流和数据流，我们可以知道更多关于程序的性质，根据这些性质优化代码</li></ul><h3 id="过程内和过程分析">过程内和过程分析</h3><ul><li>过程内分析（<code>Intra-procedural analysis</code>）<ul><li>仅在函数内部进行分析</li></ul></li><li>过程间分析（<code>Inter-procedural analysis</code>）<ul><li>考虑过程调用时参数传递和返回值的数据流和控制流</li></ul></li><li>为什么过程分析是一个问题？<ul><li><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230119102344793.png" /></li><li>需要通过数据流分析得知i的具体类型，才能知道<code>i.foo()</code>调用的是哪个<code>foo()</code></li><li>根据<code>i</code>的具体类型，产生了新的控制流，<code>A.foo()</code>，分析继续</li><li>过程间分析需要同时分析控制流和数据流——联合求解，比较复杂</li></ul></li></ul><h2 id="go编译器优化">Go编译器优化</h2><h3 id="背景">背景</h3><ul><li>为什么要做编译器优化<ul><li>用户无感知，重新编译即可获得性能收益</li><li>通用性优化</li></ul></li><li>现状<ul><li>采用的优化少</li><li>编译时间较短，没有进行较复杂的代码分析和优化</li></ul></li><li>编译优化的思路<ul><li>场景：面向后端长期执行任务</li><li><code>Tradeoff</code>：<strong>用编译时间换取更高效的机器码</strong></li></ul></li><li><code>Beast mode</code>（编译优化产品）<ul><li><strong>函数内联</strong></li><li><strong>逃逸分析</strong></li><li>默认栈大小调整</li><li>边界检查消除</li><li>循环展开</li><li>...</li></ul></li></ul><h3 id="函数内联">函数内联</h3><ul><li>内联：将被调用函数的函数体（<code>callee</code>）的副本替换到调用位置（<code>caller</code>）上，同时重写代码以反映参数的绑定</li><li>优点<ul><li><strong>消除函数调用开销</strong>，例如传递参数、保存寄存器等</li><li><strong>将过程间分析转化为过程内分析</strong>，帮助其他优化，例如逃逸分析</li></ul></li><li>缺点<ul><li>函数体变大，<code>instruction cache</code>不友好，命中率降低</li><li>编译生成的<code>Go</code>镜像变大</li></ul></li><li>函数内联在大多数情况下是正向优化</li><li>内联策略<ul><li>调用和被调函数的规模...</li></ul></li></ul><h3 id="逃逸分析">逃逸分析</h3><ul><li>逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问</li><li>大致思路<ul><li>从对象分配处出发，沿着控制流，观察对象的数据流</li><li>若发现指针<code>p</code>在当前作用域<code>s</code>：<ul><li>作为参数传递给其他函数</li><li>传递给全局变量</li><li>传递给其他的<code>goroutine</code></li><li>传递给已逃逸的指针指向的对象</li></ul></li><li>则指针p指向的对象逃逸出<code>s</code>，反之则没有逃逸出<code>s</code></li></ul></li><li><code>Beast Mode</code>：函数内联拓展了函数的边界，更多对象不逃逸</li><li>优化：为逃逸的对象可以在<strong>栈上分配</strong><ul><li>对象在栈上分配和回收很快：移动<code>sp</code></li><li>减少在<code>heap</code>上的分配，降低<code>GC</code>负担</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go高质量编程与性能调优</title>
      <link href="/2023/01/17/Go/high-quailty-programming-and-performance-tuning/"/>
      <url>/2023/01/17/Go/high-quailty-programming-and-performance-tuning/</url>
      
        <content type="html"><![CDATA[<h1 id="高质量编程">高质量编程</h1><h2 id="高质量编程简介">高质量编程简介</h2><blockquote><p>编写的代码能够达到正确可靠、简介清晰的目标可称之为高质量代码</p></blockquote><ul><li>各种边界条件是否考虑完备</li><li>异常情况处理、稳定性保证</li><li>易读易维护</li></ul><h3 id="编程原则">编程原则</h3><p>简单性</p><ul><li>消除“多余的复杂性”，以简单清晰的逻辑编写代码</li><li>不理解的代码无法修复改进</li></ul><p>可读性</p><ul><li>代码是给人看的，而不是机器</li><li>编写可维护代码的第一步是确保代码可读</li></ul><p>生产力</p><ul><li>团队整体工作效率非常重要</li></ul><h2 id="编码规范">编码规范</h2><h3 id="代码格式">代码格式</h3><p>推荐使用<code>gofmt</code>或者<code>goimports</code>工具自动化格式化代码</p><blockquote><p>在<code>vscode</code>中可以在<code>settings.json</code>中进行配置</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230117132719395.png" /></p></blockquote><h3 id="注释">注释</h3><ol type="1"><li><p>解释代码作用：注释公共符号（函数、变量）</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230117132901852.png" /></p></li><li><p>解释代码如何做的：注释实现过程</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230117132920134.png" /></p></li><li><p>解释代码实现的原因：解释代码外部因素，提供额外上下文</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230117132940650.png" /></p></li><li><p>解释代码什么情况会出错：解释代码的限制条件</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230117133009300.png" /></p></li></ol><blockquote><p>代码是最好的注释，注释应该给出代码为表达出的上下文信息</p></blockquote><h3 id="命名规范">命名规范</h3><h4 id="变量">变量</h4><ul><li>简洁胜于冗长</li><li>缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写</li><li>变量距离其被使用的地方越远，则需要携带越多的上下文信息</li></ul><h4 id="函数">函数</h4><ul><li>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现</li><li>函数名尽量简短</li><li>当名为<code>foo</code>的包某个函数返回类型<code>Foo</code>时，可以省略类型信息而不导致歧义</li><li>当名为<code>foo</code>的包某个函数返回类型<code>T</code>时（不是<code>Foo</code>），可以在函数名中加入类型信息</li></ul><h4 id="package">package</h4><ul><li>只由小写字母组成。不包含大写字母和下划线等字符</li><li>简短并包含一定的上下文信息</li><li>不要与标准库同名</li><li>不使用常用变量名作为包名，例如使用<code>bufio</code>而不是<code>buf</code></li><li>使用单数而不是复数</li><li>谨慎地使用缩写，在不破坏上下文的情况下比尽可能简短，例如<code>fmt</code>包</li></ul><h3 id="控制流程">控制流程</h3><ul><li>避免嵌套，保持正常流程清晰</li><li>尽量保持正常代码路径为最小路径：优先处理错误情况和特殊情况，尽早返回或继续循环来减少嵌套</li><li>线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230117164220641.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230117164241983.png" /></p><h3 id="错误和异常处理">错误和异常处理</h3><h4 id="error">error</h4><ul><li>简单错误：仅出现一次的错误，且在其他地方不需要捕获该错误，优先使用<code>errors.New</code>来创建匿名变量直接表示简单错误；如果需要格式化处理，使用<code>fmt.Errorf()</code></li><li>错误的<code>Wrap</code>和<code>Unwrap</code>：错误的<code>Wrap</code>实际上是提供了一个<code>error</code>嵌套另一个<code>error</code>的能力，从而生成一个<code>error</code>的跟踪链，在<code>fmt.Errorf</code>中使用<code>%w</code>关键字来将一个错误关联至错误链中</li></ul><h4 id="panic">panic</h4><ul><li>不建议在业务代码中使用<code>panic</code></li><li>调用函数不包括<code>recover</code>会造成程序的崩溃</li><li>若问题可以被屏蔽或者解决，建议使用<code>error</code>代替<code>panic</code></li><li>如果在程序启动阶段就发生了不可逆的错误时，可以在<code>init</code>或者<code>main</code>函数中使用<code>panic</code></li></ul><h4 id="recover">recover</h4><ul><li><code>recover</code>只能在被<code>defer</code>的函数中使用</li><li>嵌套无法生效</li><li>只在当前的<code>goroutine</code>生效</li><li><code>defer</code>的语句是后进先出</li></ul><h2 id="性能优化建议">性能优化建议</h2><h3 id="预分配内存">预分配内存</h3><p>对于<code>slice</code>、<code>map</code>、<code>strings.Builder</code>和<code>bytes.Buffer</code>这几种在使用时最好都要预分配内存，否则在进行操作时会需要经常进行扩容从而频繁操作内存。</p><h3 id="字符串处理">字符串处理</h3><p><code>go</code>中存在3中字符串处理方式：用<code>+</code>拼接、<code>strings.Builder</code>、<code>bytes.Buffer</code>；可以看出<code>strings.Builder</code>和<code>bytes.Buffer</code>两种方式处理字符串的效率更高。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230117170015817.png" /></p><ul><li>字符串在<code>Go</code>语言中是不可变类型，占用内存大小是固定的</li><li>使用<code>+</code>每次都会重新分配内存</li><li>另外两种方式的实现底层都是<code>byte[]</code>，并且存在内存扩容策略，不需要每次拼接重新分配内存</li></ul><blockquote><p>和<code>Java</code>的字符串处理比较类似</p></blockquote><p>对于<code>strings.Builder</code>和<code>bytes.Buffer</code>这两种方式，也存在区别，从上图可以看出<code>strings.Builder</code>是更快的，从下面<code>strings.Builder</code>和<code>bytes.Buffer</code>的<code>String()</code>函数源码可以看出一点原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// To build strings more efficiently, see the strings.Builder type</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// Special case, useful in debugging.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;nil&gt;&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(b.buf[b.off:])<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// String returns the accumulated string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Builder)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> *(*<span class="hljs-type">string</span>)(unsafe.Pointer(&amp;b.buf))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>bytes.Buffer</code>转化为字符串时重新申请了一块空间</li><li><code>strings.Builder</code>直接将底层的<code>[]byte</code>转换成了字符串类型返回</li></ul><h3 id="空结构体">空结构体</h3><ul><li>空结构体<code>struct&#123;&#125;</code>实例不占据任何内存空间</li><li>可以作为各种场景下的占位符使用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 借助空结构体可以通过map来实现set</span><br>m := <span class="hljs-built_in">make</span>([<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-comment">// hash set</span><br></code></pre></td></tr></table></figure><h3 id="atomic包">atomic包</h3><ul><li>锁的实现是通过操作系统来实现，属于系统调用</li><li><code>atomic</code>操作是通过硬件实现，效率比锁高</li><li><code>sync.Mutex</code>应该用来保护一段逻辑而不是仅仅保护一个变量</li><li>对于非数值操作，可以使用<code>atomic.Value</code>，能承载一个<code>interface()</code></li></ul><h1 id="性能调优实战">性能调优实战</h1>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶——并发编程</title>
      <link href="/2023/01/16/Go/go-concurrency/"/>
      <url>/2023/01/16/Go/go-concurrency/</url>
      
        <content type="html"><![CDATA[<h2 id="并发与并行">并发与并行</h2><ul><li>并发：多个线程通过切换时间片的方式在一个<code>cpu</code>上进行调度运行</li><li>并行：多个线程在<code>cpu</code>的多个核上运行，真正的同时运行</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116082029712.png" /></p><h2 id="线程与协程">线程与协程</h2><ul><li>线程：内核态，操作系统内核进行调度的基本单位，在一个线程上可以跑多个携程，栈大小在MB级别</li><li>协程：用户态，由<code>Go</code>管理，轻量级线程，栈大小在KB级别</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116082257503.png" /></p><p><code>Go</code>中使用<code>go</code>语句创建协程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> concurrence<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello world : &quot;</span> + fmt.Sprint(i))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ManyGo</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<br>hello(j)<br>&#125;(i)<br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>输入如下</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116083908419.png" /></p><p>可以看到输出并不是顺序的，说明确实协程是并发执行的</p><h2 id="csp">CSP</h2><ul><li>通过通信共享内存：通过通道的方式实现进程之间信息的交换（<code>Go</code>语言提倡）</li><li>通过共享内存实现通信：操作系统中进程通信的经典方式，通过读写信号量实现对临界区内存的正确访问</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116084547715.png" /></p><h3 id="channel">Channel</h3><p><code>make(chan &lt;eleType&gt;, [size])</code></p><ul><li>无缓冲通道：<code>make(chan int)</code></li><li>有缓冲通道：<code>make(chan int, 2)</code></li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116085248292.png" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> concurrence<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CalSquare</span><span class="hljs-params">()</span></span> &#123;<br>src := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>dest := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 协程A: 将数字放进无缓冲通道src中</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(src)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>src &lt;- i<br>&#125;<br>&#125;()<br><span class="hljs-comment">// 协程B: 将数字从src中取出，平方后放入有缓冲通道dest</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(dest)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> src &#123;<br>dest &lt;- i * i<br>&#125;<br>&#125;()<br><span class="hljs-comment">// 主线程: 将数字从dest中取出并打印</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dest &#123;<br><span class="hljs-built_in">println</span>(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lock">Lock</h3><p>使用信号量的方式对临界区的访问进行控制，使得并发的协程能够正确访问临界区</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> concurrence<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>x    <span class="hljs-type">int64</span><br>lock sync.Mutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addWithLock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++ &#123;<br>lock.Lock()<br>x += <span class="hljs-number">1</span><br>lock.Unlock()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addWithoutLock</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++ &#123;<br>x += <span class="hljs-number">1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试是各创建5个协程调用上述两个方法，结果如下</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116090515359.png" /></p><p>可以看到加锁方法可以保证每次都正确得到结果；但是不加锁的方法每次得到的结果是不确定的</p><h2 id="waitgroup">WaitGroup</h2><p>前面在主线程创建了协程之后，主线程是使用<code>time.Sleep()</code>方法来阻塞自己的，但是这并不是一个好的方法，因为我们并不知道协程到底什么时候执行结束，我们只能传入一个大概的比较大的值进去。</p><p><code>sync</code>包下有一个结构体：<code>WaitGroup</code>，可以通过该方法优雅地实现主进程的阻塞</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116091334976.png" /></p><p>该结构体内部维护了一个计数器，并且暴露了三个方法出来</p><ul><li><code>Add</code>：创建了多少个协程，就传入相应的<code>delta</code></li><li><code>Done</code>：当协程运行结束时，调用<code>Done()</code></li><li><code>Wait</code>：该方法用来阻塞直到所有的协程执行结束</li></ul><p>然后就可以使用这三个方法来实现主进程的阻塞（以第一个例子为例）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ManyGo</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>hello(j)<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3-script-setup</title>
      <link href="/2023/01/13/front-end-technology/script-setup/"/>
      <url>/2023/01/13/front-end-technology/script-setup/</url>
      
        <content type="html"><![CDATA[<p>1、<code>setup</code>是<code>vue3</code>新增的生命周期函数，它的加入主要是为了<code>vue3</code>的组合式<code>API</code>得以使用。</p><p>2、<code>setup</code>位于<code>beforeCreated</code>之前，用于代替<code>created</code>和<code>beforeCreated</code>，由于<code>setup</code>函数执行的时候项目还没有初始化，所以不能访问<code>data</code>或<code>methods</code>中的数据，也不能使用<code>this</code>。</p><blockquote><p>由于不能使用<code>this</code>，在使用很多变量上会和<code>vue2</code>有一定区别</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// $router</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>; <span class="hljs-comment">// vue2</span><br><span class="hljs-comment">// vue3</span><br><span class="hljs-keyword">import</span> &#123; useRoute, useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> $router = <span class="hljs-title function_">useRouter</span>();<br></code></pre></td></tr></table></figure><p><ahref="https://www.yisu.com/zixun/697588.html#:~:text=%3Cscript%20setup%3E%20import%20%7B%20storeToRefs%20%7D%20from%20%27pinia%27,%7B%20count%2C%20double%20%7D%20%3D%20storeToRefs%20%28counter%29%20%3C%2Fscript%3E">setup语法糖中使用pinia做数据持久化</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 获取proxy, 和this类似作用</span><br><span class="hljs-keyword">import</span> &#123; getCurrentInstance &#125; <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">let</span> &#123; proxy &#125; = <span class="hljs-title function_">getCurrentInstance</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">ComponentInternalInstance</span>;<br>proxy.<span class="hljs-property">$router</span> <span class="hljs-comment">// 通过proxy获取$router</span><br></code></pre></td></tr></table></figure></blockquote><p>3、如果要在<code>&lt;script setup&gt;</code>中使用生命周期钩子函数，调用<code>onXXX</code>方法即可，例如<code>mounted</code>方法就是<code>onMounted</code>方法。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230114111916648.png" /></p><blockquote><p><code>ref</code>属性</p><ol type="1"><li>被用来给元素或者子组件注册引用信息</li><li>应用在<code>html</code>标签上获取的是真是<code>DOM</code>元素，应用在组件标签上是组件实例对象</li><li>使用方式，在标签中增加<code>ref="xxx"</code>，然后就可以通过<code>this.$refs.xxx</code>来获取</li></ol><p>注意在<code>&lt;script setup&gt;</code>中，使用方式有所改变，因为不能使用<code>this</code>指针</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildVue</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&#x27;ts&#x27;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>();</span><br><span class="language-javascript"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childRef.<span class="hljs-property">value</span>); <span class="hljs-comment">// Proxy&#123;...&#125;</span></span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>碰到一个错误就是使用<code>refName.value.xxx='xx'</code>去做修改的时候报错：<ahref="https://salesforce.stackexchange.com/questions/256761/uncaught-typeerror-set-on-proxy-trap-returned-falsish-for-property-name">'set'on proxy: trap returned falsish for property'direction'</a>，大概原因是修改了只读变量，如果要做修改需要将其变成可修改的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Object</span>(&#123;&#125;, steps.<span class="hljs-property">value</span>);<br>steps.<span class="hljs-property">value</span> = s; <span class="hljs-comment">// 这样steps.value就可以修改了</span><br></code></pre></td></tr></table></figure></blockquote><p>如果在父组件中需要调用子组件内的方法，需要在子组件中将方法公开</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">foo</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">//...  </span><br>&#125;;<br><span class="hljs-title function_">defineExpose</span>(&#123;<br>    foo<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后就可以在父组件中使用</p></blockquote><blockquote><p>相关文章：</p><p><a href="https://juejin.cn/post/7009282373476941831">Vue3 scriptsetup 语法糖详解</a></p><p><ahref="https://www.jianshu.com/p/5096bfb42e5a">Vue3之script-setup全面解析</a></p><p><ahref="https://www.cnblogs.com/Joannamo/p/15396039.html#script-setup%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">setup函数和scriptsetup</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础</title>
      <link href="/2023/01/13/Go/go-language-learning/"/>
      <url>/2023/01/13/Go/go-language-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="go语言环境搭建">Go语言环境搭建</h2><h3 id="安装go">安装Go</h3><p>在<ahref="https://go.dev/dl/">官网</a>下载Go语言的安装包，然后按照要求安装即可。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230114183054321.png" /></p><p>安装完毕后，需要添加系统环境变量<code>GOROOT</code>，其值为<code>Go</code>的安装目录（安装过程中可以自定义），以及在<code>Path</code>里加上安装目录下的<code>bin</code>目录，然后在<code>cmd</code>中输入<code>go version</code>。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230114183357126.png" /></p><p>然后就是配置IDE，我选择的是<code>vscode</code>。需要安装<code>Go</code>插件；并且安装插件依赖工具：调出命令面板输入<code>go install tools</code>，选择<code>Go: Install/Update Tools</code>。</p><h3 id="工作空间">工作空间</h3><blockquote><p><code>Go</code>的工作空间是由<code>GOPATH</code>环境变量指定的，在<code>Go</code>早期版本，<code>GOPATH</code>是必须的，即所有的<code>Go</code>项目代码都要保存在<code>GOPATH</code>指定的目录下。但是后面<code>Go</code>引入了<code>Go Module</code>，使用<code>Go Module</code>管理的项目可以放在<code>GOPATH</code>之外。</p></blockquote><p>工作空间是<code>Go</code>比较特别的地方，它要求所有的项目代码都要放在工作空间中，包括自己写的项目代码以及从外部获取的代码可以存在该空间内。工作空间中存在三个文件夹：</p><ul><li><code>src</code>：存放项目源代码</li><li><code>pkg</code>：存放编译生成的代码</li><li><code>bin</code>：存放编译生成的<strong>可执行</strong>代码</li></ul><p><strong>在Go中，是将每一个项目都当作<code>$GOPATH\src</code>的一个包来看待</strong>，工作空间的概念就有点类似于<code>Java</code>中的<code>classpath</code>。</p><blockquote><p><code>classpath</code>是<code>JVM</code>用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p><p>很多教程在配置Java环境时都会在系统变量中加上<code>CLASSPATH</code>环境变量，其中<code>.</code>代表当前目录。详见<ahref="https://www.liaoxuefeng.com/wiki/1252599548343744/1260466914339296">classpath和jar</a>。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230115101414843.png" /></p><p>在<code>Go</code>中，<code>GOPATH</code>的作用就是指示一个工作空间：当<code>Go</code>编译文件时，在工作空间中搜索需要的包。</p></blockquote><blockquote><p>相关文章：<ahref="https://stackoverflow.com/questions/24306183/can-someone-explain-why-gopath-is-convenient-and-how-it-should-be-used-in-genera">Cansomeone explain why GOPATH is convenient and how it should be used ingeneral?</a></p></blockquote><h2 id="go语言基础">Go语言基础</h2><h3 id="变量">变量</h3><p>定义变量有多种方式：</p><ul><li><code>var &lt;varName&gt; &lt;varType&gt; = &lt;value&gt;</code></li><li><code>var &lt;varName&gt; = &lt;value&gt;</code></li><li><code>varName := value</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> var1 <span class="hljs-type">string</span> = <span class="hljs-string">&quot;go&quot;</span><br><span class="hljs-keyword">var</span> var2 = <span class="hljs-number">10</span><br>var3 := <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 常量就是将var换成const</span><br><span class="hljs-keyword">const</span> const1 = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><code>_</code>是一个特殊的变量名，任何赋予它的值都会被丢弃。</li><li><code>Go</code>对于已声明但未使用的变量会在编译阶段报错</li></ul></blockquote><h3 id="数据类型">数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">int8</span>, <span class="hljs-type">int16</span>, <span class="hljs-type">int32</span>(<span class="hljs-type">rune</span>), <span class="hljs-type">int64</span> <span class="hljs-comment">// 有符号整数</span><br><span class="hljs-type">uint8</span>(<span class="hljs-type">byte</span>), <span class="hljs-type">uint16</span>, <span class="hljs-type">uint32</span>, <span class="hljs-type">uint64</span> <span class="hljs-comment">// 无符号整数</span><br><span class="hljs-type">bool</span> <span class="hljs-comment">// 布尔类型</span><br><span class="hljs-type">float32</span>, <span class="hljs-type">float64</span> <span class="hljs-comment">// 浮点数</span><br><span class="hljs-type">complex64</span>, <span class="hljs-type">complex128</span> <span class="hljs-comment">// 复数 一半位数作实数，一半位数作虚数</span><br><span class="hljs-type">string</span> <span class="hljs-comment">// 字符串</span><br></code></pre></td></tr></table></figure><blockquote><p>不同类型之间的变量不允许相互赋值或操作，例如<code>int</code>和<code>int32</code>之间的赋值</p></blockquote><h3 id="数据结构">数据结构</h3><ul><li><p><code>array</code>：静态数组（数组长度不可变）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// var &lt;arrayName&gt; [&lt;size&gt;]&lt;typeName&gt;</span><br><span class="hljs-keyword">var</span> arr [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">// &lt;arrayName&gt; := [&lt;size&gt;]&lt;typeName&gt;&#123;&lt;initVals&gt;&#125;</span><br>a := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>b := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// 自动根据元素个数来计算长度</span><br></code></pre></td></tr></table></figure></li><li><p><code>slice</code>：动态数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明方式和array相比就是少了[]中的长度</span><br><span class="hljs-keyword">var</span> slice []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-comment">// 可以通过append来向slice中增加内容</span><br>s1 = <span class="hljs-built_in">append</span>(s1, <span class="hljs-number">3</span>) <span class="hljs-comment">// [1, 2, 3, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><code>map</code>：字典</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// var &lt;mapName&gt; map[&lt;keyType&gt;]&lt;valueType&gt;</span><br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">// &lt;mapName&gt; := make(map[&lt;keyType&gt;valueType])</span><br>mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>m1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;c++&quot;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&quot;go&quot;</span>:<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="控制流">控制流</h3><blockquote><p>在<code>Go</code>有<code>if-else</code>、<code>for</code>、<code>switch-case</code>三大结构，唯一需要注意的是<strong><code>Go</code>中条件表达式不需要用括号包裹</strong>。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// if-else</span><br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// for</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++ &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// switch-case</span><br><span class="hljs-keyword">switch</span> i &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// ....</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">func funcName(arg1 type1, arg2 type2, ... ) (ret1 type1, ret2 type2) &#123;</span><br><span class="hljs-comment">    // ...</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> (res <span class="hljs-type">int</span>, ok <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fmt">fmt</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br>fmt.Println() <span class="hljs-comment">// 打印一行</span><br>fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, s) <span class="hljs-comment">// 所有类型的变量都是用v通配符</span><br>fmt.Printf(<span class="hljs-string">&quot;%+v&quot;</span>, s) <span class="hljs-comment">// 输出关于s变量的详细信息</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v&quot;</span>, s) <span class="hljs-comment">// 更加详细</span><br>f := <span class="hljs-number">3.1415</span><br>fmt.Printf(<span class="hljs-string">&quot;%.2f&quot;</span>, f)<br></code></pre></td></tr></table></figure><blockquote><p>拥有以上知识基本上就可以写一些简单的程序了</p></blockquote><h2 id="go依赖管理">Go依赖管理</h2><h3 id="依赖管理演进">依赖管理演进</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116104940464.png" /></p><h3 id="gopath">GOPATH</h3><p>在<code>GOPTAH</code>指定工作空间的模式下，所有的项目代码都要存放在<code>$GOPATH/src</code>目录下，包括项目代码依赖的包也是存放在该目录下，就会导致下面的问题：两个项目依赖于两个不同版本的包，但是由于两个版本的包不兼容就导致两个项目会有一个有问题，即<strong>无法实现package的多版本控制</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116105024051.png" /></p><h3 id="go-vender">Go Vender</h3><p>项目目录下增加<code>vendor</code>文件，在每个项目内配置该项目所依赖的包</p><p>依赖寻址方式：先<code>vender</code> 后 <code>GOPATH</code></p><p>这个方式也会存在一个问题：一个项目依赖于两个<code>package</code>，这两个<code>package</code>又依赖于不同版本的<code>package</code>，这样还是会导致冲突。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116080132092.png" /></p><h2 id="go-module">Go Module</h2><blockquote><p>实现了终极目标：定义版本规则和管理项目依赖关系</p></blockquote><ul><li>通过<code>go.mod</code>文件管理依赖包版本</li><li>通过<code>go get/go mod</code>指令工具管理依赖包</li></ul><h3 id="配置文件go.mod">配置文件——go.mod</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116110311906.png" /></p><p>可以看到依赖由几部分组成：包路径、版本号、以及一些特殊标志</p><h4 id="版本号">版本号</h4><ul><li>语义化版本：<code>$&#123;MAJOR&#125;.$&#123;MINOR&#125;.$&#123;PATCH&#125;</code></li><li>基于<code>commit</code>的伪版本：<code>vx.0.0-yyyymmddhhmmss-&lt;12位hash码&gt;</code></li></ul><h4 id="特殊标志">特殊标志</h4><ul><li><code>indirect</code>：表示的是间接依赖。<code>A-&gt;B-&gt;C</code>，<code>A</code>对<code>C</code>就是间接依赖</li><li>主版本<code>2+</code>模块会在模块路径后增加<code>/vN</code>后缀</li><li><code>+incompatible</code>：对于没有<code>go.mod</code>文件且主版本<code>2+</code>的依赖，表示可能出现不兼容的代码逻辑</li></ul><h4 id="依赖图">依赖图</h4><p>最终编译的时候会使用<code>C 1.4</code>：<strong>因为会选择最低兼容版本</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116111321724.png" /></p><h3 id="proxy">Proxy</h3><p>对于<code>go.mod</code>所用到的依赖应该去哪里下载以及如何下载，常见的有<code>Github</code>等第三方代码托管平台，像之前在配置Go语言开发环境时就需要到<code>Github</code>上下载对应的依赖工具。但是依赖第三方代码托管平台上下载依赖会存在一些问题：</p><ul><li>无法保证构建稳定性以及依赖可用性：因为作者随时可以修改删除软件版本甚至是整个软件</li><li>增加第三方平台压力</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116111648728.png" /></p><p>一个解决方案就是引入<code>Proxy</code>：它其实是一个服务站点，用来缓存源站中的软件以及对应的软件版本，不会改变，实现依赖的稳定性和可靠性。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116112115698.png" /></p><p>使用<code>GOPROXY</code>配置，指定一个服务站点<code>url</code>列表。例如：<code>GOPROXY="https://proxy1.cn, https://proxy2.cn, direct(源站点)"</code>，那么就会<strong>依次</strong>到指定几个网站中下载依赖。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116112411670.png" /></p><h3 id="go-getgo-mod">go get/go mod</h3><p>使用<code>go get/go mod</code>来管理和安装项目的依赖</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116112745496.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230116112802277.png" /></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab4 Traps</title>
      <link href="/2023/01/13/6.S081/6.S081-lab4-traps/"/>
      <url>/2023/01/13/6.S081/6.S081-lab4-traps/</url>
      
        <content type="html"><![CDATA[<h2 id="risc-v-assembly">RISC-V Assembly</h2><blockquote><p>主要是回答一下关于汇编的问题，难度不大</p></blockquote><h2 id="backtrace">Backtrace</h2><p>实现一个函数，能够打印出栈上函数调用链，以帮助出错时的调试。</p><p>原理也比较简单：利用栈结构的性质（返回地址和上一个栈帧指针在栈中存放位置是固定的），由当前栈帧指针开始，不断向上得到栈中返回地址，直到到达栈的底部。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230103182903462.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<br>  <span class="hljs-comment">// get the current frame pointer</span><br>  uint64 fp = r_fp();<br>  <span class="hljs-comment">// attention: stack grow from high address to low address</span><br>  uint64 stack_bottom = PGROUNDUP(fp); <span class="hljs-comment">// note the bottom of stack</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    uint64 ret_addr = *((uint64 *)(fp - <span class="hljs-number">8</span>)); <span class="hljs-comment">// get the return address</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, ret_addr);<br>    fp = *((uint64 *)(fp - <span class="hljs-number">16</span>)); <span class="hljs-comment">// get the previous frame pointer</span><br>    <span class="hljs-keyword">if</span> (PGROUNDUP(fp) != stack_bottom) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// judge the fp cross over the stack_bottom or not</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="alarm">Alarm</h2><blockquote><p>要求实现一个机制，在调用了<code>sigalarm(interval, handler)</code>后，该进程每消耗<code>interval</code>个时间片，就要调用一次<code>handler</code>函数。</p></blockquote><h3 id="思路">思路</h3><p>实现的核心是：编写<code>sigalarm</code>、<code>sigreturn</code>两个<strong>系统调用</strong>和修改<code>usertrap</code>中处理<strong>时钟中断</strong>的部分代码。</p><p>下图是核心函数之间的调用关系，也是该部分的重点和难点，因为涉及内核空间和用户空间的频繁切换。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230125072846825.png" /></p><p>重点需要理解的有两点：</p><ol type="1"><li><p><code>usertrap</code>位于内核空间，而<code>handler function</code>位于用户空间，<code>3</code>号箭头应该如何发生？</p><p><font color='red'><strong>由于<code>usertrap</code>是在处理异常的一个环节中，最后还是会返回到用户空间中，如果不做处理返回的是源代码发生中断的位置，而该位置是由<code>sepc</code>寄存器保存的，在<code>usertrap</code>中<code>sepc</code>寄存器中的值被保存在了<code>p-&gt;trapframe-&gt;epc</code>中，所以只要将<code>p-&gt;trapframe-&gt;epc</code>的值设置成<code>handler function</code>的地址即可</strong></font></p></li><li><p><code>sigreturn</code>系统调用是<code>handler function</code>调用的，如何使其返回时回到<code>user code</code>原先被时钟中断的那部分代码，即<code>5</code>号箭头如何发生？</p><p><strong><font color='red'>这一部分其实和第一点类似，只要设置<code>p-&gt;trapframe-&gt;epc</code>就可以使其返回到原先被中断处，但是还需要考虑如何恢复源代码的上下文，就需要恢复所有的寄存器。所以需要在<code>usertrap</code>中保存<code>p-&gt;trapframe</code>中的所有值，然后在<code>sys_sigreturn</code>处恢复</font></strong></p></li></ol><h3 id="实现">实现</h3><p>两个系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// return from the handler function to user code which interrupted by time interrupt</span><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>  memmove(p-&gt;trapframe, p-&gt;savedtrapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe)); <span class="hljs-comment">// restore all the registers</span><br>  p-&gt;inhandler = <span class="hljs-number">0</span>;<br>  p-&gt;ticksincelast = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> ticks; uint64 fn_addr;<br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>, &amp;ticks) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;fn_addr) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">if</span> (ticks == <span class="hljs-number">0</span> &amp;&amp; fn_addr == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// stop generating periodic alarm calls. </span><br>    p-&gt;ticks = <span class="hljs-number">-1</span>;<br>    p-&gt;handler_p = <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    p-&gt;ticks = ticks;<br>    p-&gt;handler_p = fn_addr;<br>  &#125;<br>  p-&gt;ticksincelast = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>usertrap</code>中针对时钟中断的的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">if</span> (ticks &gt;= <span class="hljs-number">0</span> &amp;&amp; !p-&gt;inhandler)&#123;<br>        p-&gt;ticksincelast ++;<br>        <span class="hljs-comment">// kernel cause the user process to call the handler function</span><br>        <span class="hljs-comment">// current is in kernelspace, while the handler function address is in userspace</span><br>        <span class="hljs-comment">// so just set the p-&gt;trapframe-&gt;epc to the address of the handler function</span><br>        <span class="hljs-comment">// when return to userspace, will call the handler function </span><br>        <span class="hljs-keyword">if</span> (p-&gt;ticksincelast == p-&gt;ticks) &#123;<br>            memmove(p-&gt;savedtrapframe, p-&gt;trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>            p-&gt;trapframe-&gt;epc = p-&gt;handler_p;<br>            p-&gt;inhandler = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    yield();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题">问题</h3><p>1、<code>usertrap</code>中只保存了handler函数处理完的返回地址，并没有保存一整套寄存器，导致回到<code>user code</code>之后，上下文改变了，所以发生了异常</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230125055351113.png" /></p><p>2、<code>p-&gt;savedtrapframe</code>在初始化时没有分配内存，导致发生了内存<code>store</code>时的缺页异常。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230125055254773.png" /></p><p>3、<code>p-&gt;savedtrapframe</code>没有释放</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230125063126826.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 6.S081-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode周赛笔记</title>
      <link href="/2023/01/09/leetcode/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/09/leetcode/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="单周赛">311单周赛</h2><blockquote><p>时间：2022.09.18</p><p>【过程】</p><p>前两道题很快就写出来了</p><p>第三道题，很难受，一种感觉能写出来但是就是写不出来的感觉，还是对于二叉树的递归不够深入</p><p>第四道题用常规方法写出来，但是超时...</p></blockquote><h3 id="最长的字母序连续子字符串的长度">6181.最长的字母序连续子字符串的长度</h3><blockquote><p><ahref="https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/">题目</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比赛写的时候是用栈写的，但是其实只是用到栈的思想，不用栈也是完全可以的</span><br><span class="hljs-comment">// 抓住 1、连续 2、字母序 3、最大</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestContinuousSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下一个需要的字符</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span>(c == need)&#123;<br>            cnt ++;<br>            need ++;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果不满足的话，从这个位置重新开始向后寻找</span><br>            need = c + <span class="hljs-number">1</span>;<br>            cnt = <span class="hljs-number">1</span>;<br>        &#125;<br>        maxLen = Math.max(maxLen, cnt);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反转二叉树的奇数层">6182. 反转二叉树的奇数层</h3><blockquote><p><ahref="https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/">题目</a></p></blockquote><p>【答题】</p><p>解题过程中，想过递归和队列两种方式。</p><p>但是，递归想的一直都是如何交换节点，所以很快就放弃了</p><p>使用队列，想的是在奇数层用遍历将值倒过来，写的过程中不是很顺利</p><p>【思路】</p><p><strong>核心思想就是交换值，不交换结点</strong></p><h4 id="dfs-递归">DFS 递归</h4><p>其实使用DFS递归的过程中只要交换结点的值就可以了，这样就不会影响下面的子节点，只要考虑如何递归能够将一层的结点值倒过来。</p><p>运用到二叉树递归的一个技巧，【当递归函数参数只有一个结点难以实现递归时，可以考虑使用两个结点参数的递归函数】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">reverseOddLevels</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">reverseOddLevelsByDFS</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    dfs(root.left, root.right, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node1, TreeNode node2, <span class="hljs-type">int</span> level)</span>&#123;<br>    <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <br><span class="hljs-comment">// 如果是奇数层，就交换对应结点的值</span><br>    <span class="hljs-keyword">if</span>(level % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node1.val;<br>        node1.val = node2.val;<br>        node2.val = tmp;<br>    &#125;<br><span class="hljs-comment">// 通过两个结点一起递归，且该两个结点是处于对称位置</span><br>    dfs(node1.left, node2.right, level+<span class="hljs-number">1</span>);<br>    dfs(node1.right, node2.left, level+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bfs-迭代">BFS 迭代</h4><p>BFS迭代就是借助队列实现层次遍历，如果是奇数层做出对结点值的改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] values;<br><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">reverseOddLevelsByBFS</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br><br>        <span class="hljs-comment">// 如果队列中放的是奇数层，将这一层的值取出来放在values数组中</span><br>        <span class="hljs-keyword">if</span>(level % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                values[i] = node.val;<br>                queue.offer(node);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 改造一下常规框架，如果是奇数层，再将结点poll出来之后，根据values数组改变其值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span>(level % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 如果是奇数层就改变值</span><br>                node.val = values[size - i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>        &#125;<br><br>        level++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串的前缀分数和">6183. 字符串的前缀分数和</h3><blockquote><p><ahref="https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/">题目</a></p></blockquote><p>在前缀树的基础上，这道题就十分简单了，只需要稍微改造一下前缀树，在插入word的过程中每经过一个结点就+1，然后再提供一个计算word得分的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">改造 Trie 树 在每一个结点里增加一个 cnt 统计在插入过程中 经过该结点的单词个数</span><br><span class="hljs-comment">也就是以 到这个结点为至形成的prefix 开始的单词数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sumPrefixScores(String[] words) &#123;<br>    <span class="hljs-type">Trie</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>    <span class="hljs-keyword">for</span> (String word : words) &#123;<br>        root.insert(word);<br>    &#125;<br>    <span class="hljs-type">int</span>[] answer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[words.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>        answer[i] = root.getScores(words[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">public</span> Trie[] children;<br>    <span class="hljs-type">boolean</span> isEnd;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> cnt;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-literal">false</span>;<br>        cnt = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>) &#123;<br>                cur.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur.children[idx].cnt ++; <span class="hljs-comment">// 经过这个结点的单词数++</span><br>            cur = cur.children[idx];<br>        &#125;<br>        cur.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获得该word的得分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScores</span><span class="hljs-params">(String word)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 不存在这个word, 对于已存在的word肯定不会出现这个情况</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                score += cur.children[idx].cnt;<br>                cur = cur.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isEnd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模板-208.-实现-trie-前缀树">模板: 208. 实现 Trie (前缀树)</h4><blockquote><p><ahref="https://leetcode.cn/problems/implement-trie-prefix-tree/">题目</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Trie的原理: 每一个结点都包含一个指向 size = 26 的数组的引用</span><br><span class="hljs-comment">插入一个单词就是 从根节点依次向下新增结点 在数组对应位置(对应下标的字符 - &#x27;a&#x27;) 创建结点Trie</span><br><span class="hljs-comment">26cha&#x27;shu</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">public</span> Trie[] children;<br>    <span class="hljs-type">boolean</span> isEnd;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-literal">false</span>;<br>        cnt = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>) &#123;<br>                cur.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.children[idx];<br>        &#125;<br>        cur.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isEnd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单周赛-1">327单周赛</h2><blockquote><p>时间：2023-01-08</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230108222540372.png" /></p><p>在第三道题浪费了太多时间，第四道题比较复杂，思路不清晰。</p></blockquote><h3 id="使字符串总不同字符的数目相等第三题"><ahref="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/">6284.使字符串总不同字符的数目相等(第三题)</a></h3><blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230108222913402.png" /></p></blockquote><p>这道题在做题时把问题想简单了，导致没有考虑全面，通过判题罚时找到漏洞。</p><p>其实可以将两个字符串的字符出现情况用两个数组记录下来，然后双重循环即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isItPossible</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word1) a1[c-<span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word2) a2[c-<span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>    <br>    <span class="hljs-type">int</span> s1 = <span class="hljs-number">0</span>, s2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : a1) s1 += i &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : a2) s2 += i &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(s1 - s2) &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span> (a1[i] &gt; <span class="hljs-number">0</span> &amp;&amp; a2[j] &gt; <span class="hljs-number">0</span>)&#123;<br>                a1[j]++; a1[i]--; a2[j]--; a2[i]++;<br>                s1 = <span class="hljs-number">0</span>; s2 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : a1) s1 += k &gt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : a2) s2 += k &gt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (s1 == s2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                a1[j]--; a1[i]++; a2[j]++; a2[i]--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="过桥的时间第四题"><ahref="https://leetcode.cn/problems/time-to-cross-a-bridge/">6306.过桥的时间(第四题)</a></h3><blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230108223927959.png" /></p></blockquote><p>看了题解，核心就是<strong>四个堆</strong>，因为上面的流程无非就是四个步骤：从桥的左边到右边、从旧仓库取箱子、从桥的右边到左边、从新仓库放箱子，就可以对应这四个步骤建立四个堆。整个过程还是比较复杂的，需要仔细理解。</p><ul><li>==wait_l==：在桥左边等待的工人</li><li>==wait_r==：在桥右边等待的工人</li><li>==box_l==：在新仓库放箱子的工人</li><li>==box_r==：在旧仓库取箱子的工人</li></ul><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230109143846728.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCrossingTime</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; time)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = time.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) time[i].<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-comment">// 按照效率从高到低排序 使得下标最大的工人效率最低</span><br>    <span class="hljs-built_in">sort</span>(time.<span class="hljs-built_in">begin</span>(), time.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)&#123;<br>        <span class="hljs-type">int</span> prof_a = a[<span class="hljs-number">0</span>] + a[<span class="hljs-number">2</span>]; <span class="hljs-type">int</span> prof_b = b[<span class="hljs-number">0</span>] + b[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (prof_a != prof_b) <span class="hljs-keyword">return</span> prof_a &lt; prof_b;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">4</span>] &lt; b[<span class="hljs-number">4</span>];<br>    &#125;);<br><br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; wait_l, wait_r; <span class="hljs-comment">// 大顶堆 top()是效率最低的工人</span><br>    priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt;&gt; box_l, box_r; <span class="hljs-comment">// 小顶堆 top()是最快完成box任务的工人</span><br><br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录时间</span><br><br>    <span class="hljs-comment">// 一开始全部在左边等待</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++) wait_l.<span class="hljs-built_in">push</span>(i);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">bool</span> LtoR = n &gt; <span class="hljs-number">0</span> &amp;&amp; !wait_l.<span class="hljs-built_in">empty</span>();<br>        <span class="hljs-type">bool</span> RtoL = !wait_r.<span class="hljs-built_in">empty</span>();<br><br>        <span class="hljs-keyword">if</span> (!LtoR &amp;&amp; !RtoL) &#123; <span class="hljs-comment">// 左右两边都没有工人等待</span><br>            <span class="hljs-comment">// 找到box_l和box_r中最快完成任务的工人 更新时间</span><br>            <span class="hljs-type">int</span> x = INT_MAX;<br>            <span class="hljs-keyword">if</span>(!box_l.<span class="hljs-built_in">empty</span>()) x = <span class="hljs-built_in">min</span>(x, box_l.<span class="hljs-built_in">top</span>().first);<br>            <span class="hljs-keyword">if</span>(!box_r.<span class="hljs-built_in">empty</span>()) x = <span class="hljs-built_in">min</span>(x, box_r.<span class="hljs-built_in">top</span>().first);<br>            cur = x;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (RtoL)&#123; <span class="hljs-comment">// 右边到左边</span><br>            <span class="hljs-type">int</span> x = wait_r.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 取出右边效率最低的工人x</span><br>            wait_r.<span class="hljs-built_in">pop</span>();<br>            cur += time[x][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 让x工人过桥</span><br>            <span class="hljs-comment">// 检查是否是最后一个工人到达桥左岸</span><br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> &amp;&amp; wait_r.<span class="hljs-built_in">empty</span>() &amp;&amp; box_r.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> cur;<br>            box_l.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">p</span>(cur+time[x][<span class="hljs-number">3</span>], x)); <span class="hljs-comment">// 过桥后到新仓库放箱子 放入box_l堆中</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (LtoR) &#123; <span class="hljs-comment">// 左边到右边</span><br>            <span class="hljs-type">int</span> x = wait_l.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 取出左边效率最低的工人x</span><br>            wait_l.<span class="hljs-built_in">pop</span>();<br>            cur += time[x][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 让x工人过桥</span><br>            box_r.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">p</span>(cur+time[x][<span class="hljs-number">1</span>], x)); <span class="hljs-comment">// 过桥后到旧仓库取箱子 放入box_r堆中</span><br>            n--; <span class="hljs-comment">// 箱子数-1</span><br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!box_l.<span class="hljs-built_in">empty</span>()) &#123;<br>            p worker = box_l.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-comment">// 如果在桥上的工人过桥的时间里，有工人能够完成box任务，就将他们放到对应的桥边等待队列中</span><br>            <span class="hljs-keyword">if</span> (worker.first &gt; cur) <span class="hljs-keyword">break</span>;<br>            box_l.<span class="hljs-built_in">pop</span>();<br>            wait_l.<span class="hljs-built_in">push</span>(worker.second);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!box_r.<span class="hljs-built_in">empty</span>()) &#123;<br>            p worker = box_r.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-comment">// 如果在桥上的工人过桥的时间里，有工人能够完成box任务，就将他们放到对应的桥边等待队列中</span><br>            <span class="hljs-keyword">if</span> (worker.first &gt; cur) <span class="hljs-keyword">break</span>;<br>            box_r.<span class="hljs-built_in">pop</span>();<br>            wait_r.<span class="hljs-built_in">push</span>(worker.second);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>类似的题目：</p><p><a href="https://leetcode.cn/problems/single-threaded-cpu/">1834.单线程 CPU</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间求和</title>
      <link href="/2023/01/05/leetcode/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/"/>
      <url>/2023/01/05/leetcode/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307.区域和检索 - 数组可修改</a></p></blockquote><p>区间求和是算法中非常常见的一个类型题目，一般有两个操作：</p><ol type="1"><li>单点更新</li><li>区间求和</li></ol><p>然后不同的题目会对上面两种操作的调用次数不同</p><h2 id="普通方法">1、普通方法</h2><h3 id="普通数组">1.1、普通数组</h3><ul><li>单点更新：<span class="math inline">\(O(1)\)</span></li><li>区间求和：<span class="math inline">\(O(N)\)</span></li></ul><h3 id="前缀和数组">1.2、前缀和数组</h3><ul><li>单点更新：<span class="math inline">\(O(N)\)</span></li><li>区间求和：<span class="math inline">\(O(1)\)</span></li></ul><blockquote><p>无论是哪一种方式，如果单点更新和区间求和的次数相当，并且都十分多时，效率是不高的。</p><p>但是如果某一种操作的调用次数非常高，可以使用对应的方式。</p><p>例如有些题目，数组初始化后就不再改变，只是不断地求区间和，就可以使用前缀和。</p></blockquote><h2 id="分块">2、分块</h2><blockquote><p>分块的思想是，由于单点更新和区间求和的调用次数相当，所以希望尽可能平摊在两个操作上的时间复杂度</p></blockquote><p>【操作】</p><ol type="1"><li>将数组分成 <span class="math inline">\(\sqrt{N}\)</span> 块，每块有<span class="math inline">\(\sqrt{N}\)</span> 个元素</li><li>单点更新：在某个块内遍历：<spanclass="math inline">\(O(\sqrt{N})\)</span></li><li>区间求和：最多将 <span class="math inline">\(\sqrt{N}\)</span>个块加在一起：<span class="math inline">\(O(\sqrt{N})\)</span></li></ol><h2 id="树形数组">3、树形数组</h2><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029210540933.png"alt="image-20221029210540933" /><figcaption aria-hidden="true">image-20221029210540933</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Binary Index Tree</span><br><span class="hljs-comment"> * 树状数组</span><br><span class="hljs-comment"> * 思想是: 前缀区间的差集</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> len;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        len = n + <span class="hljs-number">1</span>;<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 做单点更新</span><br><span class="hljs-comment">     * 要把包含了nums[i]的元素全部更新</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i 下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 增加的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> delta)</span>&#123;<br>        i = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; len)&#123;<br>            tree[i] += delta;<br>            i += lowbit(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i 下标 i</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 前 i 个元素之和</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        i = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>)&#123;<br>            sum += tree[i];<br>            i -= lowbit(i); <span class="hljs-comment">// 不断去掉(二进制表示下)最后一个1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树">4、线段树</h2><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029210553764.png"alt="image-20221029210553764" /><figcaption aria-hidden="true">image-20221029210553764</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线段树</span><br><span class="hljs-comment"> * 用二分的方式来对树进行划分</span><br><span class="hljs-comment"> * 思想是: 若干区间的并集</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br>    <span class="hljs-type">int</span>[] st;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SegmentTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        buildTree(nums);<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    二叉树的性质:</span><br><span class="hljs-comment">            1、已知父节点下标 i，求出左右子节点的下标 i &gt;&gt; 1 和 (i &gt;&gt; 1) | 1</span><br><span class="hljs-comment">            2、已知左右子节点下标 i，求出父节点下标 i &lt;&lt; 1</span><br><span class="hljs-comment">            3、对于完美二叉树来说，整棵树的节点总数 = 2 * 叶子节点总数</span><br><span class="hljs-comment">    从最底层开始建树</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        n = nums.length;<br>        st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span> * n];<br>        <span class="hljs-comment">// 先构建叶子节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &lt; <span class="hljs-number">2</span> * n; i++)&#123;<br>            st[i] = nums[i - n];<br>        &#125;<br>        <span class="hljs-comment">// 构建非叶子节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-comment">// st[i &lt;&lt; 1] 和 st[(i &lt;&lt; 1) | 1] 分别代表 左子节点 和 右子节点</span><br>            st[i] = st[i &lt;&lt; <span class="hljs-number">1</span>] + st[(i &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> delta)</span>&#123;<br>        index += n;<br>        <span class="hljs-keyword">while</span> ( index &gt; <span class="hljs-number">0</span>)&#123;<br>            st[index] += delta;<br>            index = index &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 向上找到父节点</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        l += n; r += n;<br>        <span class="hljs-keyword">for</span> (; l &lt;= r; l &gt;&gt;= <span class="hljs-number">1</span>, r &gt;&gt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>( (l &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> )&#123; <span class="hljs-comment">// l是右子节点</span><br>                sum += st[l];<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>( (r &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )&#123; <span class="hljs-comment">// r是左子节点</span><br>                sum += st[r];<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理Lab5</title>
      <link href="/2022/12/30/compilation-principle/compilation-principle-lab5/"/>
      <url>/2022/12/30/compilation-principle/compilation-principle-lab5/</url>
      
        <content type="html"><![CDATA[<h2 id="实验过程">实验过程</h2><blockquote><p><ahref="http://47.122.3.40:8081/#/lab5-function-and-var/lab5-function-and-var">本次实验</a>通过重新设计符号表，使用Visitor函数遍历语法树并在合适的函数内调用LLVM的API完成了对函数定义和函数调用，以及局部变量的声明、定义和使用的翻译。</p></blockquote><p>==重新设计符号表==：整体上符号表的结构没有改变，只是需要记录的信息变成了<code>LLVMValueRef</code>和<code>LLVMTypeRef</code>。<u>注意存在符号表里的<code>LLVMValueRef</code>是指针，而不是变量本身。</u></p><p>==翻译==：翻译过程并不复杂，但是需要注意很多细节！</p><h2 id="遇到的问题">遇到的问题</h2><p>==BUGs==：<strong>1</strong>、<code>void</code>函数可以没有返回语句，但是翻译时要将其加上；<strong>2</strong>、<code>(exp)</code>的<code>visitor</code>函数需要重写使其返回<code>exp</code>的<code>LLVMValueRef</code>；<strong>3</strong>、形如<code>x[x[0]]</code>的翻译中，当其作为左值时要注意，里面的<code>x[0]</code>返回的应是本身的值，而外面的<code>x[]</code>返回的应该是指针，由于两者都属于<code>LVal</code>，所以在遍历翻译是需要加以区分。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab3 Page Tables</title>
      <link href="/2022/12/27/6.S081/6.S081-lab3-pgtbl/"/>
      <url>/2022/12/27/6.S081/6.S081-lab3-pgtbl/</url>
      
        <content type="html"><![CDATA[<h2 id="lecture-4-chapter-3">0 lecture 4 &amp; chapter 3</h2><h3 id="lecture-4">Lecture 4</h3><h3 id="chapter-3-page-tables">Chapter 3 Page tables</h3><h4 id="xv6的页表映射机制">xv6的页表映射机制</h4><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221225144537100.png" /></p><h4 id="xv6-内核地址空间">xv6 内核地址空间</h4><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221225144757600.png" /></p><h4 id="xv6的页表代码">xv6的页表代码</h4><blockquote><p><code>vm.c</code></p></blockquote><p>核心数据结构：==pagetable_t==</p><p>核心函数：==walk== 和 ==mappages==</p><h4 id="物理地址分配代码">物理地址分配代码</h4><blockquote><p><code>kalloc.c</code></p></blockquote><p>核心数据结构：==kmem==</p><p>核心函数：==kfree== 和 ==kalloc==</p><h4 id="进程地址空间">进程地址空间</h4><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221225152730759.png" /></p><h4 id="系统调用sbrk-和-exec">系统调用：sbrk 和 exec</h4><p><strong>sbrk</strong>：为一个进程去减少或者增加它的内存（<code>kernel/sysproc.c</code>）</p><p><strong>exec</strong>：创建一个地址空间的用户部分</p><blockquote><p><font color='red'>what is trampoline?</font></p><p>trampolinepage存储了用户空间和内核空间相互切换的代码，无论是在内核空间还是在用户空间它都映射在相同的虚拟地址，这样在切换之后还可以继续工作。</p><p>相关文章：<ahref="https://xiayingp.gitbook.io/build_a_os/traps-and-interrupts/untitled-3">Whatis trampoline?</a></p><p><font color='red'>what is trapframe?</font></p><p><code>trapframe</code>是存在于用户地址空间，位于<code>trampoline</code>下面的大小为<code>PGSIZE</code>（4096字节）的一块内存，用于在用户地址空间向内核地址空间切换时保存用户空间的寄存器。</p></blockquote><h2 id="speed-up-system-calls">1 Speed up system calls</h2><p><u>任务描述</u>：加速<code>getpid()</code>系统调用。方法是在<code>trapframe</code>前面映射一个只读的页，在这个页的开始，存储一个结构体<code>syscall</code>，结构体里存储当前进程的<code>pid</code>，然后通过已经提供的<code>ugetpid()</code>函数获得<code>pid</code>。</p><p><u>思路</u>：可以参考<code>trapframe</code>的构造。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 步骤</span><br><span class="hljs-comment">// 1. 在proc结构体中增加一个usyscall字段</span><br><span class="hljs-comment">// 2. 在allocproc()函数为usyscall分配空间，并且将pid存储在usyscall中</span><br><span class="hljs-comment">// 3. 在proc_pagetable()函数中将p-&gt;usyscall（物理地址）映射到USYSCALL（虚拟地址）</span><br><span class="hljs-comment">// 4. 在freeproc()函数中将usyscall的空间释放</span><br><span class="hljs-comment">// 5. 在proc_freepagetable()函数中取消之前建立的映射</span><br></code></pre></td></tr></table></figure><h2 id="print-a-page-table">2 Print a page table</h2><p><u>任务描述</u>：如题要求打印页表。</p><p><u>思路</u>：参考<code>freewalk</code>函数进行递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> level = <span class="hljs-number">1</span>;<br><span class="hljs-type">void</span><br><span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span>&#123;<br>    <span class="hljs-keyword">if</span>(level &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span>(level == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-keyword">if</span>(pte &amp; PTE_V)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; level; j++)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<br>                <span class="hljs-keyword">if</span>(j != level - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            uint64 child = PTE2PA(pte);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);<br>            level++;<br>            vmprint((<span class="hljs-type">pagetable_t</span>)child);<br>            level--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="detecting-which-pages-have-been-accessed">3 Detecting whichpages have been accessed</h2><p><u>任务描述</u>：检测页表是否被访问，实现<code>pgaccess</code>系统调用。</p><p><u>思路</u>：通过<code>walk</code>函数找到虚拟地址对应的<code>pte</code>，检查<code>PTE_A</code>位即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sysproc.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    uint64 base;<br>    <span class="hljs-type">int</span> len;<br>    uint64 mask;<br>    <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;base) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;len) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">2</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    uint64 start = PGROUNDDOWN(base);<br>    uint64 bitmask = <span class="hljs-number">0L</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++, start += PGSIZE)&#123;<br>        <span class="hljs-type">pte_t</span> *pte = walk(myproc()-&gt;pagetable, start, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// page not map</span><br>        uint64 flag = (*pte &amp; PTE_A) &gt;&gt; <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            *pte ^= PTE_A; <span class="hljs-comment">// clear the PTE_A</span><br>        &#125;<br>        bitmask |= (flag &lt;&lt; i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(copyout(myproc()-&gt;pagetable, mask, (<span class="hljs-type">char</span> *)&amp;bitmask, <span class="hljs-keyword">sizeof</span>(uint64)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>:zap:访问页表时将<code>PTE_A</code>置1的工作由RISC-V硬件做了，在代码中不需要自己设置。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 6.S081-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-Lab4</title>
      <link href="/2022/12/22/compilation-principle/compilation-principle-lab4/"/>
      <url>/2022/12/22/compilation-principle/compilation-principle-lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理lab4">编译原理Lab4</h1><h2 id="实验过程">实验过程</h2><p>总的来说，本次实验比较简单，只要弄清楚<code>LLVM</code>的<code>API</code>如何使用即可，核心在于编写<code>MyVisitor</code>类。</p><p>由于本次实验只涉及<code>main</code>函数以及<code>return</code>语句，并且<code>return</code>语句中的表达式都是由<code>INTEGR_CONST</code>组成，所以只需要重写函数定义、返回语句、运算表达式以及数字这几个<code>visitor</code>函数即可。整体的逻辑比较简单，这里不做详细描述。</p><h2 id="遭遇的问题">遭遇的问题</h2><p>==关于如何找到正确API==：可以写一个包含想要寻找的操作的<code>.c</code>文件，用<code>clang</code>编译成<code>.ll</code>，从中找到<code>API</code>的大致名称。比如我在写<code>%</code>运算的时候，就是通过这种方法找到<code>srem</code>操作对应的<code>API</code>。</p><p>==关于导入依赖的报错==：导了一晚上的包，最后发现有关<code>linux</code>的包还是没有导入。经过搜索后，加入阿里云镜像，并且对<code>maven</code>的<code>import</code>进行配置，得以解决。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-Lab4</title>
      <link href="/2022/12/15/nju-os-labs/OS-Lab4/"/>
      <url>/2022/12/15/nju-os-labs/OS-Lab4/</url>
      
        <content type="html"><![CDATA[<h2 id="实验要求">实验要求</h2><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201103215027.png" /></p><h2 id="源码理解">源码理解</h2><h3 id="运行源码">运行源码</h3><p><code>make run</code> 之后报错</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201105312262.png" /></p><p>和Lab3一样</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201105450390.png" /></p><h3 id="进程调度">进程调度</h3><p>在<code>kernel_main</code>函数中，为三个任务分配时间片和优先级如下</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206092451046.png" /></p><p>书中说是时钟中断每隔10ms发生一次，时钟中断处理程序如下</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206111157768.png" /></p><p>进程调度函数<code>schedule</code></p><p>调度的逻辑就是：<strong>找到剩余时间片最多（也就是优先级最高）的那个进程</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206111347873.png" /></p><h2 id="实现过程">实现过程</h2><h3id="添加一个系统调用print_strchar-s">添加一个系统调用：print_str(char*s)</h3><p>实现完毕后出现bug：</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201155257376.png" /></p><p>原因是：该系统调用需要传递参数，但是由于源代码中的<code>sys_call</code>不支持传递参数，所以报错</p><p>解决方法：修改<code>sys_call</code>的汇编代码，将<code>ebx</code>中内容压入栈中，然后再进行系统调用，这样只要将参数存放在<code>ebx</code>中即可。（后续如果需要更多参数，就对应压入更多的寄存器中的值）</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201181325369.png" /></p><h3id="添加一个系统调用sleepint-milli_seconds">添加一个系统调用：sleep(intmilli_seconds)</h3><p>该系统调用实现的是在指定的<code>milli_seconds</code>中不被分配时间片。</p><p>实现方式，手册中给了提示</p><p>1、修改<code>PROCESS</code>结构体，增加一个<code>wake_tick</code>字段，指示该进程醒来的时间片。</p><p>2、修改<code>schedule</code>函数，在进程调度时需要增加对<code>wake_tick</code>的判断，可以参与进程调度的应该是<code>wake_tick&lt;=current_tick</code>的进程。</p><h3 id="模拟读者写者">模拟读者写者</h3><blockquote><p><strong>注意点</strong></p><p>一个读进程被选中开始读一个时间片之后，另一个读进程被调入开始读的这一个时间中，前一个读进程应该仍然保持读状态，直至读结束。</p></blockquote><blockquote><p>需要实现三种策略：读者优先、写者优先、读写公平（防止饿死）</p><p>允许同时读的进程数需要能够改变（<code>n=1,2,3</code>）</p><p>每个进程读写结束之后休息的时间片可以随意修改(<spanclass="math inline">\(t \ge 0\)</span>)</p><p>（具体的PV操作以及三种策略对应的读写函数见代码）</p></blockquote><p>1、<strong>三种策略</strong></p><p>使用表驱动的实现方式，建立函数数组，依据不同的策略去调用数组中对应的读写函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// type.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(* reader_func)</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 读者函数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(* writer_func)</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 写者函数</span><br><br><span class="hljs-comment">// const.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRATEGY    3</span><br><span class="hljs-comment">// 读写策略</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READER_FIRST 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITER_FIRST 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RW_EQUALITY  2</span><br><br><span class="hljs-comment">// global.c</span><br>PUBLIC reader_func readers[STRATEGY] = &#123;<br>    reader_first_r,<br>    writer_first_r,<br>    rw_equality_r<br>&#125;;<br><br>PUBLIC writer_func writers[STRATEGY] = &#123;<br>    reader_first_w,<br>    writer_first_w,<br>    rw_equality_w<br>&#125;;<br><br><span class="hljs-comment">// main.c</span><br>strategy = READER_FIRST;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ReadB</span><span class="hljs-params">()</span>&#123;<br>readers[strategy]();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">WriteE</span><span class="hljs-params">()</span>&#123;<br>writers[strategy]();<br>&#125;<br></code></pre></td></tr></table></figure><p>2、同时读的进程数</p><p>使用一个信号量控制读者进程数量<code>r_mutex</code>，其<code>value</code>初值为<code>READER_MAX</code></p><p>3、读写之后的休息时间</p><p>在<code>PROCESS</code>结构体中增加一个<code>sleep_time</code>字段，在完成读写后调用<code>sleep</code>函数即可</p><p>4、<code>PROCESS</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s_proc</span> &#123;</span><br>...<br>        <br><span class="hljs-type">int</span> wake_tick;  <span class="hljs-comment">// 进程醒来的时间片</span><br><span class="hljs-type">int</span> state;<span class="hljs-comment">// 进程的状态</span><br><span class="hljs-type">int</span> type; <span class="hljs-comment">// 进程的类型</span><br><span class="hljs-type">int</span> run_after_sleep; <span class="hljs-comment">// 判断进程此时是否是醒来立刻运行的</span><br><span class="hljs-type">int</span> sleep_time; <span class="hljs-comment">// 进程休息的时间片数量</span><br>&#125;PROCESS;<br></code></pre></td></tr></table></figure><p>5、<strong><code>schedule</code>函数</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221217144338875.png" /></p><blockquote><p>注意：要调度<strong>所有的</strong>睡醒的进程、调度<strong>所有的</strong>结束进程释放资源、调度<strong>所有的</strong>waiting进程。因为逻辑上他们就是要同步进行的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">PUBLIC <span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span><br>&#123;<br>PROCESS* p = proc_table;<br><br><span class="hljs-keyword">if</span>(isRunnable(p))&#123; <span class="hljs-comment">// 优先选择A</span><br>p_proc_ready = p;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 先去找刚睡醒的进程，尝试调度他们</span><br><span class="hljs-keyword">for</span> (PROCESS* i = proc_table + <span class="hljs-number">1</span>; i &lt; proc_table + NR_TASKS; i++)&#123;<br><span class="hljs-keyword">if</span> (i-&gt;state == SLEEPING &amp;&amp; i-&gt;wake_tick &lt;= get_ticks())&#123;<br>i-&gt;state = RUNNING;<br>i-&gt;run_after_sleep = <span class="hljs-number">1</span>;<br>p_proc_ready = i;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 再找到tick=0的进程 去释放资源</span><br><span class="hljs-keyword">for</span> (PROCESS* i = proc_table + <span class="hljs-number">1</span>; i &lt; proc_table + NR_TASKS; i++)&#123;<br><span class="hljs-keyword">if</span> (i-&gt;ticks == <span class="hljs-number">0</span>)&#123;<br>p_proc_ready = i;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 调度waiting的进程 不用等信号量的进程</span><br><span class="hljs-keyword">for</span> (PROCESS* i = proc_table + <span class="hljs-number">1</span>; i &lt; proc_table + NR_TASKS; i++)&#123;<br><span class="hljs-keyword">if</span>(i-&gt;state == WAITING)&#123;<br>i-&gt;state = RUNNING;<br>p_proc_ready = i;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 都不存在按之前的顺序继续调度</span><br>p = prev_proc + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(!isRunnable(p))&#123;<br>p++;<br><span class="hljs-keyword">if</span>(p &gt;= proc_table + NR_TASKS)&#123;<br>p = proc_table;<br>&#125;<br>&#125;<br>p_proc_ready = p;<br>prev_proc = p;<br>&#125;<br>p_proc_ready-&gt;state = RUNNING;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：调度了刚睡醒的进程后，如果其可以成功执行，要在开始执行后停止再次执行调度函数，因为需要将结束的进程的资源返回，同时尝试开启其他进程。（<code>run_after_sleep</code>字段就是为了执行这个功能）</p></blockquote><p>6、一个问题<code>reader_max=2 &amp;&amp; sleep_time=2</code>会有一个问题：B进程结束开始睡觉，C进程睡醒，D进程在睡觉，此时<code>rw_mutex</code>被写者进程抢走。</p><p>解决：<u>先调度刚睡醒的进程，然后调度要结束的进程</u>，保证刚睡醒的进程可以和其他进程一样在结束的进程返回资源之后一起竞争。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221215210022614.png" /></p><h2 id="实验">实验</h2><h3 id="中断返回">中断返回</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221208101839093.png" /></p><p>schedule调度策略采用顺序调度，如下结果可以发现，当再次调度到A的时候是先打印的是<code>a.</code>，可见再次调度之后确实是从中断处继续执行的。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221208101741056.png" /></p><h3 id="进程调度-1">进程调度</h3><p>同样的sleep函数，一个是普通函数实现，一个是系统调用实现，结果是只有系统调用才能正确实现进程调度。</p><p>因为系统调用返回后回到<code>p_proc_ready</code>所指的进程中执行，而普通函数返回后仍然在原来函数中执行，即使<code>p_proc_ready</code>已经改变。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221208113136173.png" /></p><p><strong>奇怪的问题：</strong></p><p>右侧只是做了一些输出，结果就和左边不一样！</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221216001730954.png" /></p><p><strong>原因：</strong>在进程中直接调用了<code>schedule</code>函数改变了<code>p_proc_ready</code>，但是由于<code>schedule</code>函数在用户态执行完毕后返回原进程，就没有起到预想中的调度的作用。但是增加了一些输出就做到了，是因为输出方法是系统调用，会进入内核态，然后从内核态返回之后，就进入了<code>p_proc_ready</code>所指定的进程中执行，起到了调度的作用！</p><p>在图中红框部分，<code>0</code>和<code>t</code>本应该是<code>schedule</code>函数中相邻的两次输出，但是中间却夹着一部分字符，这一部分字符就是从第一个打印系统调用中返回后进入新的<code>p_proc_ready</code>指定的进程中执行的输出，出现乱码也应该是因为之前不正当使用<code>schedule</code>函数引起的。</p><p><strong>解决：</strong>用一个系统调用封装<code>schedule</code>函数供进程调用，修改后发现程序行为正常且一致。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221216002321372.png" /></p><h3 id="sleep和milli_delay的对比">sleep和milli_delay的对比</h3><p>对A任务进程执行 <code>milli_delay(100)</code></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206112309949.png" /></p><p>对A任务进程执行<code>sleep(100)</code></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206112729973.png" /></p><p>两者的区别就在于：对A执行<code>sleep(100)</code>后就不参与进程调度了，所以只有B和C进程参与调度；但是对A执行<code>miili_delay(100)</code>，A只是在这<code>100ms</code>中不执行任何操作而已，仍然参与进程的调度。</p>]]></content>
      
      
      <categories>
          
          <category> nju-os-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-Lab3</title>
      <link href="/2022/12/13/compilation-principle/compilation-principle-lab3/"/>
      <url>/2022/12/13/compilation-principle/compilation-principle-lab3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><ahref="http://47.122.3.40:8081/#/lab3-type-and-rename/lab3-type-and-rename">本次实验</a>主要分为两个部分：</p><p>1、对程序进行类型检查，找到所有的语义错误（11种）</p><p>2、若程序没有语义错误，则完成变量重命名后打印语法树</p></blockquote><h2 id="类型检查">类型检查</h2><h3 id="设计类型">设计类型</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221217001208028.png" /></p><h3 id="设计符号表">设计符号表</h3><p>==Symbol类==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Symbol</span>&#123;<br>    <span class="hljs-keyword">public</span> Type type;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> Scope scope;<br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-type">int</span>[]&gt; usePos;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isNeedReplace;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> row;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> col;<br>    <br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Symbol</span><span class="hljs-params">(...)</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 增加一个该符号被使用的位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUsePos</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 调试使用</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>==Scope类==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scope</span>&#123;<br>    Scope enclosingScope;<br>    Map&lt;String, Symbol&gt; symbols;<br>    List&lt;Scope&gt; childScope;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Scope</span><span class="hljs-params">(...)</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 定义一个符号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">define</span><span class="hljs-params">(Symbol symbol)</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// (全局)解析一个符号</span><br>    <span class="hljs-keyword">public</span> Symbol <span class="hljs-title function_">resolve</span><span class="hljs-params">(String name)</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// (在当前作用域下)解析一个符号</span><br>    <span class="hljs-keyword">public</span> Symbol <span class="hljs-title function_">resolveCurrentScope</span><span class="hljs-params">(String name)</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 增加一个该作用域的子作用域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addChildScope</span><span class="hljs-params">(Scope s)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后只需要在遍历语法树的过程中，在合适的位置创建作用域，并在合适的位置退出作用域，以及在函数定义、变量声明的对应处理函数中将变量包装成符号加入到作用域的符号列表中。</p><h3 id="处理语义错误">处理语义错误</h3><p>需要针对11种错误依次进行分析处理</p><table><thead><tr class="header"><th>错误编号</th><th>错误说明</th><th>分析</th></tr></thead><tbody><tr class="odd"><td>1</td><td>变量未声明</td><td>在使用变量的位置，全局解析该符号，看是否定义该变量，可在<code>visitTerminal</code>函数中处理</td></tr><tr class="even"><td>2</td><td>函数未定义</td><td>在函数调用中处理，解析被调用的函数名，查看是否被定义</td></tr><tr class="odd"><td>3</td><td>变量重复声明</td><td>在声明变量的位置：函数形参，常量声明、变量声明三个地方，<u>注意解析时只要在当前作用域下解析</u>（和全局同名变量不冲突）</td></tr><tr class="even"><td>4</td><td>函数重复定义</td><td>在函数定义的位置，解析要定义的函数名，是否已经定义过</td></tr><tr class="odd"><td>5</td><td>赋值号两侧类型不匹配</td><td>出现在有赋值符号的位置：常量声明、变量声明并初始化、赋值语句，处理方式就是取得两边的类型，进行比较判断</td></tr><tr class="even"><td>6</td><td>运算符需求类型与提供类型不匹配</td><td>出现在有运算符的地方，<u>注意下标运算符<code>[]</code></u>，处理方式也是获取操作数的类型，检查是否匹配</td></tr><tr class="odd"><td>7</td><td>返回值类型不匹配</td><td>出现在返回语句中，由于函数类型只有<code>int</code>和<code>void</code>，如果没有返回值判断是否是<code>void</code>，如果有返回值就需要判断<code>return</code>后面的表达式返回的类型是否为<code>int</code></td></tr><tr class="even"><td>8</td><td>函数参数不适用</td><td>出现在函数调用中，可以先判断形参数量和实参数量，如果相同再进行一个一个的检查判断</td></tr><tr class="odd"><td>9</td><td>对非数组使用下标运算符</td><td>在出现下标运算符时检查变量是否是数组类型，<u>注意对数组类型变量使用超过其维数的下标运算符个数</u>（例如对一维数组使用两个下标运算符）</td></tr><tr class="even"><td>10</td><td>对变量使用函数调用</td><td>出现在函数调用中，判断变量类型是否是函数类型</td></tr><tr class="odd"><td>11</td><td>赋值号左侧非变量或数组元素</td><td>出现在左值表达式中，如果是赋值语句，判断左侧的符号类型是否为函数类型</td></tr></tbody></table><blockquote><p>这一部分最麻烦的是，一个错误会引起连锁错误，但是要求只打印"最本质错误"。</p><p>我在处理的过程中采用：一旦出现错误之后，返回的类型都是<code>null</code>，而上层的函数只有在下层函数不返回<code>null</code>是才会在这一层进行错误检查，否则直接返回。但是需要注意的是，不是每一个函数返回null都代表出现错误，还需要结合具体情况分析，不过大部分都适用。</p></blockquote><h2 id="重命名">重命名</h2><blockquote><p>为所有与选中变量<strong>生命周期一致</strong>的<strong>同名变量</strong>重命名</p></blockquote><p>思路：</p><p>在第一次遍历语法树的过程中，解析变量之后将该变量的位置加入到符号的<code>usePos</code>列表中，并且找到需要重命名的那个变量(<code>isNeedReplace</code>)。在第二次遍历过程中，将需要重命名的那个符号的<code>usePos</code>取出，遍历到对应位置后进行重命名即可。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221217105317387.png" /></p><h2 id="碰到的问题">碰到的问题</h2><p>感觉比较困难的地方主要还是在第一部分语义错误检查，因为出错了之后需要自己想用例去排查，而且“最本质错误”的要求导致bug比较难以找到。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-Lab2</title>
      <link href="/2022/11/24/compilation-principle/compilation-principle-lab2/"/>
      <url>/2022/11/24/compilation-principle/compilation-principle-lab2/</url>
      
        <content type="html"><![CDATA[<blockquote><p><ahref="http://47.122.3.40:8081/#/lab2-parser/lab2-parser">实验内容</a>：编写SysY语言的语法分析器，并实现高亮。</p></blockquote><h2 id="实验思路">实验思路</h2><p>首先需要根据<ahref="https://github.com/courses-at-nju-by-hfwei/compilers-lab-docs/raw/main/docs/docs/SysY%E8%AF%AD%E8%A8%80%E5%AE%9A%E4%B9%89.pdf">SysY语言定义</a>编写Parser，这部分基本上就是将手册上的语法规则改写成<code>Antrl</code>语句即可。</p><p>然后就可以到<code>Main</code>类中编写相应的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span>(args.length == <span class="hljs-number">0</span>)&#123;<br>            System.err.println(<span class="hljs-string">&quot;input path is required&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// get input file and generate the Lexer</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">CharStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> CharStreams.fromFileName(source);<br>        <span class="hljs-type">SysYLexer</span> <span class="hljs-variable">sysYLexer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysYLexer</span>(input);<br><br>        <span class="hljs-comment">// generate the Parser</span><br>        <span class="hljs-type">CommonTokenStream</span> <span class="hljs-variable">tokens</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonTokenStream</span>(sysYLexer);<br>        <span class="hljs-type">SysYParser</span> <span class="hljs-variable">sysYParser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysYParser</span>(tokens);<br><br>        <span class="hljs-type">Visitor</span> <span class="hljs-variable">visitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Visitor</span>();<br><br>        <span class="hljs-comment">// add error listener</span><br>        sysYParser.removeErrorListeners();<br>        <span class="hljs-type">MyParserErrorListener</span> <span class="hljs-variable">myParserErrorListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyParserErrorListener</span>(visitor);<br>        sysYParser.addErrorListener(myParserErrorListener);<br><br>        <span class="hljs-comment">// DFS the tree</span><br>        <span class="hljs-type">ParseTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> sysYParser.program();<br>        visitor.visit(tree);<br>    &#125;<br></code></pre></td></tr></table></figure><p>类似于Lab1，需要实现一个自定义的<code>ErrorListener</code>，传递给<code>Parser</code>，使得在发现语法错误时执行报错输出。</p><blockquote><p>为什么要传递<code>Visitor</code>?</p><p>由于一旦出现语法错误，就不需要打印语法树了，所以需要在<code>ErrorListener</code>监听到语法错误时让<code>Visitor</code>不要做输出。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyParserErrorListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseErrorListener</span>&#123;<br>    Visitor visitor;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyParserErrorListener</span><span class="hljs-params">(Visitor v)</span>&#123; <span class="hljs-built_in">this</span>.visitor = v; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syntaxError</span><span class="hljs-params">(Recognizer&lt;?, ?&gt; recognizer,</span><br><span class="hljs-params">                            Object offendingSymbol,</span><br><span class="hljs-params">                            <span class="hljs-type">int</span> line,</span><br><span class="hljs-params">                            <span class="hljs-type">int</span> charPositionInLine,</span><br><span class="hljs-params">                            String msg,</span><br><span class="hljs-params">                            RecognitionException e)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.visitor.hasError = <span class="hljs-literal">true</span>;<br>        System.err.println(<span class="hljs-string">&quot;Error type B at Line &quot;</span> + line + <span class="hljs-string">&quot;: &quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后也是最关键的，编写继承自<code>SysYParserBaseVisitor&lt;Void&gt;</code>的<code>Visitor</code>，实现打印语法树以及高亮的功能。</p><ol type="1"><li>如何打印节点信息：在<code>visitChildren</code>和<code>visitTerminal</code>两个函数中，调用参数<code>node</code>的相关方法就可以获得<code>type</code>、<code>text</code>等信息。</li><li>如何实现缩进：存在<code>depth</code>字段，调用<code>node.getRuleContext().depth()</code>获得；注意在<code>visitTerminal</code>函数中需要强转一下类型。</li><li>如何实现高亮：在<code>SysYParser</code>中找到对应的存放节点类型的数组，将数组中的值修改为对应的颜色值，每次根据<code>type</code>获取对应颜色。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SysYParserBaseVisitor</span>&lt;Void&gt;&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasError</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type &lt; <span class="hljs-number">0</span> || type &gt;= _COLOR_NAMES.length) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> _COLOR_NAMES[type];<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] _COLOR_NAMES = &#123;<br>            <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;[orange]&quot;</span>, <span class="hljs-string">&quot;[orange]&quot;</span>, <span class="hljs-string">&quot;[orange]&quot;</span>, <span class="hljs-string">&quot;[orange]&quot;</span>, <span class="hljs-string">&quot;[orange]&quot;</span>, <span class="hljs-string">&quot;[orange]&quot;</span>, <span class="hljs-string">&quot;[orange]&quot;</span>, <span class="hljs-string">&quot;[orange]&quot;</span>,<br>            <span class="hljs-string">&quot;[orange]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>,<br>            <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;[blue]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;[green]&quot;</span>,<br>            <span class="hljs-string">&quot;[red]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br>    &#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printIndents</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; depth * <span class="hljs-number">2</span>; i++)&#123;<br>            System.err.print(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visitChildren</span><span class="hljs-params">(RuleNode node)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ruleIdx</span> <span class="hljs-operator">=</span> node.getRuleContext().getRuleIndex();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> SysYParser.ruleNames[ruleIdx];<br>        <span class="hljs-keyword">if</span> (!hasError)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> node.getRuleContext().depth();<br>            printIndents(depth-<span class="hljs-number">1</span>); <span class="hljs-comment">// need -1: depth begin from 1</span><br>            System.err.println(rule.toUpperCase().charAt(<span class="hljs-number">0</span>) + rule.substring(<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitChildren(node);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visitTerminal</span><span class="hljs-params">(TerminalNode node)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> node.getSymbol().getType(); <span class="hljs-comment">// node type</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> getColor(type);<br>        <span class="hljs-keyword">if</span> (!hasError &amp;&amp; !color.equals(<span class="hljs-string">&quot;&quot;</span>))&#123; <span class="hljs-comment">// &quot;&quot; means the terminal node we need, such as &#x27;&#123;&#x27; &#x27;&#125;&#x27;</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">literal_name</span> <span class="hljs-operator">=</span> node.toString();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">symbol_name</span> <span class="hljs-operator">=</span> SysYParser.VOCABULARY.getSymbolicName(type);<br>            <span class="hljs-comment">// deal with numbers</span><br>            <span class="hljs-keyword">if</span> (type == SysYParser.INTEGR_CONST)&#123;<br>                literal_name = convert_to_dec(literal_name);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> ((RuleNode)node.getParent()).getRuleContext().depth(); <span class="hljs-comment">// the depth in parser tree</span><br>            printIndents(depth);<br>            System.err.println(literal_name + <span class="hljs-string">&quot; &quot;</span> + symbol_name + color);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">convert_to_dec</span><span class="hljs-params">(String number)</span>&#123;<br>        <span class="hljs-keyword">if</span> (number.equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            number = <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (number.startsWith(<span class="hljs-string">&quot;0x&quot;</span>) || number.startsWith(<span class="hljs-string">&quot;0X&quot;</span>))&#123;<br>            number = Integer.parseInt(number.substring(<span class="hljs-number">2</span>), <span class="hljs-number">16</span>) + <span class="hljs-string">&quot;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (number.startsWith(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            number = Integer.parseInt(number.substring(<span class="hljs-number">1</span>), <span class="hljs-number">8</span>) + <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="碰到的问题">碰到的问题</h2><h3 id="缩进">缩进</h3><p>如何按层次缩进是做实验的时候碰到的最大的一个问题。一开始没想到会有<code>depth</code>字段，一直在想如何通过一个变量来标记层次，结果一直没有成功，因为两个<code>visit</code>函数都是进入节点之前调用，而没有对应的离开后调用的函数，所以不能通过在两个函数内的增减变化实现层次的变化（也许<code>Listener</code>应该是可以的）</p><h3 id="拼写">拼写</h3><p><code>INTEGR_CONST</code>。测试的时候看它输出在文件里报拼写错误，还以为是自己写错了，全部改成<code>INTEGER_CONST</code>，结果<code>OJ</code>过不了，后来发现在<code>Lab1</code>的<code>Lexer</code>中写的就是<code>INTEGR_CONST</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-Lab3</title>
      <link href="/2022/11/21/nju-os-labs/OS-Lab3/"/>
      <url>/2022/11/21/nju-os-labs/OS-Lab3/</url>
      
        <content type="html"><![CDATA[<h2 id="准备">准备</h2><p>实验以《orange's：一个操作系统的实现》的<ahref="https://github.com/wlmnzf/oranges/tree/master/chapter7/o">代码</a>为基础</p><h3 id="运行">运行</h3><h4 id="问题1">问题1</h4><p>make image失败</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221108200704537.png" /></p><p>解决方法</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221108200905099.png" /></p><p>结果</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221108201025947.png" /></p><h4 id="问题2">问题2</h4><p><code>make image</code>结束之后，执行下面的命令失败</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bochs -f bochsrc</span><br></code></pre></td></tr></table></figure><p>报错信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dlopen failed for module &#x27;x&#x27;: file not found<br></code></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install bochs-x<br></code></pre></td></tr></table></figure><p>结果显示</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221108201337846.png" /></p><h3 id="已实现和待实现">已实现和待实现</h3><h4 id="已实现">已实现</h4><ol type="1"><li>从屏幕左上角开始，以白色显示键盘输入的字符，可以输入并显示a-z,A-Z和0-9字符。</li><li>支持大小写切换包括 Shift 组合键以及大写锁定两种方式，大写锁定后再用Shift 组合键将会输入小写字母</li><li>支持回车键换行</li><li>支持用退格键删除输入内容</li><li>支持空格键</li><li>有光标显示</li><li>输入字符无上限</li></ol><h4 id="待实现">待实现</h4><ul class="task-list"><li><label><input type="checkbox" checked="" />make run直接运行</label></li><li><label><input type="checkbox" checked="" />支持Tab键</label></li><li><label><input type="checkbox"checked="" />清空屏幕以及每隔20秒清空屏幕</label></li><li><label><input type="checkbox"checked="" />退格换行和TAB需要一次完成</label></li><li><label><input type="checkbox" checked="" />查找功能</label></li><li><label><input type="checkbox" checked="" />control + z组合键撤回</label></li></ul><h2 id="理解代码">理解代码</h2><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112082935878.png" /></p><p>首先，需要理解代码，可以照着《orange's：一个操作系统的实现》第七章的讲解一起看。</p><p>输出一个字符的函数调用逻辑</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221110203047699.png" /></p><p>当初始化结束后，就会进入到<code>task_tty()</code>函数中，进行不断的循环。</p><h3id="探究console结构体中四个变量的含义">探究CONSOLE结构体中四个变量的含义</h3><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111162034665.png" /></p><p><strong>分析过程</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111090406115.png" /></p><p><u>屏幕一行80个字符，屏幕总共25行。</u></p><p>在敲字符过程中，<u><code>cursor</code>在不断加1</u>，<u><code>original_addr</code>始终为<code>0x0</code></u>，<code>current_start_addr</code>是<u>当前屏幕可见范围的开始位置</u>距离<u>最开始显示位置</u>的偏移。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111091301955.png" /></p><p>按到最后</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111162617930.png" /></p><p>可以发现<code>cursor</code>的值最大只能到<code>0x1554</code>，因为被<code>v_mem_limit</code>所限制。</p><p>经过分析就可以基本确定CONSOLE结构体四个变量的含义，用一张图来表示一下</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111164821213.png" /></p><h2 id="实现功能">实现功能</h2><h3 id="tab">TAB</h3><p>在<code>keyboard.h</code>中可以发现TAB是一个不可显示的字符，所以在<code>tty.c</code>的<code>in_process</code>中要增加对于<code>TAB</code>的识别，将其放进缓冲区内。然后在<code>console.c</code>的<code>out_char</code>函数中增加对<code>\t</code>的输出处理。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112160733005.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112160949600.png" /></p><h3 id="清屏">清屏</h3><p>清屏的功能实现在逻辑上比较简单，只要不断地调用<code>out_char()</code>函数，传入<code>\b</code>，直到<code>cursor</code>回到<code>original_addr</code>位置。</p><p>但是如何在实现每20秒清屏一次呢？要理解<code>kernel_main()</code>函数中的任务，可以新增一个任务，<code>task_clear_screen</code>，然后在其中执行清屏任务，并且每次执行完毕后延迟20s。</p><p>1、将<code>task_clear_screen</code>声明成一个任务，不断执行</p><p>在<code>global.c</code>中做相应修改，并修改对应的宏</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112161118740.png" /></p><p>2、在<code>task_clear_screen</code>任务中完成清屏逻辑，并且延迟20s</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111215247007.png" /></p><blockquote><p>每个任务中while循环不能break，否则执行会报错。</p></blockquote><h3 id="退格一次完成">退格一次完成</h3><p>源代码的删除功能只实现了一个一个删除，即使是对于<code>\n</code>和<code>\t</code>也是如此，不符合实际情况，需要做修改，实现一次删除<code>\t</code>和<code>\n</code>。</p><p><strong>思路</strong></p><p>要想实现一次退格，就需要知道前一个字符是什么，如果是普通字符那么让光标位置减一即可，如果是特殊的<code>\n</code>和<code>\t</code>就需要特殊处理，使光标回到按下<code>\n</code>和<code>\t</code>前的位置。</p><p>对于<code>\t</code>还好说，只要把光标减4即可；但是对于<code>\n</code>来说，就有点麻烦了。</p><p>一开始，想让光标一直往回移动直到遇到不是空格的字符。但是如果在输入<code>\n</code>之前刚输入了空格呢？这样显然就不对，而且实现起来还很复杂。</p><p>所以需要借助新的数据结构来存储已经显示的字符，并且对显示的字符做一个包装，做成一个结构体。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111192544494.png" /></p><p>再构建一个存储当前屏幕中所有显示的字符的结构体</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111192521635.png" /></p><p>然后需要在适当的地方将这个数据结构插入</p><p><strong>过程</strong></p><p>1、初始化C_BUF结构体</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193022381.png" /></p><p>2、在将字符放入TTY中的同时，也将封装起来的字符放进C_BUF中</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193053341.png" /></p><p>3、<strong>在<code>out_char</code>函数中实现对应逻辑</strong></p><p>在其他输出字符的位置需要加上对CHAR结构体中before_cursor和after_cursor的赋值，例如：</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193614434.png" /></p><p>然后在处理退格键时就可以用如下一段代码解决</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193431518.png" /></p><p>4、显示字符结束后，需要修改C_BUF中的<code>buf_cur_idx</code></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193124708.png" /></p><p><strong>这么设计就可以把所有的字符统一起来处理，在退格时只要回到按下该键前的光标位置即可。</strong></p><blockquote><p>注意需要把p_cbuf作为全局变量声明，这样可以在所有文件中使用，而不用作为函数参数传来传去。</p><p><u>在global.c和global.h中做声明即可</u></p></blockquote><h3 id="查找功能">查找功能</h3><p><strong>思路</strong></p><p>明确几个状态(代码也是依据状态编写的)</p><p>1、正常状态。以黑底白字显示字符，一切正常</p><p>2、搜索状态。在正常状态按下esc后，<u>以黑底红字显示字符</u>，并<u>记录这段时间敲下的字符</u>。</p><p>3、匹配状态。搜索状态按下enter后，进行match，思路是<u>从头遍历C_BUF结构体数组，找到匹配的字符串后把相应的字符颜色改成黑底红字，再从头显示</u>。</p><p>4、从匹配态退出。<u>删去搜索字符串</u>，<u>把黑底红字的改成黑底白字</u>，<u>重新显示</u>。</p><p><strong>过程</strong></p><p>1、定义一些全局变量和常量，对CHAR结构体进行调整(增加color字段)</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145803256.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112144313280.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112144339441.png" /></p><p>状态的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">INIT(按ESC) -&gt; SEARCH(按Enter) -&gt; MATCH(按ESC) -&gt; INIT<br></code></pre></td></tr></table></figure><p>2、在每个状态编写相应逻辑</p><p><strong>INIT</strong></p><p>在<code>in_process</code>函数中增加对ESC的识别</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112144935869.png" /></p><p>这个初始化要小心，每次进入搜索状态都要进行初始化</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145609113.png" /></p><p><strong>SEARCH</strong></p><p>改变in_process中对Enter键的处理</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145035952.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145542894.png" /></p><p><strong>MATCH</strong></p><p>在in_process函数开头加上判断，只接收ESC</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145201780.png" /></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145515851.png" /></p><p>在out_char函数中也要做相应处理</p><p>1、MATCH状态下是不需要向C_BUF数组中增添CHAR的，只做输出。</p><p>2、SEARCH状态下要记录搜索字符串，并且注意SEARCH状态下是黑底红色。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145247460.png" /></p><blockquote><p>注意：在退格搜索字符串时(<code>SEARCH</code>状态)，不能将原来的字符串删除。</p></blockquote><h3 id="controlz撤销">control+z撤销</h3><p>这个也很简单，首先要判断出是否是按下<code>ctrl+z</code>组合键，然后执行退格操作即可。</p><p>似乎没有那么简单，因为既要撤销显示出来的字符，还要撤销删除，以及需要能够一直撤销直到初始状态。</p><p>想法1：再建立一个ACTION的列表，记录所有的操作。但是实现起来可能比较复杂，因为需要同步好几个数据结构数组之间的关系。</p><p>想法2：改造C_BUF数据结构。其实撤销的主要难点在于撤销退格，所以在C_BUF中使用两个指针。也不行，可操作性不高，指针移动比较复杂。</p><p>最终采用想法1，需要理清ACTION数组在什么位置更新！</p><p>1、创建数据结构</p><p>其中<code>MAX_ACTION</code>为1000，即支持大约1000次撤销。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112155756326.png" /></p><p>2、初始化ACTION列表</p><p>在task_tty函数中调用初始化函数即可</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112155904351.png" /></p><p>3、向列表中增加ACTION</p><p>经过思考，选在tty_do_write函数的out_char后面</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112160009078.png" /></p><p>4、撤销操作</p><p>在in_process函数中增加以下逻辑，就是在判断出是<code>Ctrl+z</code>组合键后，回退ACTION数组，做逆操作。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112160101647.png" /></p><blockquote><p>注意虚拟机中的热键 VirtualBox默认是 Right Ctrl</p><p>导致Right Ctrl按不出来</p></blockquote><h3 id="总结">总结</h3><p>由于上面的描述是写完一个功能后立刻写下的，所以导致代码前后会出现不一致。</p><p>感觉十分重要的调整是 【将字符加进C_BUF结构体中buf 】的位置 和 【更新C_BUF结构体中 buf_cur_idx】 的位置，最后是都放在了out_char函数中。</p>]]></content>
      
      
      <categories>
          
          <category> nju-os-labs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记11--面试必知必会</title>
      <link href="/2022/11/19/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B011%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89/"/>
      <url>/2022/11/19/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B011%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="nsum问题">nSum问题</h2><blockquote><p>nSum问题就是给定一个整数数组 <code>nums</code> 和一个<code>target</code>，要求找到 <code>n</code>个<code>nums</code>中的元素，使得这<code>n</code>个元素的和等于<code>target</code>，要求返回所有可能的不重复的情况。</p></blockquote><p>【2Sum】问题是这类的基本情况，将数组排序后使用双指针即可解决问题。对于<spanclass="math inline">\(n &gt;2\)</span>的情况，尤其是<code>n</code>比较大时，直接解决是比较困难的，可以采用==递归==解决。下面给出解决【nSum】问题的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** </span><br><span class="hljs-comment">nums: sorted之后的数组</span><br><span class="hljs-comment">start: 开始寻找的位置</span><br><span class="hljs-comment">k: 需要寻找多少个元素之和</span><br><span class="hljs-comment">target: 目标值</span><br><span class="hljs-comment">*/</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">nSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// base case k ==</span><br>        <span class="hljs-type">int</span> i = start; <span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-type">int</span> left = nums[i]; <span class="hljs-type">int</span> right = nums[j];<br>            <span class="hljs-type">int</span> sum = left + right;<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                res.<span class="hljs-built_in">push</span>(&#123;left, right&#125;);<br>                <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == left) i++;<br>                <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == right) j--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == right) j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == left) i++;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// other case k &gt; 2</span><br>        <span class="hljs-type">int</span> i = start;<br>        <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>            <span class="hljs-type">int</span> val = nums[i];<br>            <span class="hljs-type">int</span> sub_target = target - val;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sub_res = <span class="hljs-built_in">nSum</span>(nums, i+<span class="hljs-number">1</span>, k<span class="hljs-number">-1</span>, sub_target);<br>            <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt; sub_res_i : sub_res)&#123;<br>                sub_res_i.<span class="hljs-built_in">push_back</span>(val);<br>                res.<span class="hljs-built_in">push_back</span>(sub_res_i);<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; nums[i] == val) i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间问题">区间问题</h2><blockquote><p>区间问题就是给定一些区间，然后需要求解这些区间的交集、或者合并区间等问题</p></blockquote><p>解决这类问题最核心的思想就是==排序==+==讨论==。</p><p>针对不同的问题，需要进行不同的排序，可能是对起点排序，也可能是对终点排序，有可能是升序，也有可能是降序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 对nums进行排序，左端点升序排列，左端点相同右端点降序排列</span><br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), cmp);<br></code></pre></td></tr></table></figure><blockquote><p>题目列表：</p><p><ahref="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球</a></p><p><ahref="https://leetcode.cn/problems/non-overlapping-intervals/">435.无重叠区间</a></p><p><ahref="https://leetcode.cn/problems/remove-covered-intervals/">1288.删除被覆盖区间</a></p><p><a href="https://leetcode.cn/problems/merge-intervals/">56.合并区间</a></p><p><ahref="https://leetcode.cn/problems/interval-list-intersections/">986.区间列表的交集</a></p></blockquote><blockquote><p><a href="https://leetcode.cn/problems/video-stitching/">1024.视频拼接</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230105224256015.png" /></p></blockquote><p>一道别致的区间问题！这道题在对区间进行排序之后的操作更为复杂一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; clips, <span class="hljs-type">int</span> time)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(clips.<span class="hljs-built_in">begin</span>(), clips.<span class="hljs-built_in">end</span>(), cmp);<br>    <br>    <span class="hljs-comment">// 由于是需要找出最少，所以就需要挑选出最合适的片段</span><br>    <span class="hljs-type">int</span> n = clips.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 在后面有重叠的区间中找到终点最大的那个区间</span><br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; clips[i][<span class="hljs-number">0</span>] &lt;= end)&#123;<br>            <span class="hljs-keyword">if</span> (clips[i][<span class="hljs-number">1</span>] &gt; max) max = clips[i][<span class="hljs-number">1</span>];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(max == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 中间有断开或者片段用完了但是没到time</span><br>        end = max;<br>        cnt ++;<br>        <span class="hljs-keyword">if</span> (end &gt;= time) <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速选择算法">快速选择算法</h2><blockquote><p><ahref="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215.数组中的第K个最大元素</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127115141557.png" /></p></blockquote><h3 id="快速排序算法">快速排序算法</h3><p>快排（quick-sort）是一种经典的排序算法，和归并排序（merge-sort）一样都是divide-and-conquer 类型的算法，平均时间复杂度为 <spanclass="math inline">\(O(NlogN)\)</span></p><p>【思路】</p><p>快排的思路是，要对<code>nums[lo...hi]</code>排序，先找到一个分界点<code>pivot</code>，然后使得<code>nums[lo...pivot-1]</code>都小于<code>nums[pivot]</code>，<code>nums[pivot+1...hi]</code>都大于<code>nums[pivot]</code>，然后递归地在<code>nums[lo...pivot-1]</code>和<code>nums[pivot+1...hi]</code>上执行相同的操作。</p><p>【实现过程】</p><p>首先可以轻易写出下面两个函数，最主要的难点是实现<code>partition</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>    <span class="hljs-built_in">quick_sort_helper</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort_helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i &gt;= j) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(nums, i, j);<br>    <span class="hljs-built_in">quick_sort_helper</span>(nums, i, pivot<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">quick_sort_helper</span>(nums, pivot+<span class="hljs-number">1</span>, j);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>partition</code>函数所做的工作就是，对一个数组<code>nums[lo...hi]</code>，返回一个下标<code>pivot</code>，使得数组<code>nums[lo...pivot-1]</code>部分的元素全部都小于<code>nums[pivot]</code>，数组<code>nums[pivot+1...hi]</code>部分的元素全部都大于<code>nums[pivot]</code>。</p><blockquote><ol type="1"><li>首先任意选取一个值作为pivot，比如选择最后一个元素`</li><li><code>smaller_idx</code>变量是用来记录所有<code>&lt;=nums[pivot]</code>的元素的下标</li><li>遍历数组，当遇到<code>&lt;=nums[pivot]</code>的元素时，就要把它放在<code>smaller_idx</code>指定的位置上（for循环中if块中的内容）</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot = nums[hi];<br>    <span class="hljs-type">int</span> smaller_idx = lo<span class="hljs-number">-1</span>; <span class="hljs-comment">// 标记&lt;=nums[pivot]元素的下标</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = lo; i &lt;= hi; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &lt;= pivot)&#123;<br>            smaller_idx ++;<br>            <span class="hljs-built_in">swap</span>(nums, smaller_idx, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> smaller_idx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-type">int</span> tmp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><ahref="https://www.geeksforgeeks.org/quick-sort/">quick-sort</a></p></blockquote><p>上面的<code>partition</code>函数返回的<code>pivot</code>其实就是数组的第<code>pivot</code>大元素，而问题需要的是第<code>k</code>大元素，所以可以借用【二分搜索】思想进行求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> lo = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> hi = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> idx = nums.<span class="hljs-built_in">size</span>() - k;<br>    <span class="hljs-keyword">while</span>(lo &lt;= hi)&#123;<br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(nums, lo, hi);<br>        <span class="hljs-keyword">if</span>(idx &gt; pi)&#123;<br>            lo = pi+<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idx &lt; pi)&#123;<br>            hi = pi<span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> nums[pi];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉堆">二叉堆</h3><p>这道题最简单的还是采用二叉堆（优先队列）的解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq; <span class="hljs-comment">// 采用小顶堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)&#123;<br>        pq.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt; k)&#123;<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><font color='red'><code>priority_queue</code>数据结构自定义比较如何书写？</font></p><p>1、首先优先队列默认情况下是使用less比较，即大顶堆（最大元素作为堆顶出现）。如果想要改成小顶堆，需要使用greater比较。</p><p>2、如果要自定义优先队列的比较，可以在一个<strong>结构体</strong>里==重载()运算符==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>      <span class="hljs-comment">// ...</span><br>  &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><p>3、或者可以重载复合数据类型的比较运算符（改变原本less和greater中比较运算符的含义）</p><p><font color='red'>sort函数中的自定义比较应该如何书写？</font></p><p>1、默认情况下按照升序对容器内元素进行排序。</p><p>2、一般情况下只要重写一个比较函数传入sort函数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-built_in">sort</span>(container.<span class="hljs-built_in">begin</span>(), container.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// container 是 vector&lt;vector&lt;int&gt;&gt;</span><br></code></pre></td></tr></table></figure><p><strong>但是如果要在类中使用，自定义的比较函数一定得是静态成员函数或者全局函数</strong></p><p>因为<code>std::sort</code>函数是全局的，不能依赖于只有创建实例后才能使用的普通成员函数</p></blockquote><h2 id="运算优先级分治算法">运算优先级：分治算法</h2><blockquote><p><ahref="https://leetcode.cn/problems/different-ways-to-add-parentheses/">241.为运算表达式设计优先级</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230104002637818.png" /></p></blockquote><p>使用递归思想解决问题，一定要从整体出发考虑问题的结构，而不能局限于某个细节。将大问题不断分解成规模更小的子问题，当规模小到一定程度时就可以轻易求解，然后再将小规模问题的答案合并，得到最终问题的结果，这就是分治的思想。</p><p>这道题也是一样，给定一个表达式字符串，要求出该表达式所有可能的结果。无论如何改变运算符优先级，或者说增加括号，本质上表达式的计算都可以回到【操作数1操作符操作数2】这种形式上，只是这个操作数可以又是一个表达式，以此来增加复杂度。</p><p>如何分解复杂度呢？可以选定一个操作符，然后递归处理两边的表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string expression)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-type">int</span> n = expression.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">char</span> c = expression[i];<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i));<br>            vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>, n - i));<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> op1 : left)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> op2 : right)&#123;<br>                    <span class="hljs-keyword">switch</span>(c)&#123;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: res.<span class="hljs-built_in">push_back</span>(op1+op2); <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: res.<span class="hljs-built_in">push_back</span>(op1-op2); <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: res.<span class="hljs-built_in">push_back</span>(op1*op2); <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            val = <span class="hljs-number">10</span> * val + expression[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心算法">贪心算法</h2><h3 id="加油站">加油站</h3><blockquote><p><a href="https://leetcode.cn/problems/gas-station/">134.加油站</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230105224152317.png" /></p></blockquote><p>看到问题的一个反应就是把两个数组变成一个数组<code>diff</code>，<code>diff[i]</code>表示在<code>i</code>加油站加完油开到<code>i+1</code>加油站的油量变化。那么要找到那个点，应该尽可能的让车在刚开始一段时间油量尽可能多，这样才能保证最后可以走完一圈。可以将<code>diff</code>的值标在图上，连起来之后最低点的下一个点就应该是出发的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = gas.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; diff; <span class="hljs-comment">// 从i加完油开到i+1剩下的油量</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> onediff = gas[i] - cost[i];<br>        diff.<span class="hljs-built_in">push_back</span>(onediff);<br>        sum += onediff;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> min = <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>        total += diff[i];<br>        <span class="hljs-keyword">if</span> (total &lt; min)&#123;<br>            min = total;<br>            res = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (res+<span class="hljs-number">1</span>)%n;<br>&#125;<br></code></pre></td></tr></table></figure><p>换一个思路，这道题更为普遍的想法应该是用一个双重循环去枚举所有的情况。可以增加一个<code>trick</code>：<strong>当发现从<code>i</code>开到<code>j</code>不能到达时，那么<code>i</code>到<code>j</code>中间的任何一个点出发都行不通</strong>。这样就避免了很多重复的情况，复杂度可以达到线性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span></span>&#123;<br>    <span class="hljs-type">int</span> n = gas.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; diff; <span class="hljs-comment">// 从i加完油开到i+1剩下的油量</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> onediff = gas[i] - cost[i];<br>        diff.<span class="hljs-built_in">push_back</span>(onediff);<br>        sum += onediff;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (diff[i] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> j = (i+<span class="hljs-number">1</span>)%n;<br>        <span class="hljs-type">int</span> total = diff[i];<br>        <span class="hljs-keyword">for</span> (; j != i; j = (j+<span class="hljs-number">1</span>)%n)&#123;<br>            total += diff[j];<br>            <span class="hljs-keyword">if</span>(total &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == i) <span class="hljs-keyword">return</span> i;<br>        i = (j + n - <span class="hljs-number">1</span>) % n; <span class="hljs-comment">// trick</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割数组为连续子序列">分割数组为连续子序列</h3><blockquote><p><ahref="https://leetcode.cn/problems/split-array-into-consecutive-subsequences/">659.分割数组为连续子序列</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230110180018694.png" /></p></blockquote><p>贪心算法：要想满足上述条件，<strong>应该使得每个子序列尽可能地长，即尽可能不要建造新的子序列</strong>。</p><p>所以当遍历到<code>nums</code>中<code>x</code>时，判断是否有以<code>x-1</code>结尾的子序列，如果有：将<code>x</code>加在子序列的后面；如果没有：看<code>x+1</code>和<code>x+2</code>这两个数字是否还有，如果还有，则建造一个以<code>x+2</code>结尾的子序列，如果没有，则返回<code>false</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPossible</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt; <span class="hljs-comment">// 存储nums中每个数字的个数</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; endx; <span class="hljs-comment">// 存储以x结尾的子序列的个数</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) cnt[num] ++;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>        <span class="hljs-keyword">if</span> (cnt[x] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 该数字还有</span><br>            <span class="hljs-keyword">if</span> (endx[x<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 存在以x-1结尾的子序列</span><br>                endx[x<span class="hljs-number">-1</span>] --;<br>                endx[x] ++;<br>                cnt[x] --;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 不存在以x-1结尾的子序列</span><br>                <span class="hljs-keyword">if</span> (cnt[x+<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; cnt[x+<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                    endx[x+<span class="hljs-number">2</span>]++;<br>                    cnt[x]--; cnt[x+<span class="hljs-number">1</span>]--; cnt[x+<span class="hljs-number">2</span>]--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计算器">计算器</h2><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator/">224.基本计算器</a></p><p><a href="https://leetcode.cn/problems/basic-calculator-ii/">227.基本计算器 II</a></p></blockquote><p>给定一个字符串，包含数字、四则运算符、括号以及空格，要求计算该表达式的值</p><p>可以将这个问题进行分解，比如：如何将字符串中的数提取出来、如何处理四则运算以及如何处理括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> sign = <span class="hljs-string">&#x27;+&#x27;</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>        <span class="hljs-comment">// 处理字符串中的数字</span><br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            val = <span class="hljs-number">10</span> * val + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 处理四则运算</span><br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span> || s[i] == <span class="hljs-string">&#x27;-&#x27;</span> || s[i] == <span class="hljs-string">&#x27;*&#x27;</span> || s[i] == <span class="hljs-string">&#x27;/&#x27;</span> || i == n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">switch</span>(s[i])&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: stk.<span class="hljs-built_in">push</span>(val); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span> * val); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: val = stk.<span class="hljs-built_in">top</span>() * val; stk.<span class="hljs-built_in">pop</span>(); stk.<span class="hljs-built_in">push</span>(val); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: val = stk.<span class="hljs-built_in">top</span>() / val; stk.<span class="hljs-built_in">pop</span>(); stk.<span class="hljs-built_in">push</span>(val); <span class="hljs-keyword">break</span>;<br>            &#125;<br>            val = <span class="hljs-number">0</span>;<br>            sign = s[i];<br>        &#125;<br>        <span class="hljs-comment">// 处理括号</span><br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> start = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(cnt != <span class="hljs-number">0</span>)&#123;<br>                i ++;<br>                <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) cnt ++;<br>                <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) cnt --;<br>            &#125;<br>            val = <span class="hljs-built_in">calculate</span>(s.<span class="hljs-built_in">substr</span>(start, i - start)); <span class="hljs-comment">// 递归</span><br>        &#125;<br>        <br>        i ++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;<br>        res += stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完美矩形">完美矩形</h2><blockquote><p><a href="https://leetcode.cn/problems/perfect-rectangle/">391.完美矩形</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230111192906031.png" /></p><p><u>精确覆盖</u>的意思是：这些小矩形可以恰好组成一个大矩形，中间不能有重叠，也不能有空隙。</p></blockquote><ul><li>首先，很明显可以从<strong>面积</strong>出发。找到组成的大矩形的顶点，算出大矩形的面积，如果小矩形面积之和不等于大矩形面积的话，肯定实现不了。</li><li>其次，尽管算出来面积是相等的，也不能保证就可以恰好组成一个大矩形。可以从<strong>顶点</strong>出发，如果可以恰好围成一个大矩形，那么在所有小矩形的顶点中，有且只有4个顶点只出现一次（围成大矩形的四个顶点/角），其他顶点一定只出现2次或者4次。</li><li>由下图可以看出，<strong>只有当某个顶点只出现奇数次才会作为围成图形的角</strong>。很明显，要想恰好围成大矩形，必须有其只有4个顶点符合情况一，且不能出现情况三。</li></ul><blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230111195849264.png" /></p><p>图片来源：《labuladong算法秘籍》</p></blockquote><blockquote><p>注意：</p><ol type="1"><li>找到的大矩形顶点只是理论上的：就是说给定这些矩形，所可以围成的大矩形的顶点理论上是这个值。</li><li>考虑顶点的时候，除了判断只有4个顶点出现1次，还需要判断这4个顶点是否就是理论上的那4个顶点。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isRectangleCover</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;<br>    map&lt;p, <span class="hljs-type">int</span>&gt; points;<br>    <span class="hljs-comment">// 大矩形的左下顶点坐标和右上顶点坐标</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> X1 = INT_MAX, Y1 = INT_MAX, X2 = INT_MIN, Y2 = INT_MIN;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> areaSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; rectangle : rectangles) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> x1 = rectangle[<span class="hljs-number">0</span>], y1 = rectangle[<span class="hljs-number">1</span>], x2 = rectangle[<span class="hljs-number">2</span>], y2 = rectangle[<span class="hljs-number">3</span>];<br>        X1 = <span class="hljs-built_in">min</span>(X1, x1);<br>        Y1 = <span class="hljs-built_in">min</span>(Y1, y1);<br>        X2 = <span class="hljs-built_in">max</span>(X2, x2);<br>        Y2 = <span class="hljs-built_in">max</span>(Y2, y2);<br>        areaSum += (x2 - x1) * (y2 - y1);<br>        p p1 = &#123;x1, y1&#125;, p2 = &#123;x1, y2&#125;, p3 = &#123;x2, y1&#125;, p4 = &#123;x2, y2&#125;;<br>        points[p1]++;points[p2]++;points[p3]++;points[p4]++;<br>    &#125; <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> bigArea = (X2 - X1) * (Y2 - Y1);<br>    <span class="hljs-keyword">if</span> (areaSum != bigArea) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 面积不相等 false</span><br>    <span class="hljs-type">int</span> v_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; p0 : points)&#123;<br>        <span class="hljs-comment">// 计算图形中角的个数</span><br>        <span class="hljs-keyword">if</span> (p0.second % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) v_cnt++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (v_cnt != <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果围成大矩形，只能有4个角</span><br>    <span class="hljs-comment">// 最后还需要判断这四个角确实是大矩形的四个顶点</span><br>    p p1 = &#123;X1, Y1&#125;, p2 = &#123;X1, Y2&#125;, p3 = &#123;X2, Y1&#125;, p4 = &#123;X2, Y2&#125;;<br>    <span class="hljs-keyword">return</span> points[p1]==<span class="hljs-number">1</span> &amp;&amp; points[p2]==<span class="hljs-number">1</span> &amp;&amp; points[p3]==<span class="hljs-number">1</span> &amp;&amp; points[p4]==<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里使用的是<code>map</code>而不是一般的<code>unordered_map</code>，原因是在<code>unordered_map</code>是使用<code>hash</code>来计算<code>key</code>，但是<code>hash</code>不能处理<code>pair</code>类型数据，所以不能在<code>unordered_map</code>中使用<code>pair</code>数据类型。</p><p><ahref="https://blog.csdn.net/weixin_42989041/article/details/113183015">参考文章</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记7-暴力搜索</title>
      <link href="/2022/11/18/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B07%EF%BC%88%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%EF%BC%89/"/>
      <url>/2022/11/18/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B07%EF%BC%88%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="dfs回溯算法">DFS/回溯算法</h2><p>回溯的核心思想在于：</p><ul><li>做出选择</li><li>（DFS递归）</li><li>撤销选择</li></ul><p>但是面对不同的题目：做什么选择，在哪做选择都是需要考虑的问题。</p><p>大致的框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">结果集 = []<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrace</span>(<span class="hljs-params">路径, 选择列表</span>):<br>    <span class="hljs-keyword">if</span> 满足结束的条件:<br>        结果集.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做出选择<br>        backtrace(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><h3 id="例子">例子</h3><h4 id="全排列">【全排列】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    backtrace(nums, path);<br>&#125;<br><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;Integer&gt; path)</span>&#123;<br>    <span class="hljs-comment">// 结束条件</span><br>    <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(path.contains(nums[i])) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 筛除不在选择列表中的元素</span><br>        path.add(nums[i]); <span class="hljs-comment">// 做出选择</span><br>        backtrace(nums, path);<br>        path.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(nums[i])); <span class="hljs-comment">// 撤销x</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="n皇后">【N皇后】</h4><p>在 n<span class="math inline">\(\times\)</span>n 的棋盘上放置 n个皇后，使得 n 个皇后不能相互攻击</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    List&lt;Integer&gt; board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子集划分">子集划分</h3><p>给定一个数组<code>nums</code>和一个正整数<code>k</code>，返回其是否能被分成<code>k</code>个子集，且每个子集的元素和相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 1. 以数字的视角：每一个数都是去k个桶中的一个桶</span><br>    <span class="hljs-comment">// O(k^n)</span><br>    <span class="hljs-comment">// 会超时!</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartitionKSubsets2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 去掉一些特殊情况</span><br>        <span class="hljs-keyword">if</span>(k &gt; nums.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) sum += i;<br>        <span class="hljs-keyword">if</span>(sum % k != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sub_sum</span> <span class="hljs-operator">=</span> sum / k;<br>        <span class="hljs-type">int</span>[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br><br>        <br>        <span class="hljs-comment">// 给数组按降序排列，使得回溯的剪枝尽早发生</span><br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(; i &lt; j; i++, j--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> backtrace(nums, <span class="hljs-number">0</span>, sub_sum, buckets);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] buckets)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index == nums.length)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buckets.length; i++)&#123;<br>                <span class="hljs-keyword">if</span>(buckets[i] != target) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buckets.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(buckets[i] + nums[index] &gt; target) <span class="hljs-keyword">continue</span>;<br>            buckets[i] += nums[index];<br>            <span class="hljs-comment">// 向后继续走</span><br>            <span class="hljs-keyword">if</span>( backtrace(nums, index + <span class="hljs-number">1</span>, target, buckets) )&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 后面的某个情况不满足条件，需要回溯</span><br>            buckets[i] -= nums[index];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    回溯：不能没有尝试完就做决定，没做一次决定都要向后继续走，只有最后能走通，才算是正确的选择</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 2.以桶的视角：每个桶都要遍历所有元素</span><br>    <span class="hljs-comment">// O(k*2^n)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartitionKSubsets1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 去掉一些特殊情况</span><br>        <span class="hljs-keyword">if</span>(k &gt; nums.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) sum += i;<br>        <span class="hljs-keyword">if</span>(sum % k != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sub_sum</span> <span class="hljs-operator">=</span> sum / k;<br>        <span class="hljs-type">int</span>[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br><br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br><br>        <span class="hljs-keyword">return</span> backtrace(nums, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, buckets, sub_sum);<br>    &#125;<br><br>    <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] buckets, <span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index == buckets.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(buckets[index] == target) &#123;<br>            <span class="hljs-keyword">return</span> backtrace(nums, <span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>, buckets, target);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[i] || buckets[index] + nums[i] &gt; target) <span class="hljs-keyword">continue</span>;<br>            buckets[index] += nums[i];<br>            visited[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 向后继续走</span><br>            <span class="hljs-keyword">if</span>( backtrace(nums, i + <span class="hljs-number">1</span>, index, buckets, target) )&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 回溯</span><br>            visited[i] = <span class="hljs-literal">false</span>;<br>            buckets[index] -= nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 3.状态数组+递归</span><br>    <span class="hljs-comment">// 重点理解三个点:</span><br>    <span class="hljs-comment">// 1. 为什么在刚进入dfs时就把 dp[s]设为false !!!</span><br>    <span class="hljs-comment">// 2. 为什么 nums[i] + p &gt; per 后就 break 返回 fasle</span><br>    <span class="hljs-comment">// 3. 为什么 递归的dfs p = (nums[i] + p) % per</span><br><br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> per, n;<br>    <span class="hljs-type">boolean</span>[] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartitionKSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">all</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (all % k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        per = all / k;<br>        Arrays.sort(nums);<br>        n = nums.length;<br>        <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] &gt; per) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span> &lt;&lt; n];<br>        Arrays.fill(dp, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> dfs((<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dp[s]) &#123;<br>            <span class="hljs-keyword">return</span> dp[s];<br>        &#125;<br>        <span class="hljs-comment">// 避免重复执行相同情况</span><br>        dp[s] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// dp[s] 到底代表了什么?</span><br>                       <span class="hljs-comment">// s代表的是还有哪些位置的元素是可用的,dp[s]是代表在这种情况下的可行性? 为什么在一开始就把这种情况作为不可行.</span><br>                       <span class="hljs-comment">// 如果这种某种情况可行的话,那么是不会再次被碰到的,会直接返回到主函数中</span><br>                       <span class="hljs-comment">// 相反如果这种情况被再次碰到,那么上一次碰到这种情况的时候肯定是不可行,即false</span><br>                       <span class="hljs-comment">// 下一次碰到的时候,尽管s是相同,p也相同吗? 是的</span><br>                       <span class="hljs-comment">// 从p是如何迭代的可以看出,由于s是相同的,所以用掉的nums[i]是一样的,而p是用掉的nums[i]相加后模per得到的,所以当s是相同的时候,p也是相同的.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 因为nums是被排序过的，所有前面的要是加起来 &gt; per 后面肯定也会 提前剪枝</span><br>            <span class="hljs-keyword">if</span> (nums[i] + p &gt; per) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// (p + nums[i]) % per 是为了重置当前的子集的值</span><br>                <span class="hljs-comment">// 即当 p + nums[i] == per 后，重置为0</span><br>                <span class="hljs-keyword">if</span> (dfs(s ^ (<span class="hljs-number">1</span> &lt;&lt; i), (p + nums[i]) % per)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回溯很重要的一个点：不能没有考虑后面情况就定死了前面的选择。回溯的本质在于先不断地做决定，如果成功那么之前的选择就是正确的并返回，如果出错了，在不断地撤回决定并且重新做决定</strong></p><h3 id="总结">总结</h3><blockquote><p>总结回溯算法在子集、组合和排列三类问题上的处理</p></blockquote><p>对于子集、组合和排列这三类问题，可以按照元素是是否可重、是否可复选两方面来划分。</p><blockquote><p>子集问题和排列问题本质其实是同属一类问题，都是对顺序没有要求的选取部分序列...所以就将他们归类为一种问题</p></blockquote><h4 id="集合组合问题">1、集合/组合问题</h4><ol type="1"><li>集合/组合问题是不存在顺序的，所以每次<code>backtrace</code>的过程中，不能都从下标0开始选择元素，所以每次进入<code>backtrace</code>时都应该指明下次从哪开始选。</li><li>集合/组合问题的要求主要有两种：1、选出指定元素个数的组合（即包含指定数量元素的子集）2、选出元素和等于指定值的组合</li></ol><h5 id="元素无重不可复选">1.1、元素无重+不可复选</h5><blockquote><p>子集问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ans;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    backtrace(nums, <span class="hljs-number">0</span>, node);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, List&lt;Integer&gt; node)</span>&#123;<br><span class="hljs-comment">// 如果要返回指定数量元素的子集，在这里微调即可</span><br>    ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(node));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>        node.add(nums[i]);<br>        backtrace(nums, i + <span class="hljs-number">1</span>, node);<br>        node.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(nums[i]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="元素可重不可复选">1.2、元素可重+不可复选</h5><blockquote><p>包含重复元素的集合，选出子集</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ans;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums);<br>    backtrace(nums, <span class="hljs-number">0</span>, node);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, List&lt;Integer&gt; node)</span>&#123;<br><br>    ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(node));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">// 剪枝 如果当前元素和前一个相同 就跳过</span><br>        <span class="hljs-keyword">if</span>( i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] ) <span class="hljs-keyword">continue</span>;<br>        node.add(nums[i]);<br>        backtrace(nums, i + <span class="hljs-number">1</span>, node);<br>        node.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(nums[i]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="元素无重可重复选">1.3、元素无重+可重复选</h5><blockquote><p>nums数组，指定 target，返回所有满足 元素和等于 target 的子序列</p><p>可以重复使用元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(candidates);<br>        backtrace(candidates, <span class="hljs-number">0</span>, one, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    nums: 元素集合</span><br><span class="hljs-comment">    start: 开始位置</span><br><span class="hljs-comment">    one: 子序列</span><br><span class="hljs-comment">    target: 目标值</span><br><span class="hljs-comment">    cur_sum: 当前元素和</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, List&lt;Integer&gt; one, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> cur_sum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cur_sum == target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(one));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(cur_sum + nums[i] &gt; target) <span class="hljs-keyword">break</span>;<br>            one.add(nums[i]);<br>            <span class="hljs-comment">// 从 i 开始向后走，保证可以重复使用元素...</span><br>            backtrace(nums, i, one, target, cur_sum + nums[i]);<br>            one.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(nums[i]));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="排列问题">2、排列问题</h4><p>排列问题一般不存在对子序列元素和的要求，所以框架上略有不同</p><ul><li>元素无重+不可复选</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">solve</span><span class="hljs-params">(...)</span>&#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    backtrace(nums, one);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;Integer&gt; one)</span>&#123;<br>    <span class="hljs-comment">// 结束条件: 包含了所有元素</span><br>    <span class="hljs-keyword">if</span>(one.size() == nums.length)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(one));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>( one.contains(nums[i]) ) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 排除被选中的元素</span><br>        one.add(nums[i]);<br>        backtrace(nums, one);<br>        one.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(nums[i]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>元素有重+不可复选</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要排除一些情况</span><br>List&lt;List&lt;Integer&gt;&gt; res;<br><span class="hljs-type">boolean</span>[] visited;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">solve</span><span class="hljs-params">(...)</span>&#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>    backtrace(nums, one);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;Integer&gt; one)</span>&#123;<br>    <span class="hljs-comment">// 结束条件: 包含了所有元素</span><br>    <span class="hljs-keyword">if</span>(one.size() == nums.length)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(one));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">/* 剪枝: 当前元素和前一个元素相同 且 前一个还没有遍历到的话 就跳过</span><br><span class="hljs-comment">        因为这个情况在前一个元素遍历时已经经历了</span><br><span class="hljs-comment">        例如: [1,2,1] 遍历第一个 1 的时候就已经 遍历出了 [1,1,2] 和 [1,2,1] 了</span><br><span class="hljs-comment">        遍历到第二个 1 就可以跳过了</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>( i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>] &amp;&amp; !visited[i-<span class="hljs-number">1</span>] ) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>( visited[i] ) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 排除被选中的元素</span><br>        visited[i] = <span class="hljs-literal">true</span>;<br>        one.add(nums[i]);<br>        backtrace(nums, one);<br>        visited[i] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//one.remove(new Integer(nums[i])); // remove(Object o) 是移除第一个出现的这个元素</span><br>        one.remove(one.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 使用下标移除</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="岛屿问题">岛屿问题</h3><h4 id="岛屿数量">1、岛屿数量</h4><blockquote><p><ahref="https://leetcode.cn/problems/number-of-islands/submissions/">200.岛屿数量 - 力扣（LeetCode）</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                dfs(grid, i, j);<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">/* 这种越界判断跟简洁 */</span><br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 越界返回</span><br>        <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br>        <br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <br>        dfs(grid, i - <span class="hljs-number">1</span>, j);<br>        dfs(grid, i + <span class="hljs-number">1</span>, j);<br>        dfs(grid, i, j - <span class="hljs-number">1</span>);<br>        dfs(grid, i, j + <span class="hljs-number">1</span>);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="封闭岛屿数量">2、封闭岛屿数量</h4><blockquote><p>封闭岛屿就是<strong>完全</strong>（上、下、左、右）被水包围的陆地</p></blockquote><p>其实 封闭岛屿数量 = 200.岛屿数量 - 靠边岛屿数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 把200.岛屿数量中求出来的岛屿数减去靠边的岛屿数就是本题结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closedIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// Attention: 得先将上下左右边上的岛屿给淹掉</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) dfs(grid, <span class="hljs-number">0</span>, j);<br>            <span class="hljs-keyword">if</span>(grid[m-<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) dfs(grid, m-<span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) dfs(grid, i, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(grid[i][n-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) dfs(grid, i, n-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果在这个主循环里排除靠边的岛屿的话，会出现错误</span><br>        <span class="hljs-comment">// 因为存在遍历次序 中间的0 肯定比 最下面那条边的0 更早被遍历</span><br>        <span class="hljs-comment">// 如果中间的0和下面那条边的0是相连通的，这个岛屿就是靠边岛屿</span><br>        <span class="hljs-comment">// 但是这个岛屿会被算进答案中</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        for(int i = 0; i &lt; m; i ++)&#123;</span><br><span class="hljs-comment">            for(int j = 0; j &lt; n; j ++)&#123;</span><br><span class="hljs-comment">                if(grid[i][j] == 1) continue;</span><br><span class="hljs-comment">                if(i == 0 || i == m - 1 || j == 0 || j == n - 1)&#123;</span><br><span class="hljs-comment">                    dfs(grid, i, j);</span><br><span class="hljs-comment">                &#125; else &#123;</span><br><span class="hljs-comment">                    dfs(grid, i, j);</span><br><span class="hljs-comment">                    cnt++;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dfs(grid, i, j);<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>        grid[i][j] = <span class="hljs-number">1</span>;<br><br>        dfs(grid, i - <span class="hljs-number">1</span>, j);<br>        dfs(grid, i + <span class="hljs-number">1</span>, j);<br>        dfs(grid, i, j - <span class="hljs-number">1</span>);<br>        dfs(grid, i, j + <span class="hljs-number">1</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="统计子岛屿">3、统计子岛屿</h4><blockquote><p><a href="https://leetcode.cn/problems/count-sub-islands/">1905.统计子岛屿 - 力扣（LeetCode）</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubIslands</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid1, <span class="hljs-type">int</span>[][] grid2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid1.length; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid1[<span class="hljs-number">0</span>].length;<br>    <br>    <span class="hljs-comment">// 先淹掉grid2中不是子岛屿的部分</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid1[i][j] == <span class="hljs-number">0</span> &amp;&amp; grid2[i][j] == <span class="hljs-number">1</span>)&#123;<br>                dfs(grid2, i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计子岛屿</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid2[i][j] == <span class="hljs-number">1</span>)&#123;<br>                dfs(grid2, i, j);<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    grid[i][j] = <span class="hljs-number">0</span>;<br><br>    dfs(grid, i-<span class="hljs-number">1</span>, j);<br>    dfs(grid, i+<span class="hljs-number">1</span>, j);<br>    dfs(grid, i, j-<span class="hljs-number">1</span>);<br>    dfs(grid, i, j+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不同岛屿的数量">4、不同岛屿的数量</h4><p>统计不同形状的岛屿数量</p><p>这就要求在dfs遍历的过程中用某种方法记录岛屿的形状：在dfs过程中用字符进行拼接形成字符串</p><p>由于dfs的顺序是一样的、固定的，所以如果岛屿形状相同，开始dfs的位置肯定是一样的，最后形成的字符串也是一样的，再通过HashMap记录即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinctIslands</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br><br>    Map&lt;String, Integer&gt; mapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                <br>                <span class="hljs-type">String</span> <span class="hljs-variable">shape</span> <span class="hljs-operator">=</span> dfs(grid, i, j);<br>                System.out.println(<span class="hljs-string">&quot;(&quot;</span> + i + <span class="hljs-string">&quot;, &quot;</span> + j + <span class="hljs-string">&quot;)&quot;</span> + <span class="hljs-string">&quot;: &quot;</span> + shape);<br>                <br>                <span class="hljs-keyword">if</span> (!mapping.containsKey(shape))&#123;<br>                    mapping.put(shape, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> mapping.size();<br>&#125;<br><br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-comment">// 非陆地的统一用&#x27;0&#x27;表示</span><br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>    grid[i][j] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>  +  dfs(grid, i - <span class="hljs-number">1</span>, j) +<br>                   dfs(grid, i + <span class="hljs-number">1</span>, j) +<br>                   dfs(grid, i, j - <span class="hljs-number">1</span>) +<br>                   dfs(grid, i, j + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bfs算法">BFS算法</h2><p>BFS算法是广度优先，遍历过程中，从开始节点到（第一次到）任一节点的的距离都是最小的</p><p>优点：BFS算法的普适性强，可以适用于所有情况</p><p>缺点：效率低，BFS的遍历由一个点等距离的向四周扩散</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029210656103.png"alt="image-20221029210656103" /><figcaption aria-hidden="true">image-20221029210656103</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(Node root, Node target)</span>&#123;<br>    <span class="hljs-comment">// 队列: BFS遍历必备</span><br>    Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-comment">// 记录已经走过的节点</span><br>    Set&lt;Node&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    visited.add(root);<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录已走的步数</span><br>    <br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <br>            <span class="hljs-keyword">if</span>(cur is target) <span class="hljs-keyword">return</span> step;<br>            <br>            <span class="hljs-keyword">for</span>(Node n : graph[n])&#123;<br>                <span class="hljs-keyword">if</span>(!visited.contains(n))&#123;<br>                    queue.offer(n);<br>                    visited.add(n);<br>                &#125;<br>            &#125;<br>        &#125;<br>        step ++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dijkstra算法">Dijkstra算法</h2><p>Dijkstra算法就是在BFS算法上的一个改进，针对有权重的图，主要的区别就在于存放节点的数据结构从普通的队列（Queue）变成了优先级队列（PriorityQueue），而使用优先级队列就可以按照代价（<strong>这个代价是从开始节点到当前节点的代价</strong>，所以Dijkstra算法是可以求出开始节点到所有节点的最小距离的）对节点进行排序，使得每次取出的节点都是代价最小的，从而实现第一次到某节点时的代价就是最小的。</p><h2 id="greedy-best-first-search">Greedy Best-First Search</h2><p>这个算法和Dijktra算法类似，但是这里所选取的代价是<strong>当前节点到target节点的理论代价</strong>。所以这个算法可以<strong>基本可以</strong>十分快速求出到达target节点的最小代价，特殊情况就是图中存在障碍物的情形，由于所用的代价是理论上的，并不是实际情况，所以会导致"走错路"的情况。</p><h2 id="a算法">A*算法</h2><blockquote><p><a href="">Introduction to A*</a></p></blockquote><p>A*算法有效地结合了Dijkstra算法和Greedy Best-FirstSearch算法，<strong>综合了两方面的代价</strong>，使得既拥有了上述两个算法的优势。</p><p>代码框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Solution&#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">AStar</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            f: 综合代价 f = g + h</span><br><span class="hljs-comment">            g: 开始节点到当前节点的代价</span><br><span class="hljs-comment">            h: 当前节点到target节点的理论代价</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> f, g, h; <br>        Node cur; <span class="hljs-comment">// 标识当前节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AStar</span><span class="hljs-params">(Node cur, <span class="hljs-type">int</span> g, Node target)</span>&#123;<br>            <span class="hljs-built_in">this</span>.cur = cur;<br>            <span class="hljs-built_in">this</span>.h = getH(cur, target);<br>            <span class="hljs-built_in">this</span>.g = g;<br>            <span class="hljs-built_in">this</span>.f = <span class="hljs-built_in">this</span>.g + <span class="hljs-built_in">this</span>.h;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算 h 值</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getH</span><span class="hljs-params">(Node cur, Node target)</span>&#123;<br><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(Node start, Node target)</span>&#123;<br>        Queue&lt;AStar&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> a.f - b.f;<br>        &#125;);<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AStar</span>(start, <span class="hljs-number">0</span>, target));<br>        <br>        Set&lt;Node&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        visited.add(start);<br>        <br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">AStar</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <br>            <span class="hljs-keyword">for</span>(Node n : graph[node.cur])&#123;<br>                <span class="hljs-keyword">if</span>(!visited.contains(n))&#123;<br>                    <span class="hljs-keyword">if</span>(n == target)&#123;<br>                        <span class="hljs-keyword">return</span> node.g + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AStar</span>(n, node.g + <span class="hljs-number">1</span>, target));<br>                    visited(n);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>    &#125;<br>    <br>    <br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="应用">应用</h2><p>【773.滑动谜题】</p><blockquote><p><a href="https://leetcode.cn/problems/sliding-puzzle/">773. 滑动谜题- 力扣（LeetCode）</a></p></blockquote><p>关键在于如何建模形成 graph 以及 node 是什么</p><p>在这道题中，就可以把<span class="math inline">\(2 \times3\)</span>的矩阵抽象成<code>String</code>作为节点，而每次移动之后形成的节点作为该节点的邻居，这样就形成了<code>graph</code></p>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记8-动态规划</title>
      <link href="/2022/11/17/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B08%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"/>
      <url>/2022/11/17/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B08%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一核心原理">一、核心原理</h2><blockquote><p>刷过一些题后，感觉动态规划最核心的就是 <strong>dp 数组</strong> +<strong>状态转移方程</strong></p><p>【dp数组】是为了避免重复计算而带来的高复杂度</p><p>【状态转移方程】是为了将问题进行分解成更加简单的子结构</p><p>所以动态规划的核心思想就是：</p><p>1、自底向上（迭代）：从最简子结构开始，不断向上计算，在计算过程中将对应子结构的值存在dp数组 中，使得更复杂结构的问题在分解后可以直接找到答案。</p><p>2、自顶向下（递归） ：从当前问题规模出发，通过递归不断分解问题直至base case，计算出basecase后，再从最深的递归函数开始不断返回，向上计算，最后求解出问题的答案。</p></blockquote><p>要写出动态规划的解法，最重要的就是写出<strong>状态转移方程</strong>。有了状态转移方程，就知道需要保存什么值，就可以推出dp数组的定义。</p><p>首先要明确<strong>状态</strong>。这个状态是会影响问题规模的量。在背包问题中，很明显问题的规模主要和<strong>物品的数量</strong> 以及 <strong>背包的容量</strong>相关。因为如果这两个量的值很小，那么问题就会很简单，反之就会很复杂。</p><p>明确状态之后，就要寻找如何<strong>转移</strong>。转移的目的是降低问题的规模（通过改变状态）。那么在背包问题中，我们要求解的是在当前给定数量(<span class="math inline">\(N\)</span>)的物品 和给定容量(<spanclass="math inline">\(W\)</span>)的背包的前提下的某个问题，我们用 <spanclass="math inline">\(f(N, W)\)</span>来表示。</p><p>而我们想要找出来的是 <span class="math inline">\(f(N,W)\)</span>能够用某些更小规模的问题来表示（可以理解为数列中的递推公式），例如 <spanclass="math inline">\(f(N,W) = f(N-1,W) + f(N, W-1)\)</span></p><p>最后要去找到<code>base case</code>的值，例如<spanclass="math inline">\(f(0,W)\)</span>或者<spanclass="math inline">\(f(N,0)\)</span>，因为所以的状态转移都是建立在<code>base case</code>的基础上的。</p><h2 id="二经典动态规划问题">二、经典动态规划问题</h2><p>这里主要讲两类问题，分类的主要是状态转移方程的类型。</p><h3 id="单参数">1、单参数</h3><blockquote><p>【300.最长递增子序列】</p><p>【53.最大子序和】</p></blockquote><p>它们的状态转移方程都只有一个参数（dp数组都是一维的）</p><p>【300.最长递增子序列】中的状态转移方程：$f(i) = max(f(i), f(j)+1) $<span class="math inline">\(j = [i+1, ... n-1]\)</span>，其中<spanclass="math inline">\(f(i)\)</span>表示以第<spanclass="math inline">\(i\)</span>个元素结尾的最长严格递增子序列的长度。</p><p>那么核心部分的代码也就很好写了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mem</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[j] &gt;= nums[i]) <span class="hljs-keyword">continue</span>;<br>        mem[i] = <span class="hljs-built_in">max</span>(mem[i], mem[j]+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (res &lt; mem[i]) res = mem[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双参数">2、双参数</h3><blockquote><p>【1143.最长公共子序列】</p><p>【72.编辑距离】</p><p>【10.正则表达式匹配】</p></blockquote><p>这一类的问题涉及到两个状态，但本质上还是第一类问题，只是由于字符串/数组变成了两个，所以需要两个参数来记录状态。</p><p>以【10.正则表达式状态匹配】为例。存在 一个待匹配的字符串<code>str</code> 和 一个模板串 <code>pattern</code>，那么状态就有两个：<code>str</code> 的长度和 <code>pattern</code>的长度，那这个问题的解就可以表示为 <span class="math inline">\(f(N,M)\)</span></p><p>然后就要考虑如何转移状态化简问题的解。我们先任取两个值<code>i</code>，<code>j</code>，分别表示【只考虑<code>str</code>的前<code>i</code>个字符】以及【只考虑<code>pattern</code>的前<code>j</code>个字符】，这样我们要求解的就是<code>f(str.length(), pattern.length())</code>了。</p><p>由于<spanclass="math inline">\(f(i,j)\)</span>之前的子问题肯定都已经计算好了，所以我们就只要考虑如何减小<code>i</code>、<code>j</code>这两个参数。下面就涉及到问题的细节，在这个问题中，到状态转移到<code>i</code>和<code>j</code>时，考虑pattern的第<code>j</code>个字符是什么？我们分为两种情况：<code>'*'</code>和不是<code>'*'</code>，原因在于<code>'*'</code>是可以匹配多个的，是变化的。</p><ul><li>如果是<code>'*'</code>：就要看前一个字符是否和<code>str</code>的第<code>i</code>个字符【相同】<ul><li>不相同：<code>dp[i][j]</code>转移到<code>dp[i][j-2]</code></li><li>相同：就要选择是否要去匹配<code>str</code>的第<code>i</code>个字符<ul><li>不去匹配：<code>dp[i][j]</code>转移到<code>dp[i][j-2]</code></li><li>要匹配：<code>dp[i][j]</code>转移到<code>dp[i-1][j]</code></li></ul></li></ul></li><li>如果不是<code>'*'</code>：就看<code>str</code>的第<code>i</code>个字符和<code>pattern</code>的第<code>j</code>个字符是否相同<ul><li>相同：<code>dp[i][j]</code>转移到<code>dp[i-1][j-1]</code></li><li>不相同：<code>dp[i][j] = false</code></li></ul></li></ul><p>【完整代码】如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.length();<br><br>    <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">// 从0开始是为了看是否能够匹配空串；填上dp数组的最上面一行；就是确定base case</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>            <span class="hljs-keyword">if</span>(p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 匹配0个</span><br>                dp[i][j] = dp[i][j-<span class="hljs-number">2</span>];<br>                <span class="hljs-comment">// 匹配1个</span><br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">2</span>) || p.charAt(j-<span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    dp[i][j] = dp[i][j] || dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三背包问题">三、背包问题</h2><h3 id="类型">1、类型</h3><h4 id="背包问题">1.1、0-1背包问题</h4><p>【问题描述】</p><blockquote><p>给定一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性，其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，请问用这个背包最多可以装多少价值的物品？</p></blockquote><h4 id="完全背包问题">1.2、完全背包问题</h4><p>【518.零钱兑换Ⅱ】</p><blockquote><p>给定不同面额的硬币和一个总金额，计算出可以凑成总金额的硬币组合数，假设每一种面额的硬币有无限个。</p></blockquote><p>转换为背包问题，就是</p><blockquote><p>有一个最大容量为 amount 的背包，有一系列物品 coins，物品的重量为coins[i]，每个物品的数量无限，请问有多少种方法，能够恰好把背包装满？</p></blockquote><p>由于每个物品的数量是无限的，所以被称为【<strong>完全背包问题</strong>】</p><h4 id="子集背包问题">1.3、子集背包问题</h4><p>【416.分割等和子集】</p><blockquote><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得这两个子集的元素和相等。</p></blockquote><p>其实类似于0-1背包问题</p><blockquote><p>有一堆物品 nums，物品重量为 nums[i]，物品重量之和为 sum。有一个容量为sum / 2 的背包，是否存在一种方法能够恰好装满这个背包？</p></blockquote><h3 id="分析">2、分析</h3><p>由于都可以转换为情景相似的背包问题，所以就可以放在一起分析。</p><p>这里我们挑完全背包问题作为例子，【518.零钱兑换Ⅱ】</p><ol type="1"><li>明确状态：<span class="math inline">\(N\)</span>：前<spanclass="math inline">\(N\)</span>个硬币；<spanclass="math inline">\(W\)</span>：总金额</li><li>明确转移：需要求解的是 <span class="math inline">\(f(N,W)\)</span>，即给定前<spanclass="math inline">\(N\)</span>个硬币恰好可以组成<spanclass="math inline">\(W\)</span>金额的组合数。这么定义了之后，我们就可以很轻易的写出最简单问题的答案：<spanclass="math inline">\(f(0, W) = 0\)</span>和<spanclass="math inline">\(f(N, 0) = 1\)</span></li><li>如何转移：对于 <spanclass="math inline">\(f(N,W)\)</span>，我们考虑第<spanclass="math inline">\(N\)</span>个硬币P。如果我们在组合过程中不使用P，那么问题就被转化为了<spanclass="math inline">\(f(N-1,W)\)</span>。如果我们在组合过程中要使用P，那么问题就被转化为了<spanclass="math inline">\(f(N, W-wt[P])\)</span>。</li><li>所以我们可以得出状态转移方程：<span class="math inline">\(f(N,W) =f(N-1,W)+f(N,W-wt[P])\)</span></li></ol><p>写出状态转移方程之后，我们就可以知道如何定义 dp数组 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][];<br><span class="hljs-comment">// dp[i][j]: 前i个硬币组合出j金额的种数</span><br></code></pre></td></tr></table></figure><p>我们就可以用dp数组来表示状态转移方程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j - &lt;第i个硬币的面值&gt;]<br></code></pre></td></tr></table></figure><blockquote><p>[3]有一个比较难理解的点，就是为什么使用了P，问题被转化成了<spanclass="math inline">\(f(N, W-wt[P])\)</span>，而不是<spanclass="math inline">\(f(N-1, W-wt[P])\)</span></p><p>​ 可能会感觉是 <span class="math inline">\(N-1\)</span>，毕竟第<spanclass="math inline">\(N\)</span>个硬币已经用过了，但是也可能<spanclass="math inline">\(W-wt[P]\)</span>金额组合中也用了第<spanclass="math inline">\(N\)</span>个硬币，所以不能确定硬币数，只能确定金额数。</p></blockquote><h3 id="代码和改进">3、代码和改进</h3><h4 id="代码">代码</h4><p>【518.零钱兑换Ⅱ】完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][amount+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 目标就是求 dp[n][amount]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= amount; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &lt; coins[i-<span class="hljs-number">1</span>])&#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j - coins[i-<span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][amount];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="状态压缩">状态压缩</h4><p>最后，还要再探讨一下状态压缩问题，即可以使用一维dp数组，使得空间复杂度从<spanclass="math inline">\(O(NW)\)</span>降为<spanclass="math inline">\(O(W)\)</span></p><p>这里主要选取【518.零钱兑换Ⅱ】和【416.分割等和子集】两个问题</p><p>首先写出它们的状态转移方程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 518.零钱兑换Ⅱ</span><br>dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j - coins[i-<span class="hljs-number">1</span>]];<br><span class="hljs-comment">// 416.分割等和子集</span><br>dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i-<span class="hljs-number">1</span>][j - nums[i-<span class="hljs-number">1</span>]];<br></code></pre></td></tr></table></figure><p>可以发现，<code>dp[i][j]</code>只和<code>dp[i][...]</code>以及<code>dp[i-1][...]</code>有关系。</p><p>改成一维数组后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount];<br></code></pre></td></tr></table></figure><p>在第<code>i</code>轮迭代开始之前，dp数组中的值就等价于之前的<code>dp[i-1][...]</code></p><p>所以只要控制遍历顺序（正向或逆向），使得在遍历<code>dp[j]</code>时，<code>dp[j-?]</code>的值已经更新（<code>dp[i][j-?]</code>）或者没有更新（<code>dp[i-1][j-?]</code>），即可实现状态的转移。</p><p>最后附上使用一维数组解决的代码</p><blockquote><p><strong>注意两段代码的第二层循环，就是通过正向遍历和逆向遍历实现在计算dp[j]时dp[j-?]的已更新和未更新</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 518.零钱兑换Ⅱ</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 目标就是求 dp[amount]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= amount; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &lt; coins[i]) <span class="hljs-keyword">continue</span>;<br>            dp[j] = dp[j] + dp[j - coins[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 416.分割等和子集</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 前置判断</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) sum += i;<br>    <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>; <span class="hljs-comment">// 背包中的目标值</span><br><br>    <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target+<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= <span class="hljs-number">1</span>; j--)&#123;<br>            <span class="hljs-keyword">if</span>(j &lt; nums[i]) <span class="hljs-keyword">continue</span>;<br>            dp[j] = dp[j] || dp[j - nums[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记9-dp应用</title>
      <link href="/2022/11/16/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B09%EF%BC%88dp%E5%BA%94%E7%94%A8%EF%BC%89/"/>
      <url>/2022/11/16/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B09%EF%BC%88dp%E5%BA%94%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一股票问题">一、股票问题(*)</h2><blockquote><p><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机 IV</a></p><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i]是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><p>labuladong算法秘籍中使用了【三个<strong>状态</strong>】（三维dp数组）</p><ol type="1"><li>第几天</li><li>手中是否持有股票</li><li>最大交易限制（最大交易限制只在买入股票时减一）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// dp[i][j][k] 意味着在第i天，手中持有(j=1)或不持有(j=0)股票，最大交易限制为k情况下的最大利润</span><br></code></pre></td></tr></table></figure><p><strong>状态转移方程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][<span class="hljs-number">0</span>][k] = Math.max(<br>    dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k],  <span class="hljs-comment">// 第i天 不买入不卖出: 第i-1天也没有股票，交易限制还是k</span><br>    dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k]+prices[i-<span class="hljs-number">1</span>] <span class="hljs-comment">// 第i天 卖出: 第i-1天有股票，交易限制还是k</span><br>);<br>dp[i][<span class="hljs-number">1</span>][k] = Math.max(<br>    dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k], <span class="hljs-comment">// 第i天 不买入不卖出: 第i-1天有股票，交易限制为k</span><br>    dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k-<span class="hljs-number">1</span>]-prices[i-<span class="hljs-number">1</span>] <span class="hljs-comment">// 第i天 买入: 第i-1天没有股票，最大交易次数不能超过k-1</span><br>);<br></code></pre></td></tr></table></figure><p><strong>base case</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][...] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][...] = Integer.MIN_VALUE;<br>dp[...][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[...][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br></code></pre></td></tr></table></figure><h2 id="二打劫家舍问题">二、打劫家舍问题</h2><blockquote><p><ahref="%5B198.%20打家劫舍%20-%20力扣（LeetCode）%5D(https://leetcode.cn/problems/house-robber/)">198.打劫家舍</a></p><p><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍II</a></p><p><a href="https://leetcode.cn/problems/house-robber-iii/">337.打家劫舍 III</a></p></blockquote><h3 id="打劫家舍">1、打劫家舍</h3><p>【状态】是 <u>抢劫第i家时能获得的最大金额</u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 状态转移方程</span><br>dp[i] = Math.max(dp[i-<span class="hljs-number">2</span>], dp[i-<span class="hljs-number">3</span>]) + nums[i];<br></code></pre></td></tr></table></figure><h3 id="打劫家舍ⅱ">2、打劫家舍Ⅱ</h3><blockquote><p>特别之处在于 nums 换成了环形数组</p></blockquote><p>应对策略也十分巧妙</p><p><span class="math inline">\(f([x_{1}, x_{2}, ... , x_{n}]) = max(f([x_{1}, x_{2}, ..., x_{n-1}]), f([x_{2}, ..., x_{n}]) )\)</span></p><p><u><strong>既然首尾相连了，那么肯定最多只能抢劫一家，把另外一家除去</strong></u>，就把环形数组又变成了普通数组了。</p><h3 id="打劫家舍ⅲ">3、打劫家舍Ⅲ</h3><blockquote><p>把家舍的形状变成了二叉树</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] res = dp(root);<br>        <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// return &#123;x, y&#125; </span><br>    <span class="hljs-comment">// x: 包括root节点的最高金额 </span><br>    <span class="hljs-comment">// y: 不包含root节点的最高金额</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dp(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] left = dp(root.left);<br>        <span class="hljs-type">int</span>[] right = dp(root.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> left[<span class="hljs-number">1</span>] + right[<span class="hljs-number">1</span>] + root.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> Math.max(left[<span class="hljs-number">1</span>], left[<span class="hljs-number">0</span>]) + Math.max(right[<span class="hljs-number">1</span>], right[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三博弈问题">三、博弈问题</h2><blockquote><p><a href="https://leetcode.cn/problems/predict-the-winner/">486.预测赢家</a></p></blockquote><p>最核心最关键的还是在【找状态】，理解！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一种比较容易理解的，三维数组</span><br><span class="hljs-comment">// dp[i][j][0] 表示在[xi...xj]区间时，先手的最大得分</span><br>dp[i][j][<span class="hljs-number">0</span>] = Math.max(nums[i]+dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>], nums[j]+dp[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// [i...j] 先手可以选择i也可以选择j</span><br><span class="hljs-comment">// 选择i后，在[i+1...j]区间就变成了后手，就是dp[i+1][j][1]</span><br><span class="hljs-comment">// 选择j后，在[i...j+1]区间就变成了后手，就是dp[i][j-1][1]</span><br><span class="hljs-keyword">if</span> 先手选择了i: dp[i][j][<span class="hljs-number">1</span>] = dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> 先手选择了j: dp[i][j][<span class="hljs-number">1</span>] = dp[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br><br><br><span class="hljs-comment">// 第二种稍微改进一点，二维数组</span><br><span class="hljs-comment">// dp[i][j][1] 表示在[xi...xj]区间时，先手的最大得分-后手的最大得分</span><br>dp[i][j] = Math.max(nums[i] - dp[i+<span class="hljs-number">1</span>][j], nums[j] - dp[i][j-<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 在[i...j]先手做出选择后，就变成了后手，所以是&lt;减&gt;</span><br></code></pre></td></tr></table></figure><h2 id="四扔鸡蛋">四、扔鸡蛋（***）</h2><blockquote><p><ahref="https://leetcode.cn/problems/super-egg-drop/">887.鸡蛋掉落</a></p><p>这道题理解上难度很高...</p></blockquote><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221104212852347.png"alt="image-20221104212852347" /><figcaption aria-hidden="true">image-20221104212852347</figcaption></figure><p>这里讲一个逆向思维。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] 表示有j个鸡蛋，可以操作i次，可以在最高dp[i][j]的建筑里保证找到f<br></code></pre></td></tr></table></figure><p>比如<code>dp[2][1]=2</code>，表示有1个鸡蛋，可以操作2次，可以在最高2楼的建筑里保证找到<code>f</code>。意思就是如果楼<code>&gt;=</code>3，就不能保证在1个鸡蛋2次操作的情况下找到f。这里的保证是指不管在什么情况下都可以成功找到f，而不是说有一定概率可以找到。很好理解，不管多高的楼层，即使给1个鸡蛋1次操作，也有一定概率可以找到f（第1层就碎了，所以<code>f=0</code>）</p><p>理解完状态之后，就需要找到状态转移方程。先给出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = <span class="hljs-number">1</span> + dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + dp[i][j-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>这里应该是这道题最难理解的地方。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记10—其他经典算法</title>
      <link href="/2022/11/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B010%EF%BC%88%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%89/"/>
      <url>/2022/11/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B010%EF%BC%88%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="素数筛">1 素数筛</h2><p>非常普遍的，寻找素数可以使用<spanclass="math inline">\(O(N^{2})\)</span>复杂度的算法来解决，但是不够高效。下面介绍几种更加高效的寻找素数的算法—素数筛。</p><p>最近再看到素数的算法，就想到了6.S081 lab1 中写的 primes函数，好像其本质就是一个素数筛—埃式筛法</p><h3 id="埃式筛法">埃式筛法</h3><p>思路就是，如果一个数是素数，我们可以将这个数的倍数全部划掉，因为它们不可能是素数。</p><p>代码如下，当我们找到一个素数时，我们就将这个素数的2倍、3倍、...划掉，而没有被划掉的就是素数。</p><p>复杂度：<span class="math inline">\(O(N loglogN)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>    Arrays.fill(nums, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i])&#123;<br>            cnt ++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i; j &lt; n; j += i)&#123;<br>                nums[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，很明显这个解法存在一定的冗余，比如说 6 就被 素数2 和素数3重复标记，下面介绍复杂度为<spanclass="math inline">\(O(N)\)</span>的线性素数筛</p><h3 id="线性筛">线性筛</h3><p>线性筛实现了每个合数只被标记一次，时间复杂度为 <spanclass="math inline">\(O(N)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    List&lt;Integer&gt; primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>    Arrays.fill(nums, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i])&#123;<br>            primes.add(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; primes.size() &amp;&amp; primes.get(j) * i &lt; n; j++)&#123;<br>            nums[primes.get(j) * i] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(i % primes.get(j) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> primes.size();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="阶乘">2 阶乘</h2><blockquote><p><ahref="https://leetcode.cn/problems/factorial-trailing-zeroes/">172.阶乘后的零</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221116121050876.png" /></p></blockquote><p>这道题很明显直接去算阶乘肯定是行不通的，应该要考虑核心因素。</p><p>产生0的原因是阶乘式子中存在<span class="math inline">\(2 \times5\)</span>，所以要计算0的数量，只要计算式子中出现了多少对<spanclass="math inline">\(2 \times 5\)</span>，即有多少因子2和因子5。</p><p>再往下考虑，其实只需要考虑因子5的个数即可，因为因子2在任何偶数中都可以提取出来，所以在一个阶乘式子中，因子2的个数是大于因子5的（可以严格证明）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i / <span class="hljs-number">5</span> &gt; <span class="hljs-number">0</span>; i /= <span class="hljs-number">5</span>)&#123;<br>        cnt += (i / <span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><ahref="https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/">793.阶乘函数后 K 个零</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221116121859204.png" /></p></blockquote><p>这一题相当于上一题的逆过程。</p><p>首先明确，<spanclass="math inline">\(f(x)\)</span>肯定是一个单调递增的函数，<spanclass="math inline">\(x\)</span>越大，<spanclass="math inline">\(f(x)\)</span>的值肯定不会减少。而现在是给定<spanclass="math inline">\(f(x)\)</span>，要求出<spanclass="math inline">\(x\)</span>，很自然应该使用【<strong>二分查找</strong>】。</p><p>1、注意数据范围：<span class="math inline">\(k &lt;= 10^9\)</span>，所以能够产生这个<span class="math inline">\(f(x)\)</span>的<spanclass="math inline">\(x\)</span>肯定已经超出了<code>int</code>的范围需要使用<code>long</code></p><p>2、仔细想一想可以发现：给定<code>k</code>之后，要么不存在这样的<spanclass="math inline">\(x!\)</span>，如果存在只有5个这样的<spanclass="math inline">\(x!\)</span>。</p><p>回到上一题的思路，阶乘末尾0的个数 =阶乘式子中因子5的个数。<strong>如果存在的话，应该是能够找到一个<spanclass="math inline">\(x\)</span>，是5的倍数，满足<spanclass="math inline">\(\le x\)</span>的数中因子5的数量之和<spanclass="math inline">\(=k\)</span>。</strong>【举个例子，<spanclass="math inline">\(k=4\)</span>，存在<span class="math inline">\(x =20\)</span>，满足<span class="math inline">\(\lex\)</span>的数中因子5的数量之和<spanclass="math inline">\(=4\)</span>（<spanclass="math inline">\(5、10、15、20\)</span>）】既然如此，那么答案应该就在找到的这个<spanclass="math inline">\(x\)</span>到下一个5的倍数<spanclass="math inline">\(x+5\)</span>之间，即<spanclass="math inline">\([x, x+5)\)</span>，因为到下一个5的倍数<spanclass="math inline">\(x+5\)</span>时，<spanclass="math inline">\(f(x)\)</span>肯定大于<spanclass="math inline">\(k\)</span>，所以总共只有5个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">preimageSizeFZF</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-type">long</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>    <span class="hljs-keyword">while</span>(lo &lt;= hi)&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lo + (hi - lo) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">k0</span> <span class="hljs-operator">=</span> trailingZeroes(mid);<br>        <span class="hljs-keyword">if</span>(k0 == k) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k0 &gt; k) hi = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> lo = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i / <span class="hljs-number">5</span> &gt; <span class="hljs-number">0</span>; i /= <span class="hljs-number">5</span>)&#123;<br>        cnt += (i / <span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="水塘抽样">3 水塘抽样</h2><p><strong>这个算法可以实现【低空间复杂度】从无限序列中随机抽取元素。</strong>实际上是用时间换空间的一种算法。</p><h4 id="问题1无重复元素">问题1：无重复元素</h4><blockquote><p><a href="https://leetcode.cn/problems/linked-list-random-node/">382.链表随机节点</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221117093723012.png" /></p></blockquote><p>思路：当遇到第<code>i</code>个元素时，从<spanclass="math inline">\([0,i)\)</span>之间随机抽取一个数，如果这个数为0，则将答案置为第<code>i</code>个元素，否则答案不变。这样可以使得返回每个元素的概率都为<spanclass="math inline">\(\frac{1}{n}\)</span>。</p><p>证明： <span class="math display">\[P(return \ \  i\text{-}th \ \ element) = \\P(第i次随机选择的值=0) \times P(第i+1次随机选择的值\ne0) \times \cdots\times P(第n次随机选择的值\ne0) =\\\frac{1}{i} \times (1 - \frac{1}{i+1}) \times (1 - \frac{1}{i+2}) \times\cdots \times (1 - \frac{1}{n}) = \frac{1}{n}\]</span> 代码：<code>getRandom</code>函数的时间复杂度为<spanclass="math inline">\(O(N)\)</span>，空间复杂度为<spanclass="math inline">\(O(1)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    ListNode head;<br>    Random r;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = head;<br>        r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">h0</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(h0 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> h0.val;<br>            i++;<br>            <span class="hljs-keyword">if</span>(r.nextInt(i) == <span class="hljs-number">0</span>)&#123;<br>                res = val;<br>            &#125;<br>            h0 = h0.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="问题2存在重复元素">问题2：存在重复元素</h4><blockquote><p><a href="https://leetcode.cn/problems/random-pick-index/">398.随机数索引</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221117095257824.png" /></p></blockquote><p>思路：当遇到第<code>i</code>个<code>target</code>时，随机选取<spanclass="math inline">\([0,i)\)</span>之间的一个整数，如果其为0，这将答案置为<code>target</code>下标，否则答案不变。如果存在<code>k</code>个<code>target</code>，保证返回每个索引的概率都为<spanclass="math inline">\(\frac{1}{k}\)</span>。</p><p>证明同上。</p><p>代码：<code>pick</code>函数的时间复杂度为<spanclass="math inline">\(O(N)\)</span>，空间复杂度为<spanclass="math inline">\(O(1)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span>[] nums;<br>    Random r;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pick</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == target)&#123;<br>                times ++;<br>                <span class="hljs-keyword">if</span>(r.nextInt(times) == <span class="hljs-number">0</span>)&#123;<br>                    res = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="吃葡萄">4 吃葡萄</h2><blockquote><p><ahref="https://www.nowcoder.com/questionTerminal/14c0359fb77a48319f0122ec175c9ada">吃葡萄</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221118092640002.png" /></p></blockquote><p>【要求】<u>三个人中吃的最多的那个人吃得尽量少</u>，<strong>就需要尽可能的平均分</strong>。当不考虑每个人只能吃两种葡萄的限制，答案应该是<spanclass="math inline">\((a+b+c+2)/3\)</span>，就是总和除3向上取整。</p><p>但是有"每个人只能吃两种葡萄"的限制就不能这么简单考虑，因为如果出现"其中两种葡萄很少，第三种很多"的情况时，就不一样了。比如<spanclass="math inline">\(a =1,\ b=1,\c=10000\)</span>，这个时候很明显答案就不是<spanclass="math inline">\((a+b+c+2)/3\)</span>了，因为只能吃<spanclass="math inline">\(a,b\)</span>两种葡萄的人最多只能吃2颗，这种情况下做不到三个人平均分，<strong>只能两个人平均分</strong>，来实现吃的最多的人吃得尽量少，就是<spanclass="math inline">\((c+1)/2\)</span>，即<spanclass="math inline">\((max+1)/2\)</span></p><p>那么如何判断属于哪种情况呢？当<spanclass="math inline">\(a,b,c\)</span>三者没有相差很大的情况下，很明显<spanclass="math inline">\((a+b+c+2)/3 &gt;(max+1)/2\)</span>；而当其中一种水果远大于另外两种时，<spanclass="math inline">\((a+b+c+2)/3 &lt;(max+1)/2\)</span>。所以答案应该是<span class="math inline">\(max( \(a+b+c+2)/3,\ (\ max(a,b,c) + 1 \ )/2 )\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n -- &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-type">int</span> max_val = <span class="hljs-built_in">max</span>( <span class="hljs-built_in">max</span>(a, b), c );<br>        <span class="hljs-type">int</span> sum = a + b + c;<br>        cout &lt;&lt; <span class="hljs-built_in">max</span>( (sum+<span class="hljs-number">2</span>)/<span class="hljs-number">3</span>, (max_val+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span> ) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="同时寻找缺失和重复的元素">5 同时寻找缺失和重复的元素</h2><blockquote><p><a href="https://leetcode.cn/problems/set-mismatch/">645.错误的集合</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221118111228487.png" /></p><p><strong>注意数组是无序的</strong></p></blockquote><p>首先很常规的方法有【排序】、【哈希】，这些都需要一定空间复杂度。下面谈谈常数空间复杂度的【映射】和【异或】</p><h3 id="映射">映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findErrorNums(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">dup</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> Math.abs(nums[i]) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums[idx] &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 重复元素</span><br>            dup = Math.abs(nums[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums[idx] *= -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">mis</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>            mis = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;dup, mis&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异或">异或</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findErrorNums(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">xor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) xor ^= num;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) xor ^= i;<br>    <span class="hljs-comment">// xor = dup ^ mis</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lowbit</span> <span class="hljs-operator">=</span> xor &amp; (-xor);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span>((lowbit &amp; num) == <span class="hljs-number">0</span>)&#123;<br>            num1 ^= num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            num2 ^= num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>((lowbit &amp; i) == <span class="hljs-number">0</span>)&#123;<br>            num1 ^= i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            num2 ^= i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span>(num == num1)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num1, num2&#125;;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num == num2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num2, num1&#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2022/11/12/front-end-technology/TypeScript/"/>
      <url>/2022/11/12/front-end-technology/TypeScript/</url>
      
        <content type="html"><![CDATA[<h2 id="一-概述">一 概述</h2><ol type="1"><li>TypeScript是JavaScript的超集，支持ES6+标准</li><li>由微软开发的自由和开源的变成语言</li><li>可编译为纯JS</li></ol><h2 id="二-语法">二 语法</h2><h3 id="基础类型">1 基础类型</h3><p>TypeScript相比JavaScript而言最大的区别就是 <strong>类型</strong></p><h4 id="布尔值">1.1 布尔值</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> isDone : <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h4 id="数字">1.2 数字</h4><p>和JavaScript一样，TypeScript中的所有数字都是浮点数，使用类型<code>number</code>表示。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> dec : <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>; <span class="hljs-comment">// 十进制</span><br><span class="hljs-keyword">let</span> hex : <span class="hljs-built_in">number</span> = <span class="hljs-number">0x0C</span>; <span class="hljs-comment">// 十六进制</span><br><span class="hljs-keyword">let</span> bin : <span class="hljs-built_in">number</span> = <span class="hljs-number">0b01</span>; <span class="hljs-comment">// 二进制</span><br><span class="hljs-keyword">let</span> oct : <span class="hljs-built_in">number</span> = <span class="hljs-number">0o74</span>; <span class="hljs-comment">// 八进制</span><br></code></pre></td></tr></table></figure><h4 id="字符串">1.3 字符串</h4><p>使用<code>string</code>表示文本数据类型，可以使用<code>"</code>或者<code>'</code>来表示字符串</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> name : <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;curry&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>模板字符串</strong></p><p>模板字符串使用（反引号）包围，并且可以在其中使用<code>$&#123; expr &#125;</code>嵌入表达式，<code>expr</code>既可以是模板字符串也可以是可计算的表达式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> name : <span class="hljs-built_in">string</span> = <span class="hljs-string">`zhhc`</span>;<br><span class="hljs-keyword">let</span> birth_year : <span class="hljs-built_in">number</span> = <span class="hljs-number">2002</span>;<br><span class="hljs-keyword">let</span> sentence : <span class="hljs-built_in">string</span> = <span class="hljs-string">`hello, i am <span class="hljs-subst">$&#123; name &#125;</span>, and my age is <span class="hljs-subst">$&#123; <span class="hljs-number">2022</span> - birth_year &#125;</span>`</span>;<br></code></pre></td></tr></table></figure><h4 id="数组">1.4 数组</h4><p>两种定义方式</p><ol type="1"><li>```typescript // 类型后面加[] let list : number[] = [1, 2, 3];<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br><span class="hljs-number">2.</span> ```<span class="language-javascript">typescript</span><br><span class="language-javascript">   <span class="hljs-comment">// 数组泛型 Array&lt;类型&gt;</span></span><br><span class="language-javascript">   <span class="hljs-keyword">let</span> list : <span class="hljs-title class_">Array</span>&lt;number&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="元组">1.5 元组</h4><p>元组类型表示 <u>已知数量和类型</u> 的数组，各元素的类型<u>不必相同</u></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x : [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&#x27;typescript&#x27;</span>, <span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><h4 id="枚举">1.6 枚举</h4><p>枚举是TypeScript中多出来的，和C语言等高级语言类似，可以为一组数组赋予有意义的名字，帮助理解。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><span class="hljs-keyword">let</span> c : <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>;<br></code></pre></td></tr></table></figure><p>可以通过枚举值得到其名字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><span class="hljs-keyword">let</span> green_name : <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Color</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// &quot;Green&quot;</span><br></code></pre></td></tr></table></figure><h4 id="任意值">1.7 任意值</h4><p>任意值(any)其实就像是JavaScript中的变量一样，可以被赋予任何类型的值，编译器不会进行检查。</p><p>对于Object类型的变量，你可以赋任何值，但是不能任意调用方法，即便它真的有这些方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Any</span> : <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br><span class="hljs-title class_">Any</span> = <span class="hljs-string">&quot;Curry&quot;</span>;<br><span class="hljs-title class_">Any</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">let</span> anyObject : <span class="hljs-title class_">Object</span> = <span class="hljs-number">4</span>;<br>anyObject.<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>); <span class="hljs-comment">// Error</span><br><br><span class="hljs-keyword">let</span> list : <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;free&quot;</span>];<br></code></pre></td></tr></table></figure><h4 id="空值">1.8 空值</h4><p>空值（<code>void</code>）表示没有任何类型，一般用于函数没有返回值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) : <span class="hljs-built_in">void</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>声明变量没有什么意义，只能赋值<code>null</code>或<code>undefined</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> void_v : <span class="hljs-built_in">void</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// or undefined</span><br></code></pre></td></tr></table></figure><h4 id="null-undefined">1.9 Null / Undefined</h4><p>默认情况下 <code>null</code> 和 <code>undefined</code>是所有类型的子类型，即可以将它们赋值给其他类型的变量，但是如果指定了<code>--strictNullChecks</code>，那么只能赋值给各自类型了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// without &#x27;--strictNullChecks&#x27;</span><br><span class="hljs-keyword">let</span> n : <span class="hljs-built_in">number</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> s : <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>;<br><br><span class="hljs-comment">// with &#x27;--strictNullChecks&#x27;</span><br><span class="hljs-keyword">let</span> nll : <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> udfd : <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><h4 id="never">1.10 Never</h4><p><code>never</code>表示永不存在值的类型。</p><p>对于函数，修饰那些 【抛出异常】 或 【根本就不会有返回值】的函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">erro</span>(<span class="hljs-params">message : <span class="hljs-built_in">string</span></span>) : <span class="hljs-built_in">never</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deadLoop</span>(<span class="hljs-params"></span>) : <span class="hljs-built_in">never</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于变量，<code>never</code>类型是任何类型的子类型，所以可以赋值给任何类型；但是<code>never</code>类型的变量只能由<code>never</code>赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a : <span class="hljs-built_in">number</span> = <span class="hljs-built_in">never</span>; <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">let</span> a : <span class="hljs-built_in">never</span> = <span class="hljs-built_in">any</span>; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><h4 id="类型断言">1.11 类型断言</h4><p>告诉编译器某个变量的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> s : <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;i am a string&quot;</span>;<br><br><span class="hljs-comment">// 1. &lt;断言类型&gt;变量</span><br><span class="hljs-keyword">let</span> len : <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;s).<span class="hljs-property">length</span>;<br><span class="hljs-comment">// 2. 变量 as 断言类型</span><br><span class="hljs-keyword">let</span> len : <span class="hljs-built_in">number</span> = (s <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="变量声明">2 变量声明</h3><p><code>TypeScript</code>中支持<code>let</code>和<code>const</code>，JS在ES6就支持了，主要是<code>let</code>和<code>var</code>的区别：主要就是<code>var</code>是函数级作用域，但是<code>let</code>是块级作用域。</p><h3 id="接口">3 接口</h3><p>TypeScript中最核心的原则之一就是<strong>类型</strong>，而接口就是为类型检查 定义契约。</p><p>像下面这个例子，<code>printConfig</code>函数接受一个符合<code>config</code>接口的参数，而<code>config</code>接口定义了需要含有值类型为<code>string</code>的<code>name</code>属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> config&#123;<br>    name : <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printConfig</span>(<span class="hljs-params">Aconfig : config</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> cfg = &#123;name : <span class="hljs-string">&quot;my config&quot;</span>, size : <span class="hljs-number">10</span>&#125;;<br><span class="hljs-title function_">printConfig</span>(cfg);<br></code></pre></td></tr></table></figure><h4 id="可选属性">可选属性</h4><p>这里重点需要注意的是：<strong>一旦接口中定义了可选的属性，那么被修饰的变量中只能存在要求的属性和可选的属性，不能出现其中不存在的属性。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> config&#123;<br>    name?: <span class="hljs-built_in">string</span>;<br>    size?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printConfig</span>(<span class="hljs-params">Aconfig : config</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-comment">// case one</span><br><span class="hljs-title function_">printConfig</span>(&#123;name : <span class="hljs-string">&quot;my config&quot;</span>, siz : <span class="hljs-number">10</span>&#125;); <span class="hljs-comment">// Error</span><br><br><span class="hljs-comment">// case two</span><br><span class="hljs-title function_">printConfig</span>(&#123;name : <span class="hljs-string">&quot;my config&quot;</span>, siz : <span class="hljs-number">10</span>&#125; <span class="hljs-keyword">as</span> config)<br><br><span class="hljs-comment">// case three</span><br><span class="hljs-keyword">let</span> c = &#123;name : <span class="hljs-string">&quot;my config&quot;</span>, siz : <span class="hljs-number">10</span>&#125;<br><span class="hljs-title function_">printConfig</span>(c);<br></code></pre></td></tr></table></figure><h4 id="函数类型">函数类型</h4><p>下面这个接口就定义了一个函数类型，参数是两个<code>number</code>类型的值，返回类型是<code>boolean</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> func_temp&#123;<br>    (<span class="hljs-attr">n1</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">n2</span>: <span class="hljs-built_in">number</span>) : <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">func1</span>: func_temp;<br>func1 = <span class="hljs-keyword">function</span>(<span class="hljs-params">n1, n2</span>)&#123;<br>    <span class="hljs-keyword">return</span> n1 &gt; n2;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可索引的类型">可索引的类型</h4><p>1、数字索引=》数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> number_index&#123;<br>    [index : <span class="hljs-built_in">number</span>] : <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> a : number_index = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]; <span class="hljs-comment">// a[1]</span><br></code></pre></td></tr></table></figure><p>2、字符串索引=》字典</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> string_index&#123;<br>    [index : <span class="hljs-built_in">string</span>] : <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> b : string_index = &#123;x : <span class="hljs-string">&quot;x&quot;</span>, y : <span class="hljs-string">&quot;y&quot;</span>&#125;; <span class="hljs-comment">// b[&#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure><p>3、由于当使用<code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。所以当两者一起使用时，<code>number</code>索引返回值需要是<code>string</code>索引返回值的子类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">interface</span> both_index&#123;<br>    [index : <span class="hljs-built_in">number</span>] : B;<br>    [index : <span class="hljs-built_in">string</span>] : A;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类类型">类类型</h4><p>这一部分就和其他面向对象高级语言中的类似了。</p><p>要注意类静态部分和实例部分的区别</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ACon</span>&#123;<br>    <span class="hljs-keyword">new</span> ();<br>&#125;<br><br><span class="hljs-comment">// Error</span><br><span class="hljs-comment">// 当一个类实现了一个接口，只会对其实例部分进行检查，而构造函数属于静态部分。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ACon</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ACon</span>&#123;<br>    <span class="hljs-keyword">new</span> () : <span class="hljs-title class_">AInter</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AInter</span>&#123;<br>    <span class="hljs-title function_">a_func</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createA</span>(<span class="hljs-params">acon : ACon</span>) : <span class="hljs-title class_">AInter</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">acon</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AInter</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AInter</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a1 = <span class="hljs-title function_">createA</span>(<span class="hljs-variable constant_">A1</span>);<br><span class="hljs-keyword">let</span> a2 = <span class="hljs-title function_">createA</span>(<span class="hljs-variable constant_">A2</span>);<br></code></pre></td></tr></table></figure><h4 id="混合类型">混合类型</h4><p>一个对象即可以同时作为函数和对象使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-comment">// as a function</span><br>    (<span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;<br>    <span class="hljs-comment">// as a object</span><br>    <span class="hljs-attr">interval</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-title function_">reset</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCounter</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">let</span> counter = &lt;<span class="hljs-title class_">Counter</span>&gt;<span class="hljs-keyword">function</span> (<span class="hljs-params">start: <span class="hljs-built_in">number</span></span>) &#123; &#125;;<br>    counter.<span class="hljs-property">interval</span> = <span class="hljs-number">123</span>;<br>    counter.<span class="hljs-property">reset</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; &#125;;<br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-title function_">getCounter</span>();<br><span class="hljs-title function_">c</span>(<span class="hljs-number">10</span>);<br>c.<span class="hljs-title function_">reset</span>();<br>c.<span class="hljs-property">interval</span> = <span class="hljs-number">5.0</span>;<br></code></pre></td></tr></table></figure><h4 id="接口继承类">接口继承类</h4><p>当使用接口<code>A</code>去继承类<code>B</code>时，它继承类<code>B</code>的所有成员但不包括实现。所以某个类想要实现这个接口<code>A</code>，这个类必须是类<code>B</code>本身或者是类<code>B</code>的子类，否则它不能拥有接口<code>A</code>中的<code>private</code>和<code>protect</code>成员</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Control</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">state</span>: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelectableControl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Control</span> &#123;<br>    <span class="hljs-title function_">select</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Control</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SelectableControl</span> &#123;<br>    <span class="hljs-title function_">select</span>(<span class="hljs-params"></span>) &#123; &#125;<br>&#125;<br><br><span class="hljs-comment">// Error: Property &#x27;state&#x27; is missing in type &#x27;Image&#x27;.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SelectableControl</span> &#123;<br>    <span class="hljs-title function_">select</span>(<span class="hljs-params"></span>) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类">4 类</h3><p>1、类型兼容：TypeScript使用的是结构性类型系统，当比较两种不同的类型时，并不在乎它们从何处而来，如果所有的成员的类型都是兼容的，我们认为它们的类型是兼容的。但是对于带有<code>private</code>或者<code>protected</code>成员的类型时，就需要<code>private</code>和<code>protect</code>成员来自于同一处声明时，才认为这两个类型是兼容的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> name : <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">super</span>();&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-keyword">private</span> name : <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">constuctor</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();<br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br><br>a = b; <span class="hljs-comment">// OK</span><br>a = c; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>2、参数属性：在构造函数中使用访问限定符修饰参数，使类的属性的声明和赋值合并到一处</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Per</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name : <span class="hljs-built_in">string</span></span>)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、存取器</p><p>TypeScript支持通过getter和setter来截获对对象成员的访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> _name : <span class="hljs-built_in">string</span>;<br>    <br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() : <span class="hljs-built_in">string</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newName : <span class="hljs-built_in">string</span></span>)&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getter和setter是会在访问相关属性时自动调用的，而不需要显式调用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();<br>a.<span class="hljs-property">_name</span> = <span class="hljs-string">&quot;zhhc&quot;</span>; <span class="hljs-comment">// 执行 setter 函数</span><br><span class="hljs-title function_">console</span>(a.<span class="hljs-property">_name</span>); <span class="hljs-comment">// 执行 getter 函数</span><br></code></pre></td></tr></table></figure><p>4、其他</p><p>抽象类、继承、访问修饰符</p><p>5、高级技巧</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greet</span> &#123;<br>    <span class="hljs-keyword">static</span> msg = <span class="hljs-string">&quot;Hello!&quot;</span>;<br>    greeting : <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Greet</span>.<span class="hljs-property">msg</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">GreetMaker</span> : <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Greet</span> = <span class="hljs-title class_">Greet</span>; <span class="hljs-comment">// GreetMaker拥有了Greet类的静态部分（构造函数和所有静态变量）</span><br></code></pre></td></tr></table></figure><h3 id="函数">5 函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// named function</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>)&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// anonymous function</span><br><span class="hljs-keyword">let</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类型">类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) : <span class="hljs-built_in">number</span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">let</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) : <span class="hljs-built_in">number</span>&#123;<br>    retunrn x + y;<br>&#125;<br><br><span class="hljs-comment">// 完整类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <br>    <span class="hljs-keyword">function</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) : <span class="hljs-built_in">number</span> &#123; <span class="hljs-keyword">return</span> x + y; &#125;<br></code></pre></td></tr></table></figure><h4 id="可选参数">可选参数</h4><p>注意：可变参数放最后</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>) : <span class="hljs-built_in">number</span>&#123;<br>    <span class="hljs-keyword">if</span>(z)&#123;<br>        <span class="hljs-keyword">return</span> x + y + z;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="默认参数">默认参数</h4><p>1、默认参数可以放在必须参数的最后面，该参数可以省略</p><p>2、默认参数也可以放在必须参数的最前面，该参数不能省略，需要传递<code>undefined</code>获得这个默认值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y = <span class="hljs-number">10</span></span>) : <span class="hljs-built_in">number</span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x = <span class="hljs-number">10</span>, y: <span class="hljs-built_in">number</span></span>) : <span class="hljs-built_in">number</span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-title function_">add</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// OK =&gt; 12</span><br></code></pre></td></tr></table></figure><h4 id="剩余参数">剩余参数</h4><p>剩余参数肯定是需要放在参数列表的最后</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, ...nums: <span class="hljs-built_in">number</span>[]</span>) : <span class="hljs-built_in">number</span>&#123;<br>    int sum = x + y;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++)&#123;<br>        sum += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="this">this</h4><p>this是JS中的一个难点。在JavaScript中，<strong><code>this</code>的值在调用时才会确定，</strong>这导致了this值会随着调用上下文的改变而改变。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> per = &#123;<br>    name : <span class="hljs-string">&quot;zhhc&quot;</span>,<br>    age : <span class="hljs-number">21</span>,<br>    hello : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            msg = <span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot;years old!&quot;</span>;<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Hello</span> = per.<span class="hljs-title function_">hello</span>();<br><span class="hljs-keyword">let</span> message = <span class="hljs-title class_">Hello</span>(); <span class="hljs-comment">// this =&gt; window</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br></code></pre></td></tr></table></figure><p>解决方法是使用ES6的一个新特性，箭头函数。在箭头函数中，<code>this</code>的值在创建时就确定下来了，箭头函数不会创建自己的<code>this</code>，它只会从自己的作用域链的上一层继承<code>this</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> per = &#123;<br>    name : <span class="hljs-string">&quot;zhhc&quot;</span>,<br>    age : <span class="hljs-number">21</span>,<br>    hello : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            msg = <span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot;years old!&quot;</span>;<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Hello</span> = per.<span class="hljs-title function_">hello</span>();<br><span class="hljs-keyword">let</span> message = <span class="hljs-title class_">Hello</span>(); <span class="hljs-comment">// this =&gt; per</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br></code></pre></td></tr></table></figure><h4 id="this参数">this参数</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-title function_">hello</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Person</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> per : <span class="hljs-title class_">Person</span> = &#123;<br>    name : <span class="hljs-string">&quot;zhhc&quot;</span>,<br>    age : <span class="hljs-number">21</span>,<br>    hello : <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: Person</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            msg = <span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot;years old!&quot;</span>;<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Hello</span> = per.<span class="hljs-title function_">hello</span>();<br><span class="hljs-keyword">let</span> message = <span class="hljs-title class_">Hello</span>(); <span class="hljs-comment">// this =&gt; per</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br></code></pre></td></tr></table></figure><p>明确地告诉<code>typescript</code>，<code>this</code>的类型是<code>Person</code>，而不是<code>any</code></p><h4 id="其他">其他</h4><p>函数重载</p><h3 id="泛型">6 泛型</h3><p>泛型总的来说和Java的比较类似。</p><p>1、泛型函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> identity&lt;T&gt;(arg : T) : T &#123;<br>    <span class="hljs-keyword">return</span> arg<br>&#125;<br></code></pre></td></tr></table></figure><p>2、泛型接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenericFunc</span>&lt;T&gt;&#123;<br>    (<span class="hljs-attr">arg</span>: T) : T;<br>&#125;<br><br><span class="hljs-keyword">let</span> fn : <span class="hljs-title class_">GenericFunc</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">function</span>(<span class="hljs-params">arg : <span class="hljs-built_in">number</span></span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * arg; &#125;<br></code></pre></td></tr></table></figure><p>3、泛型类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calc</span>&lt;T&gt;&#123;<br>    <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、泛型约束</p><p>由于泛型参数是针对所有类型，就会导致不能使用一些只有某些类型才具备的属性，例如<code>length</code>，解决方法就是加上泛型约束，对泛型参数加上一定的限制。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> getLen&lt;T <span class="hljs-keyword">extends</span> &#123;<span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>&#125;&gt;(<span class="hljs-attr">arg</span>: T) : T&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-Lab1</title>
      <link href="/2022/11/10/compilation-principle/compilation-principle-lab1/"/>
      <url>/2022/11/10/compilation-principle/compilation-principle-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="一实验思路">一、实验思路</h2><p>本次实验主要是写词法分析器，对语法没有要求，所以在<code>.g4</code>文件中只要写对应的词法即可。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221110105750227.png" /></p><p>然后是在<code>Main</code>函数中处理逻辑，相应的代码在手册中都已给出，主要需要实现是</p><ol type="1"><li>自己的<code>MyErrorListener</code></li><li>处理<code>tokens</code>的输出</li></ol><h3 id="myerrorlistener"><code>MyErrorListener</code></h3><p>首先需要知道代码是如何调用这个类的，所以我在实现的时候先将<code>BaseErrorListener</code>中的函数全部拷贝到<code>MyErrorListener</code>中，然后对每个函数增加一个<code>System.out.println(...)</code>，这样就可以知道在出现错误是会调用哪一个函数，最后发现是<code>syntaxError</code>函数，然后就可以去<code>Lexer</code>类中找到对应调用位置，查看是如何调用这个函数，最后编写这个函数。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221110110552598.png" /></p><h3 id="tokens输出"><code>tokens</code>输出</h3><p>首先确定<code>getAllTokens</code>函数返回的类型=&gt;<code>List&lt;? extends Token&gt;</code></p><p>在遍历<code>token</code>列表时调用<code>Token</code>类中对应函数来获取行号、类型等相关信息，再做输出。</p><blockquote><p>注意：出现错误时，只输出错误信息。</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221110110925468.png" /></p><h2 id="二碰到的问题">二、碰到的问题</h2><h3 id="输出格式">1、输出格式</h3><p>注意输出格式要严格按照手册要求。</p><h3 id="integr_const的处理">2、<code>INTEGR_CONST</code>的处理</h3><p>注意八进制数和十六进制数的处理，输出<code>token</code>时是需要输出其十进制值。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pointer networks</title>
      <link href="/2022/11/07/machine-learning/pointer-networks/"/>
      <url>/2022/11/07/machine-learning/pointer-networks/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1506.03134">PointerNetworks</a>提出了一种新的 neuralarchitecture，可以解决输出序列的大小随着输入序列的大小而变化的问题。文章开头讲到，传统的seq2seq模型以及AttentionMechanism，都只能处理固定size的输入序列。下面主要围绕这PointerNetwork展开学习。</p><p>首先需要回顾 seq2seq 模型 和 Attention 机制</p><h2 id="seq2seq-model">1 Seq2Seq Model</h2><p>传统的 seq2seq model 是由两个 RNN 构成，一个作为 Encoder ，另一个作为Decoder。在输入 input sequence后，由Encoder进行处理，形成一个 EncoderVector 送到 Decoder，由 Decoder 产生最终结果。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230223151535807.png" /></p><blockquote><p><ahref="https://towardsdatascience.com/understanding-encoder-decoder-sequence-to-sequence-model-679e04af4346">UnderstandingEncoder-Decoder Sequence to Sequence Model</a></p></blockquote><ol type="1"><li>Encoder 部分由 若干个 RNN 单元构成，每个单元接受前一个单元的 hiddenstate 和当前 input sequence 中的输入元素，生成新的 hidden state并且向前传递。<spanclass="math inline">\(h_{i}\)</span>表示前面所有输入信息的 hiddenstate，计算公式为 <span class="math inline">\(h_{t} = f(W^{hh}h_{t-1} +W^{hx}x_{t})\)</span></li><li>Encoder Vector是Encoder部分的输出，也是最后一个 hiddenstate，并作为Decoder部分的初始hidden state输入Decoder。</li><li>Decoder 部分同样由若干个 RNN 单元构成，每个单元接受前一个单元的hidden state，生成当前状态下的 hidden state，并预测当前的输出。hiddenstate的公式为：<span class="math inline">\(h_{t} =f(W^{hh}h_{t-1})\)</span>，预测输出的公式为：<spanclass="math inline">\(y_{t} = softmax(W^{s}h_{t})\)</span></li></ol><p>seq2seq模型的一个很重要的好处在于 input sequence 和 output sequence的大小可以不一致。</p><p>但是seq2seq不能处理 output dictionary的大小会发生变化的任务，因为seq2seq处理一项特定的任务时，其 outputdictionary 是不会发生变化的，是一个相对固定的域，但是在<ahref="https://arxiv.org/abs/1506.03134">PointerNetworks</a>文章中所提到的闭包问题等组合相关问题，它们的 outputdictionary 是和 input sequence 密切相关的。比如，给定10个点 {<spanclass="math inline">\(P_{1}, P_{2}, ...,P_{10}\)</span>}，要找到一个闭包，那结果肯定是这10个点的子集；如果换10个点，那结果就应该是新的10个点的子集。</p><blockquote><p><ahref="https://kierszbaumsamuel.medium.com/pointer-networks-what-are-they-c3cb68fae076">Pointernetworks : What are they?</a></p></blockquote><h2 id="with-attention">2 with Attention</h2><p>上面提到了，seq2seq模型的Encoder部分将inputsequence转换成一个vector，也叫context，Decoder根据这个context做输出预测。这样的话，这个contextvector就成为模型性能的瓶颈了，模型输出结果的正确性取决于这个contextvector能多好地表达input sequence。</p><p>引入Attention机制，使得模型专注在input sequence的相关部分。</p><p>Attention机制主要在两个地方做了改进</p><ol type="1"><li><p>给Decoder部分传递<strong>所有的 hidden state</strong>，而不是一个context vector。</p></li><li><p>在Decoder的每一步，为所有的 hidden state 打分，用 softmax后的分数乘上对应的 hidden state，然后加和形成<strong>这一步的 contextvector</strong>。之后，得到的 context vector 和 Decoder hidden state做连接，得到新的 vector 传递给 <strong>feedforward neuralnetwork</strong>，最后得到该步的输出。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230223151644271.png" /></p></li></ol><p><strong>完整步骤</strong></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230223151605426.png" /></p><blockquote><p><ahref="http://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/">VisualizingA Neural Machine Translation Model (Mechanics of Seq2seq Models WithAttention)</a></p></blockquote><p>然后我们看看论文中对于Attention机制给的公式</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230223151703767.png" /></p><ol type="1"><li>第①个公式相当于就是上面说的打分，得到的<spanclass="math inline">\(u_{j}^{i}\)</span>表示的是在 time-step 'i'时，对Encoder的第 j 个 hidden state 的打分。</li><li>第②个公式：使用 <span class="math inline">\(softmax\)</span>函数对打分进行处理。</li><li>第③个公式：将 <span class="math inline">\(softmax\)</span> 后的分数<span class="math inline">\(\times\)</span> Encoder的对应 hiddenstate，并加和算出这一步的 context vector。</li></ol><h2 id="pointer-networks">3 Pointer Networks</h2><p>而 Pointer Network 所做的改变就是，<strong>在 <spanclass="math inline">\(softmax\)</span> 函数处理完打分后，选择其中最大权重 的元素直接作为该步的输出</strong>。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230223151722007.png" /></p><p>如图，第一个时间步的输出是 "1"，那么在下一个时间步，输入<spanclass="math inline">\([x_1,y_1]\)</span>的相应token和上一个时间步的hidden state 会被传递给网络以计算当前的 hidden state。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230223151744258.png" /></p><p>这样就使得输出序列完全取决于输入序列，所以可以很好适应输入序列大小的变化。</p><h2 id="ptr的应用">4 Ptr的应用</h2><h3 id="abstractive-text-summarization">abstractive textsummarization</h3><p>首先<code>text summarization</code>分为<code>extractive</code>和<code>abstractive</code>两种，<code>extractive</code>是指通过选择和重组原文中的句子或短语形成的<code>summarization</code>，而<code>abstractive</code>是指更高级的概括，会产生全新的词语，像人写<code>abstract</code>那样。</p><p><a href="https://arxiv.org/abs/1704.04368">Get To The Point:Summarization with Pointer-GeneratorNetworks</a>介绍了一种<code>hybrid pointer-generator network</code>+<code>coverage mechanism</code>的架构来处理这一任务，可以很好地解决：①不能准确再现细节；②不能处理超出词汇表以外的单词；③出现重复。其中<code>hybrid pointer-generator network</code>主要解决①②，而<code>coverage mechanism</code>解决③。</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221118003614644.png" /></p><p>上图主要是<code>hybrid pointer-generator network</code>的结构。之所以是<code>hybrid</code>，是因为这里不是单纯使用<code>pointer</code>，而是将<code>pointer</code>和原先<code>seq2seq-with-attention</code>结合起来的。从图中我们可看到有两个<code>distribution</code>，一个是<code>attention distribution</code>，它就是<code>pointer network</code>中的<code>pointer</code>，反应的是<code>source text</code>中的分布；另一个是<code>vocabulary distribution</code>，这个就是正常<code>seq2seq</code>模型会产生的针对<code>output dictionary</code>的分布。这两个分布是通过<spanclass="math inline">\(p_{gen}\)</span>结合起来的，最后形成一个总的<code>distribution</code>，由此产生结果。</p><p>而<code>coverage mechanism</code>则是插入在产生<code>attention distribution</code>的步骤中，因为它是用来反映<code>source text</code>中单词在结果中的覆盖程度，通过将它加入<code>attention distribution</code>的计算中，起到一个反馈的作用，从而有效减少重复问题。（下式红框部分就是<code>coverage vector</code>作为额外输入传递给<code>attention</code>机制的计算中）</p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221118004630172.png" /></p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划应用</title>
      <link href="/2022/10/31/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E7%94%A8%E9%A2%98/"/>
      <url>/2022/10/31/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E7%94%A8%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一股票问题">一、股票问题(*)</h2><blockquote><p><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188.买卖股票的最佳时机 IV</a></p><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i]是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><p>labuladong算法秘籍中使用了【三个<strong>状态</strong>】（三维dp数组）</p><ol type="1"><li>第几天</li><li>手中是否持有股票</li><li>最大交易限制（最大交易限制只在买入股票时减一）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// dp[i][j][k] 意味着在第i天，手中持有(j=1)或不持有(j=0)股票，最大交易限制为k情况下的最大利润</span><br></code></pre></td></tr></table></figure><p><strong>状态转移方程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][<span class="hljs-number">0</span>][k] = Math.max(<br>    dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k],  <span class="hljs-comment">// 第i天 不买入不卖出: 第i-1天也没有股票，交易限制还是k</span><br>    dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k]+prices[i-<span class="hljs-number">1</span>] <span class="hljs-comment">// 第i天 卖出: 第i-1天有股票，交易限制还是k</span><br>);<br>dp[i][<span class="hljs-number">1</span>][k] = Math.max(<br>    dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k], <span class="hljs-comment">// 第i天 不买入不卖出: 第i-1天有股票，交易限制为k</span><br>    dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k-<span class="hljs-number">1</span>]-prices[i-<span class="hljs-number">1</span>] <span class="hljs-comment">// 第i天 买入: 第i-1天没有股票，最大交易次数不能超过k-1</span><br>);<br></code></pre></td></tr></table></figure><p><strong>base case</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][...] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][...] = Integer.MIN_VALUE;<br>dp[...][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[...][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Integer.MIN_VALUE;<br></code></pre></td></tr></table></figure><h2 id="二打劫家舍问题">二、打劫家舍问题</h2><blockquote><p><ahref="%5B198.%20打家劫舍%20-%20力扣（LeetCode）%5D(https://leetcode.cn/problems/house-robber/)">198.打劫家舍</a></p><p><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍II</a></p><p><a href="https://leetcode.cn/problems/house-robber-iii/">337.打家劫舍 III</a></p></blockquote><h3 id="打劫家舍">1、打劫家舍</h3><p>【状态】是 <u>抢劫第i家时能获得的最大金额</u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 状态转移方程</span><br>dp[i] = Math.max(dp[i-<span class="hljs-number">2</span>], dp[i-<span class="hljs-number">3</span>]) + nums[i];<br></code></pre></td></tr></table></figure><h3 id="打劫家舍ⅱ">2、打劫家舍Ⅱ</h3><blockquote><p>特别之处在于 nums 换成了环形数组</p></blockquote><p>应对策略也十分巧妙</p><p><span class="math inline">\(f([x_{1}, x_{2}, ... , x_{n}]) = max(f([x_{1}, x_{2}, ..., x_{n-1}]), f([x_{2}, ..., x_{n}]) )\)</span></p><p><u><strong>既然首尾相连了，那么肯定最多只能抢劫一家，把另外一家除去</strong></u>，就把环形数组又变成了普通数组了。</p><h3 id="打劫家舍ⅲ">3、打劫家舍Ⅲ</h3><blockquote><p>把家舍的形状变成了二叉树</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] res = dp(root);<br>        <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// return &#123;x, y&#125; </span><br>    <span class="hljs-comment">// x: 包括root节点的最高金额 </span><br>    <span class="hljs-comment">// y: 不包含root节点的最高金额</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dp(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] left = dp(root.left);<br>        <span class="hljs-type">int</span>[] right = dp(root.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> left[<span class="hljs-number">1</span>] + right[<span class="hljs-number">1</span>] + root.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> Math.max(left[<span class="hljs-number">1</span>], left[<span class="hljs-number">0</span>]) + Math.max(right[<span class="hljs-number">1</span>], right[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三博弈问题">三、博弈问题</h2><blockquote><p><a href="https://leetcode.cn/problems/predict-the-winner/">486.预测赢家</a></p></blockquote><p>最核心最关键的还是在【找状态】，理解！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一种比较容易理解的，三维数组</span><br><span class="hljs-comment">// dp[i][j][0] 表示在[xi...xj]区间时，先手的最大得分</span><br>dp[i][j][<span class="hljs-number">0</span>] = Math.max(nums[i]+dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>], nums[j]+dp[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// [i...j] 先手可以选择i也可以选择j</span><br><span class="hljs-comment">// 选择i后，在[i+1...j]区间就变成了后手，就是dp[i+1][j][1]</span><br><span class="hljs-comment">// 选择j后，在[i...j+1]区间就变成了后手，就是dp[i][j-1][1]</span><br><span class="hljs-keyword">if</span> 先手选择了i: dp[i][j][<span class="hljs-number">1</span>] = dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> 先手选择了j: dp[i][j][<span class="hljs-number">1</span>] = dp[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br><br><br><span class="hljs-comment">// 第二种稍微改进一点，二维数组</span><br><span class="hljs-comment">// dp[i][j][1] 表示在[xi...xj]区间时，先手的最大得分-后手的最大得分</span><br>dp[i][j] = Math.max(nums[i] - dp[i+<span class="hljs-number">1</span>][j], nums[j] - dp[i][j-<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 在[i...j]先手做出选择后，就变成了后手，所以是&lt;减&gt;</span><br></code></pre></td></tr></table></figure><h2 id="四扔鸡蛋">四、扔鸡蛋（***）</h2><blockquote><p><ahref="https://leetcode.cn/problems/super-egg-drop/">887.鸡蛋掉落</a></p><p>这道题理解上难度很高...</p></blockquote><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221104212852347.png" /></p><p>这里讲一个逆向思维。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] 表示有j个鸡蛋，可以操作i次，可以在最高dp[i][j]的建筑里保证找到f<br></code></pre></td></tr></table></figure><p>比如<code>dp[2][1]=2</code>，表示有1个鸡蛋，可以操作2次，可以在最高2楼的建筑里保证找到<code>f</code>。意思就是如果楼<code>&gt;=</code>3，就不能保证在1个鸡蛋2次操作的情况下找到f。这里的保证是指不管在什么情况下都可以成功找到f，而不是说有一定概率可以找到。很好理解，不管多高的楼层，即使给1个鸡蛋1次操作，也有一定概率可以找到f（第1层就碎了，所以<code>f=0</code>）</p><p>理解完状态之后，就需要找到状态转移方程。先给出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = <span class="hljs-number">1</span> + dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + dp[i][j-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>这里应该是这道题最难理解的地方。</p><h2 id="五自由之路">五、自由之路</h2><blockquote><p><a href="https://leetcode.cn/problems/freedom-trail/">514.自由之路</a><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221109163239286.png" /></p></blockquote><p>这道题一眼看去和普通的动态规划没什么区别，<strong>给定两个字符串，求某个最值</strong>。</p><p>但是这里的<code>ring</code>是环形的，而且可以顺时针/逆时针旋转，就导致每次的局部最优可能得不到全局最优，有点像回溯算法，需要走到更后面才能知道这一次的选择是否是更优的。</p><p>所以需要在每一步都要列出所有情况，在最后再选出最小的。</p><p>可以这么定义<code>dp</code>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] 表示 匹配key的第i个字符时 ring的第j个字符指向<span class="hljs-number">12</span>:<span class="hljs-number">00</span> (当然了ring的第j个字符和key的第i个字符是相同的) 所需要的最小步数<br></code></pre></td></tr></table></figure><p>状态转移方程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = Math.min( dp[i-<span class="hljs-number">1</span>][k] + Math.min( Math.abs(j-k), n - Math.abs(j-k) ) ) k是ring中所有字符等于key[i-<span class="hljs-number">1</span>]的下标集合<br></code></pre></td></tr></table></figure><p>含义是：当用ring的第j个字符去匹配key的第i个字符时，所需要的最小步数应该这么求</p><p>列举出前一次匹配的所有情况<span class="math inline">\(dp[i-1][k], k\in[key的第i-1个字符在ring中的下标集合]\)</span>，计算从每一次的情况走到当前情况需要的更小的步数（因为可以顺时针转也可以逆时针转），最后取这些情况的最小值。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRotateSteps</span><span class="hljs-params">(String ring, String key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ring.length(); <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> key.length();<br>    <span class="hljs-comment">// 将ring中的字符转换为对应下标</span><br>    List&lt;Integer&gt;[] char2idx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>        char2idx[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        char2idx[ring.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>].add(i);<br>    &#125;<br>    <span class="hljs-comment">// 定义并初始化dp数组</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++) Arrays.fill(dp[i], <span class="hljs-number">0x3f3f3f</span>);<br>    <span class="hljs-comment">// base case: dp[0][...]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : char2idx[key.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>        dp[<span class="hljs-number">0</span>][i] = Math.min( i, m-i ) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 递推过程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : char2idx[key.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k : char2idx[key.charAt(i-<span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>                dp[i][j] = Math.min(<br>                    dp[i][j],<br>                dp[i-<span class="hljs-number">1</span>][k] <br>                    + Math.min( <br>                    Math.abs(j-k),<br>                        m-Math.abs(j-k)<br>                      ) <br>                    + <span class="hljs-number">1</span><br>                );<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Arrays.stream(dp[n-<span class="hljs-number">1</span>]).min().getAsInt();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六k-站中转内最便宜的航班">六、K 站中转内最便宜的航班</h2><blockquote><p><ahref="https://leetcode.cn/problems/cheapest-flights-within-k-stops/">787.K站中转内最便宜的航班</a></p><p><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221112013321045.png" /></p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221112013403828.png"alt="image-20221112013403828" /><figcaption aria-hidden="true">image-20221112013403828</figcaption></figure></blockquote><p>这道题既可以使用Dijkstra算法，也可以使用动态规划算法来解决。</p><p>这道题的起点和终点是确定的，在状态转移过程中选定一个不变，将另一个作为状态，然后另外一个状态就是中转站数k(或者使用边数来表示)</p><p>这里将<code>src</code>固定，将终点和中转站数作为状态，可以写出如下转移方程</p><p><span class="math inline">\(price(k,dst) = min(price(k-1, v) +val(v,dst))\)</span><code>v</code>是距离<code>dst</code>还有一步的节点，<spanclass="math inline">\(val(v,dst)\)</span>指边的价值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-type">int</span>[]&gt;[] graph;<br><span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> <span class="hljs-number">999999</span>;<br><span class="hljs-type">int</span> src;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] flights, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-built_in">this</span>.src = src;<br>    graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) graph[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] flight : flights)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">2</span>];<br>        graph[to].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;from, price&#125;);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span>[][] mem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k+<span class="hljs-number">2</span>][n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k+<span class="hljs-number">2</span>; i++) Arrays.fill(mem[i], inf);<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> dp(dst, k+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> ans == inf ? -<span class="hljs-number">1</span> : ans;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-keyword">if</span>(d == src) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> inf;<br>    <br>    <span class="hljs-keyword">if</span>(mem[k][d] != inf)&#123;<br>        <span class="hljs-keyword">return</span> mem[k][d];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] prev : graph[d])&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sub_ans</span> <span class="hljs-operator">=</span> dp(prev[<span class="hljs-number">0</span>], k-<span class="hljs-number">1</span>);<br>        mem[k][d] = Math.min(mem[k][d], sub_ans + prev[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> mem[k][d];<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种更加简便的，去求所有从src开始走1步、2步、...、k+1步到达某节点的最小代价：使用<code>dp[i][j]</code>表示从<code>src</code>走<code>i</code>步到<code>j</code>节点所需要的最小代价。最后只要求<spanclass="math inline">\(min(dp[1][dst],dp[2][dst],...,dp[k+1][dst])\)</span>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] flights, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k+<span class="hljs-number">2</span>][n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= k+<span class="hljs-number">1</span>; i++) Arrays.fill(dp[i], <span class="hljs-number">999999</span>);<br>    dp[<span class="hljs-number">0</span>][src] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k+<span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] flight : flights)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">2</span>];<br>            dp[i][to] = Math.min(dp[i][to], dp[i-<span class="hljs-number">1</span>][from]+price);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">999999</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k+<span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(res &gt; dp[i][dst])&#123;<br>            res = dp[i][dst];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res == <span class="hljs-number">999999</span> ? -<span class="hljs-number">1</span> : res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记6-图论</title>
      <link href="/2022/10/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B06%EF%BC%88%E5%9B%BE%E8%AE%BA%EF%BC%89/"/>
      <url>/2022/10/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B06%EF%BC%88%E5%9B%BE%E8%AE%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一图论基础">一、图论基础</h2><h3 id="图的表示">1、图的表示</h3><p>图可以分为：</p><ul><li>有向无权图</li><li>有向有权图</li><li>无向无权图</li><li>无向有权图</li></ul><h4 id="邻接表">1.1、邻接表</h4><p>对于邻接表来说</p><ul><li><p>有向/无向：没有影响，在相应结点的邻居结点表中增减即可</p></li><li><p>有权/无权：对结构有一定影响。</p><p>有权：<code>List&lt;int[]&gt;[] graph</code>其中<code>List</code>中的<code>int[]</code>放两个值，一个是结点值，一个是权重</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt;[] graph; <span class="hljs-comment">// int[][] 结构也可</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length; i++)&#123; <span class="hljs-comment">// 遍历结点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; graph[i].length; j++)&#123; <span class="hljs-comment">// 遍历每个结点的邻居结点</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="邻接矩阵">1.2、邻接矩阵</h4><p>对于临界矩阵来说</p><ul><li>有向/无向：遍历矩阵的【右上角】和【全部】的区别</li><li>有权/无权：矩阵中的值是<code>0/int</code>和<code>0/1</code>的区别</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] graph; <span class="hljs-comment">// n*n的矩阵</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123; <span class="hljs-comment">// 遍历起始节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123; <span class="hljs-comment">// 遍历终止结点</span><br>        graph[i][j] <span class="hljs-comment">// 1表示存在从i结点到j结点的路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图的遍历">2、图的遍历</h3><p>图的遍历一般程度上可以理解为多叉树的遍历，但是需要注意【环的存在】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> visited; <span class="hljs-comment">// 记录结点是否已经访问过</span><br>List&lt;Integer&gt; path; <span class="hljs-comment">// 记录一条路径</span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(Graph graph, <span class="hljs-type">int</span> s)</span>&#123;<br>    <span class="hljs-keyword">if</span>(visited[s])&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    visited[s] = <span class="hljs-literal">true</span>;<br>    path.add(s);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> neighbor : graph.neighbors(s))&#123;<br>        traversal(graph, neighbor);<br>    &#125;<br>    <span class="hljs-comment">// 回溯</span><br>    path.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(s));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题">3、例题</h3><p>【797. 所有可能的路径】</p><blockquote><p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点n-1 的路径并输出（不要求按特定顺序）</p><p>graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点graph[i][j]存在一条有向边）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; paths;<br>List&lt;Integer&gt; path;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>    paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    traversal(graph, <span class="hljs-number">0</span>, graph.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> paths;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span>&#123;<br>    path.add(begin);<br>    <span class="hljs-keyword">if</span>(begin == end) &#123;<br>        paths.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        path.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(begin));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph[begin].length; i++)&#123;<br>        traversal(graph, graph[begin][i], end);<br>    &#125;<br>    path.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(begin));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二拓扑排序">二、拓扑排序</h2><h3 id="图的生成与遍历">0、图的生成与遍历</h3><p>给定图的结点数<code>n</code>，以及结点之间的依赖关系<code>dependency</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">n(int) 节点数</span><br><span class="hljs-comment">dependency(int[][]) 结点之间依赖关系 dependency[i]是一个[from, to]的二元数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> List&lt;Integer&gt;[] buildGraph(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] dependency)&#123;<br>    List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        graph[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] pair : dependency)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> pair[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> pair[<span class="hljs-number">1</span>];<br>        graph[from].add(to);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> graph;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断是否存在环">1、判断是否存在环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span>[] visited;<br><span class="hljs-type">boolean</span>[] onPath;<br><span class="hljs-type">boolean</span> isCycle;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> s)</span>&#123;<br>    <span class="hljs-keyword">if</span>(onPath[s])&#123;<br>        isCycle = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(visited[s])&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    visited[s] = <span class="hljs-literal">true</span>;<br>    onPath[s] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> neighbor : graph[s])&#123;<br>        traversal(graph, neighbor);<br>    &#125;<br>    <br>    onPath[s] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑序列">2、拓扑序列</h3><blockquote><p><a href="https://leetcode.cn/problems/course-schedule/">207.课程表</a></p></blockquote><p>如果图G中不存在环，G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 改造一下traversal函数</span><br><span class="hljs-type">boolean</span>[] visited;<br><span class="hljs-type">boolean</span>[] onPath;<br><span class="hljs-type">boolean</span> isCycle;<br><br>List&lt;Integer&gt; postOrder;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> s)</span>&#123;<br>    <span class="hljs-keyword">if</span>(onPath[s])&#123;<br>        isCycle = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(visited[s])&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    onPath[s] = <span class="hljs-literal">true</span>;<br>    visited[s] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] neighbor : graph[s])&#123;<br>        traversal(graph, s);<br>    &#125;<br>    <br>    onPath[s] = <span class="hljs-literal">false</span>;<br>    postOrder.add(s);<br>&#125;<br><br><span class="hljs-comment">// 最后再将postOrder逆序得到就是结果</span><br></code></pre></td></tr></table></figure><p>【重点理解：为什么图的后序遍历就是拓扑排序】</p><p>如果图中不存在环，那么图就可以看成是一颗多叉树，如图。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029210620536.png"alt="image-20221029210620536" /><figcaption aria-hidden="true">image-20221029210620536</figcaption></figure><p>那么从结点<code>0</code>开始的后序遍历的序列之一就是<code>[7,9,16,11, |  6,10,8,19,2, |  3,4,5, |  0]</code></p><p>其实就是从最底层到最高层的排列。</p><p><strong>它满足了<code>from</code>结点都在<code>to</code>结点的后面</strong>（所以最后结果需要逆序，使from结点在前面）</p><p>【局部 ==》全局】</p><p>而这只是这个图的一部分，可以把这部分抽象成一个结点<strong><code>S</code></strong>，那么同样使用前面的函数，在得到的遍历结果中，图中直接指向或者间接指向<strong><code>S</code></strong>的结点都会在其后面，逆序之后就在前面，所以得出的结果就是正确的。</p><p>（同时在细节上<code>visited</code>和<code>onPath</code>数组保证结点只被遍历一次以及不会出现环）</p><h2 id="三二分图">三、二分图</h2><blockquote><p>二分图：直观的理解就是能够用两种颜色给一张图上色，使得每条边两端的结点颜色不同</p></blockquote><h3 id="判断二分图">【判断二分图】</h3><p>思路：一边遍历，一边给图上色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span>[] visited; <span class="hljs-comment">// 记录结点是否被访问</span><br><span class="hljs-type">boolean</span>[] color; <span class="hljs-comment">// 记录结点的颜色 true 和 false 两种</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isBinary</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length; <span class="hljs-comment">// 结点数</span><br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>    color = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[i])<br>        traversal(graph, i); <span class="hljs-comment">// 遍历不同的liang</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> isBinary;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 这里的 color 被new了之后每一个值都是 false 也就成了默认的颜色，只需要去改变对应结点的颜色即可</span><br><span class="hljs-comment">* 由于这里的图是无向图，所以traversal一个结点就是遍历这个连通分支</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> v)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!isBinary) <span class="hljs-keyword">return</span>;<br>    <br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w : graph[v])&#123;<br>        <span class="hljs-keyword">if</span>(!visited[w])&#123;<br>            color[w] = !color[v];<br>            traversal(graph, w);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(color[w] == color[v])&#123;<br>                isBinary = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四union-find-算法">四、Union-Find 算法</h2><h3 id="union-find的算法思想">1、union-find的算法思想</h3><ul><li>基本思想：用下标代替实际的结点，parent数组存储父结点，这样就可以较为快速的实现【合并】和【判断是否相连】的操作</li><li>进阶思想：无论是 union 操作还是 connected 操作，其复杂度的局限都在于find函数，即从一个结点找到根节点的过程，如果这个结点距离结点越近，复杂度越低。而结点与根节点的距离一方面取决于union时的插入方式，如果插入不当，就可能形成链式的连通分量，复杂度是最高的，我们希望尽量降低树的高度，可以在union 中采取 【小树插大树】的方式，使得树的高度尽可能的小。</li><li>路径压缩：在 find过程中，在从当前结点向上寻找的过程中，不断的压缩路径（将该结点连到其父结点的父结点上），使得树的高度始终维持在常数复杂度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-type">int</span> count; <span class="hljs-comment">// 连通分量个数</span><br>    <span class="hljs-type">int</span>[] parent; <span class="hljs-comment">// 结点的父节点</span><br>    <span class="hljs-type">int</span>[] size; <span class="hljs-comment">// 该节点所处连通分量的结点数</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-built_in">this</span>.count = n;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            parent[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootP</span> <span class="hljs-operator">=</span> find(p);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootQ</span> <span class="hljs-operator">=</span> find(q);<br>        <span class="hljs-keyword">if</span>(rootP == rootQ)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 小树插到大树上，保持树的平衡 维持 logN 的时间复杂度</span><br><span class="hljs-comment">        * */</span><br>        <span class="hljs-keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;<br>            parent[rootQ] = rootP;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootP] = rootQ;<br>        &#125;<br>        size[rootP] += size[rootQ];<br>        size[rootQ] += size[rootP];<br>        count--;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootP</span> <span class="hljs-operator">=</span> find(p);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootQ</span> <span class="hljs-operator">=</span> find(q);<br>        <span class="hljs-keyword">return</span> rootP == rootQ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>&#123;<br>        <span class="hljs-keyword">if</span>(p &gt;= parent.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (parent[p] != p)&#123;<br>            parent[p] = parent[parent[p]]; <span class="hljs-comment">// 路径压缩 使得所有非根结点都直接连接在根上 使树高维持在2</span><br>            p = parent[p];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="union-find算法的应用">2、Union-Find算法的应用</h3><h4 id="被围绕的区域">2.1、130. 被围绕的区域</h4><blockquote><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符<code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code>围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code>填充。</p></blockquote><p>这道题其实使用DFS算法可以很好地解决，但是也是可以体现Union-Find算法思想的一道题目</p><p><strong>加深对于DFS算法的理解</strong></p><p>DFS算法是深度优先，在二叉树中体现为从根节点不断地向叶节点前进，在图中是体现为从一个结点不断地向其邻居结点前进。</p><p>其实在这道题中，把这个矩阵理解为一副图的话，DFS就显得比较自然了</p><p>1、遍历矩阵的四周，如果是<code>'O'</code>，则进入<code>dfs</code>，将所有与其相连的<code>'O'</code>变成特殊符号</p><p>2、遍历矩阵，将特殊符号变回<code>'O'</code>，把<code>'O'</code>变成<code>'X'</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 DFS 解决</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    x x x x</span><br><span class="hljs-comment">    x o x o</span><br><span class="hljs-comment">    x o o x</span><br><span class="hljs-comment">    o x x o</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [要深入理解 dfs 的内涵]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    边界坐标的特点: [0/m-1][0/n-1]</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span>&#123;<br>        m = board.length;<br>        n = board[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// 遍历board的四条边</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                dfsHelper(board, i, j);<br>            &#125;<br>            <span class="hljs-type">int</span>[] next = forward(i,j);<br>            i = next[<span class="hljs-number">0</span>];<br>            j = next[<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>  || j &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// ① 考虑到 forward 函数会返回 &#123;-1, -1&#125; 所以要改成 &gt;0</span><br><br>        <span class="hljs-comment">// 遍历整个board 把 &#x27;O&#x27; 换成 &#x27;X&#x27; 把 &#x27;#&#x27; 换成 &#x27;O&#x27;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; a &lt; m; a++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; b &lt; n; b++)&#123;<br>                <span class="hljs-keyword">if</span> (board[a][b] == <span class="hljs-string">&#x27;O&#x27;</span>) board[a][b] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (board[a][b] == <span class="hljs-string">&#x27;#&#x27;</span>) board[a][b] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 这里的 DFS 就有些不同于 树的 DFS</span><br><span class="hljs-comment">    * DFS: 只处理一个结点，然后用递归向四周扩散深入</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfsHelper</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里要改成 != &#x27;O&#x27; 而不是 == &#x27;X&#x27;</span><br><span class="hljs-comment">        != &#x27;O&#x27; 针对的是两种情况 == &#x27;X&#x27; 和 == &#x27;#&#x27;</span><br><span class="hljs-comment">        == &#x27;X&#x27; 肯定是直接 return</span><br><span class="hljs-comment">        == &#x27;#&#x27; 的情况，其实也可以return 因为这个 &#x27;#&#x27; 周围的格子已经被遍历过了 (在其从&#x27;O&#x27;变成&#x27;#&#x27;之后)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span>(board[x][y] != <span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(board[x][y] == <span class="hljs-string">&#x27;O&#x27;</span>) board[x][y] = <span class="hljs-string">&#x27;#&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) dfsHelper(board, x - <span class="hljs-number">1</span>, y); <span class="hljs-comment">// 上</span><br>        <span class="hljs-keyword">if</span> (x &lt; m - <span class="hljs-number">1</span>) dfsHelper(board, x + <span class="hljs-number">1</span>, y); <span class="hljs-comment">// 下</span><br>        <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>) dfsHelper(board, x, y - <span class="hljs-number">1</span>); <span class="hljs-comment">// 左</span><br>        <span class="hljs-keyword">if</span> (y &lt; n - <span class="hljs-number">1</span>) dfsHelper(board, x, y + <span class="hljs-number">1</span>); <span class="hljs-comment">// 右</span><br>    &#125;<br><br>    <span class="hljs-comment">// 在board的四个边上前进</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] forward(<span class="hljs-type">int</span> i , <span class="hljs-type">int</span> j)&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j + <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 上 向右走</span><br>        <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span> &amp;&amp; i &lt; m - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i + <span class="hljs-number">1</span>, j&#125;; <span class="hljs-comment">// 右 向下走</span><br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j - <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 下 向左走</span><br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i - <span class="hljs-number">1</span>, j&#125;; <span class="hljs-comment">// 左 向上走</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>这道题也是很好的体现，Union-Find的思想在二位数组（矩阵）中判断连通性的例子</strong></p><ul><li>根据题意知道：在矩阵的<code>'O'</code>及与其相连的<code>'O'</code>是属于不被替换的<code>'O'</code>，可以算作一个连通分量。<strong>【利用一个dummy结点和它们相连】</strong>，为什么再找一个dummy结点呢？方便查找。在后续判断这个<code>'O'</code>是否需要被替换时，只需要判断是否和这个dummy结点连通即可。</li><li>遍历完四周之后，再次遍历即可完成替换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 union-find 解决</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uf</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>    <br>    <span class="hljs-comment">// 最后一个dummy作为 不被 &#x27;X&#x27; 替换的&#x27;O&#x27; 的联通分量中的一个结点 来寻找该连通分量中的其他结点</span><br>    <span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n*m+<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> i * n + j; <span class="hljs-comment">// 二维数组转化为一维</span><br>            <br>            <span class="hljs-comment">// 将矩阵四周的&#x27;O&#x27;和dummy连通</span><br>            <span class="hljs-keyword">if</span>( (i == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == n - <span class="hljs-number">1</span>) &amp;&amp;<br>                        board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> )&#123;<br>                uf.union(val, n*m);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 上</span><br>                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; board[i-<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>) uf.union((i-<span class="hljs-number">1</span>)*n+j, val);<br>                <span class="hljs-comment">// 下</span><br>                <span class="hljs-keyword">if</span> (i &lt; m - <span class="hljs-number">1</span> &amp;&amp; board[i+<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>) uf.union((i+<span class="hljs-number">1</span>)*n+j, val);<br>                <span class="hljs-comment">// 左</span><br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; board[i][j-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) uf.union(i*n+(j-<span class="hljs-number">1</span>), val);<br>                <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; board[i][j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) uf.union(i*n+(j+<span class="hljs-number">1</span>), val);<br>                <span class="hljs-comment">/* </span><br><span class="hljs-comment">                // 如果不在能够连通分量中 则改成 X</span><br><span class="hljs-comment">                if (!uf.connected(val, n*m))&#123;</span><br><span class="hljs-comment">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                 */</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; !uf.connected(i*n+j, n*m))&#123;<br>                board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="等式方程的可满足性">2.2、990. 等式方程的可满足性</h4><p>这道题就是典型需要利用Union-Find解决。相等和不相等就相当于连通和不连通，核心就是<code>union</code> 和 判断是否 <code>connected</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equationsPossible</span><span class="hljs-params">(String[] equations)</span> &#123;<br>    <span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(<span class="hljs-number">26</span>);<br>    <span class="hljs-keyword">for</span> (String equation : equations) &#123;<br>        <span class="hljs-keyword">if</span>(equation.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> equation.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> equation.charAt(<span class="hljs-number">3</span>);<br>        uf.union(c1-<span class="hljs-string">&#x27;a&#x27;</span>, c2-<span class="hljs-string">&#x27;a&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (String equation : equations) &#123;<br>        <span class="hljs-keyword">if</span> (equation.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> equation.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> equation.charAt(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">if</span>(uf.connected(c1-<span class="hljs-string">&#x27;a&#x27;</span>, c2-<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五最小生成树算法">五、最小生成树算法</h2><h3 id="kruskal算法">Kruskal算法</h3><ol type="1"><li>对所有边进行排序</li><li>从权重最小的边开始，依次将边加入到结点集中</li><li>检查是否产生环（并查集），如果有就剔除</li></ol><blockquote><p><ahref="https://leetcode.cn/problems/min-cost-to-connect-all-points/">1584.连接所有点的最小费用</a></p><p>给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi,yi] 。</p><p>连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi -xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有一条简单路径时，才认为所有点都已连接。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kruskal 最小生成树算法</span><br><span class="hljs-comment"> * 1584. 连接所有点的最小费用</span><br><span class="hljs-comment"> * https://leetcode.cn/problems/min-cost-to-connect-all-points/</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>[] parent;<br><span class="hljs-type">int</span>[] size;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> points.length; <span class="hljs-comment">// 节点个数</span><br>    List&lt;<span class="hljs-type">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> Math.abs(points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) +<br>                               Math.abs(points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>]);<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, cost&#125;);<br>        &#125;<br>    &#125;<br>    edges.sort(Comparator.comparingInt(a -&gt; a[<span class="hljs-number">2</span>])); <span class="hljs-comment">// 升序排列</span><br>    <br>    parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        parent[i] = i;<br>        size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>        <span class="hljs-keyword">if</span>(union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]))&#123;<br>            sum += edge[<span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> &#123;<br>    <span class="hljs-keyword">while</span> (parent[v] != v) &#123;<br>        parent[v] = parent[parent[v]];<br>        v = parent[v];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (parent[w] != w) &#123;<br>        parent[w] = parent[parent[w]];<br>        w = parent[w];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (w == v) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 处在一个连通分量中</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (size[w] &gt; size[v]) &#123;<br>            parent[v] = w;<br>            size[w] += size[v];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[w] = v;<br>            size[v] += size[w];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六dijstra算法">六、Dijstra算法</h2><h3 id="框架">1、框架</h3><ol type="1"><li>建图：将题目中对应的图模型建立起来（以邻接表的形式）</li><li>封装每个图节点 Node：节点id 和 "代价"(从 start节点到当前节点的最值)</li><li>使用一个 cost 数组：cost[i] 记录从 start 节点开始到 i 节点的"<strong>代价</strong>" <strong>最值</strong></li><li>使用 优先队列 queue：目的是每次能够取出最小（最大）的节点，加速BFS</li><li>从 start 节点开始 BFS</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] dijstra(..args)&#123;<br>    <span class="hljs-comment">// 建图</span><br>    List&lt;<span class="hljs-type">int</span>[]&gt;[] graph = buildGraph();<br>    <br>    <span class="hljs-comment">// start节点到相应节点的&quot;代价&quot;最值</span><br>    <span class="hljs-type">int</span>[] costTo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    initialize the array;<br>    costTo[start] = init_value;<br>    <br>    <span class="hljs-comment">// 使用优先级队列，对所有封装起来的图节点按照&quot;cost&quot;排序</span><br>    Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">a</span> start node);<br>    <br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> node.id;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> node.costFromStart;<br>        <br>        <span class="hljs-keyword">if</span>(cost &gt; costTo[id])&#123; <span class="hljs-comment">// 已经有更优的</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] next : graph[id])&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextId</span> <span class="hljs-operator">=</span> next[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 这个地方可以衍生出很多的变式，对于代价是相加，对于概率是相乘，也有可能是求最大值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextCost</span> <span class="hljs-operator">=</span> func(next[<span class="hljs-number">1</span>], costTo[id]);<br>            <br>            <span class="hljs-keyword">if</span>(nextCost &lt; costTo(nextId))&#123;<br>                <span class="hljs-comment">// 更新</span><br>                costTo[nextId] = nextCost;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">this</span> node);<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> costTo;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记1-数组/链表</title>
      <link href="/2022/09/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01%EF%BC%88%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
      <url>/2022/09/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01%EF%BC%88%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前缀和">前缀和</h2><p><font color='blue'>使用于 数组固定不变 而且需要频繁求和的情况</font></p><blockquote><p>相关题目：</p><p>1、一维数组的区域和检索 303</p><p>2、二维数组的区域和检索 304</p><p>3、和为k的子数组个数 560</p></blockquote><p>在求解数组和的时候，最普通的方法就是for循环遍历，复杂度为<spanclass="math inline">\(O(N)\)</span>。</p><p>但是当需要多次调用求解数组和的方法时，就需要降低其复杂度</p><p>使用前缀和可以将复杂度降为<spanclass="math inline">\(O(1)\)</span></p><p>使用条件：<strong>调用数组求和方法前数组已经初始化 +会调用大量的数组求和方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在初始化的时候构建前缀和数组</span><br><span class="hljs-type">int</span> *preSum = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len + <span class="hljs-number">1</span>]&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>    preSum[i+<span class="hljs-number">1</span>] = preSum[i] + nums[i];<br>&#125;<br><br><span class="hljs-comment">// 返回数组某个范围的和只需要用相应前缀和数组进行相减即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sunRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> preSum[right+<span class="hljs-number">1</span>] - preSum[left+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>在二维数组（矩阵）中应用时，"前缀和" 就是 某点<spanclass="math inline">\((row, col)\)</span> 到 <spanclass="math inline">\((0,0)\)</span>或者其他定点所围成的区域的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 求解 row1, col1, row2, col2 所围成的区域的和</span><br><span class="hljs-comment">* Sum(row2, col2) - Sum(row2, col1) - Sum(row1, col2) + Su(row1, col1)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span></span>&#123;<br>    preMatrix[row2][col2] -<br>               (col1 &gt; <span class="hljs-number">0</span> ? preMatrix[row2][col1 - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>) -<br>               (row1 &gt; <span class="hljs-number">0</span> ? preMatrix[row1 - <span class="hljs-number">1</span>][col2] : <span class="hljs-number">0</span>) +<br>               (row1 &gt; <span class="hljs-number">0</span> &amp;&amp; col1 &gt; <span class="hljs-number">0</span> ? preMatrix[row1 - <span class="hljs-number">1</span>][col1 - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>和为k的子数组个数</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 最普通的思路 O(N^3)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; len; j++)&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i; k &lt;= j; k++)&#123;<br>            sum += nums[k];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == k)&#123;<br>            cnt++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 利用前缀和数组 =&gt; O(N^2)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>        <span class="hljs-keyword">if</span>(preSum[i] - preSum[j] == k)&#123;<br>            cnt ++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 【O(N)】</span><br><span class="hljs-comment">// preSum[j] = preSum[i] - k ·········· (1)</span><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; preSum;<br>preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 考虑有前缀和=k的qing</span><br><span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> sum_i = <span class="hljs-number">0</span>, sum_j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>    sum_i += nums[i];<br>    sum_j = sum_i - k;<br>    <span class="hljs-keyword">if</span>(preSum.<span class="hljs-built_in">find</span>(sum_j) != preSum.<span class="hljs-built_in">end</span>())&#123; <span class="hljs-comment">// 存在前缀和使得 (1) 成立</span><br>        cnt += preSum[sum_j];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(preSum.<span class="hljs-built_in">find</span>(sum_i) != preSum.<span class="hljs-built_in">end</span>())&#123;<br>        preSum[sum_i] ++;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        preSum[sum_i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="差分数组">差分数组</h2><p><font color='blue'>差分数组适用于需要频繁对数组的<strong>某个区间做增减</strong>的情况</font></p><blockquote><p>区间加法 370</p><p>航班预定统计 1109</p><p>拼车 1094</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Difference</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; diff;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 初始化差分数组</span><br>    <span class="hljs-built_in">Difference</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        diff.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            diff.<span class="hljs-built_in">push_back</span>(nums[i] - nums[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// [startIndex, endIndex]区间 加和</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> endIndex, <span class="hljs-type">int</span> inc)</span></span><br><span class="hljs-function">    </span>&#123;<br>        diff[startIndex] += inc;<br>        <span class="hljs-keyword">if</span> (endIndex &lt; diff.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;<br>            diff[endIndex + <span class="hljs-number">1</span>] -= inc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 由差分数组得到原数组并返回</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(diff.size())</span></span>;<br>        nums[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; diff.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            nums[i] += nums[i - <span class="hljs-number">1</span>] + diff[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在【航班预定统计】中，对航班人数形成的数组做差分</p><p>在【拼车】中，对每个位置车上的人数形成的数组做差分</p><h2 id="滑动窗口">滑动窗口</h2><p><font color='blue'>一般解决 在字符串中寻找子串 的问题</font></p><blockquote><p>最小覆盖子串 76</p><p>字符串的排列 567</p><p>找到字符串中所有字母异位词 438</p><p>无重复字符最长子串 3</p></blockquote><p>思路：</p><p>1、先用一个map记录满足要求的情况（比如子串中字符类型和数目）</p><p>2、用另一个map记录窗口内的情况（window）[ left, right )</p><p>3、【不断移动右边界，并对window内容<strong>做更新</strong>】 =&gt;【在满足<strong>某种情况</strong>时，需要缩减窗口（即移动左边界），并<strong>做更新</strong>】（循环这个过程，直到右边界到达字符串边界）</p><p>4、<strong>我们需要的结果在哪里更新？</strong>（移动右边界过程中，还是移动左边界过程中）</p><p><strong><font color='red'>理解窗口缩小背后的含义</font></strong></p><blockquote><p>个人的理解：</p><p>滑动窗口的核心当然在于【窗口】的含义和【滑动】的含义</p><p>一般来说，窗口是帮助我们寻找答案的结构；滑动是我们寻找的答案的过程以及技巧。</p><p>所以，窗口的定义都是比较简单的。</p><p>真正灵活的是窗口的滑动。滑动避免了冗余的循环，大大降低了问题的复杂度</p><p>我们如果使用最一般的方法处理此类问题，首先要确定就是 字符串的开始位置和结束位置，之前我们使用循环是O(N^2)的复杂度；而使用窗口的滑动，右边界滑动是确定开始位置不断改变结束位置，而左边界滑动是确定结束位置不断改变开始位置，最多只需要对字符串做两次遍历，是O(N)复杂度，当然其中还涉及一些其他的技巧，帮助筛选掉一些情况。</p><p>滑动分为右边界滑动（窗口扩大）和左边界滑动（窗口缩小）</p><p>分别对应着什么时候窗口扩大；窗口扩大之后干什么；什么时候窗口缩小；窗口缩小之后干什么</p><p>一般我们都将窗口初始化为 [ 0, 0 )</p><p>窗口扩大是对应于【寻找解】的过程；窗口缩小是对应于【优化解】的过程</p><p>寻找解的过程相对简单，根据问题的类型很容易可以写出相应的代码</p><p>【最难的是】 什么时候进行解的优化，以及怎么做？先根据题目来看看</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 滑动窗口的框架</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slideWindow</span><span class="hljs-params">(string s1, string s2)</span></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; need;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s1) need[c]++;<br>    <br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> valid = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(right &lt; s2.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">char</span> c = s2[right];<br>        right++;<br>        <br>        <span class="hljs-comment">// ... 窗口扩大时做的更新</span><br>        <br>        <span class="hljs-keyword">while</span>( condition )&#123; <span class="hljs-comment">// 什么时候停止窗口扩大，开始缩减窗口</span><br>            <span class="hljs-type">char</span> d = s2[left];<br>            left++;<br>            <span class="hljs-comment">// ... 窗口缩减时做的操作</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对上面的四个例子，具体地阐述一下框架的使用，以及对于那几个问题的思考</p><ul><li>【最小覆盖子串】</li></ul><blockquote><p>在 s 中找到 包含 t 中所有字符的最小子串</p></blockquote><p>1、移动右边界</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-type">char</span> c = s2[right];<br>right++;<br><span class="hljs-comment">// 窗口增大时的更新操作</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果加入窗口的这个字符 是need中的字符 (也就是说是 t 中的字符)</span><br><span class="hljs-comment">就将该字符在窗口中的数量+1</span><br><span class="hljs-comment">如果该字符在窗口中的数量 和 在need中的数量一样 (也就是说窗口中该字符满足了t中的要求)</span><br><span class="hljs-comment">valid +1 表示有效的字符数增加 当有效字符数和t中的字符类型数一样的时候 说明此时窗口中满足了要求 包含了t中所有字符</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(c))&#123;<br>    window[c]++;<br>    <span class="hljs-keyword">if</span>(window[c] == need[c])&#123;<br>        valid++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、【窗口中满足要求时】，缩减窗口</p><p><font color='red'>为什么要缩减窗口？为什么要在窗口满足要求的时候缩减窗口？缩减时干什么？</font></p><p>问题是求解【最小子串】</p><p>在右边界不断移动的过程中，可能会有一些不必要的字符被加入窗口中，就会导致窗口中的答案可能不是最小的。比如（"adbc"中包含 "bcd"，但是 "a"是无关紧要的，可以从窗口中移除的，应该变为"dbc"）就需要对窗口进行缩减才能使得答案更优（局部最优）。</p><p>因为要对解进行优化，首先需要在窗口中出现解，或包含解，才能继续优化，所以需要在窗口满足要求时进行缩减。</p><p>根据前面我们要缩减窗口的原因，在缩减窗口时，我们需要做的就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    将字符从左边界移出，直到窗口中刚好不满足要求，此时窗口内的解为局部最优</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">while</span>( valid == need.<span class="hljs-built_in">size</span>() )&#123;<br>    <span class="hljs-type">char</span> d = s2[left];<br>    left++;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    如果移出的字符在need中，而且移出前该字符在窗口中的数量刚好满足要求</span><br><span class="hljs-comment">    移出后，valid --</span><br><span class="hljs-comment">    window[d] --</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>        <span class="hljs-keyword">if</span>(window[d] == need[d])&#123;<br>            valid--;<br>        &#125;<br>        window[d]--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、由于我们需要的最小子串，那么肯定需要对解进行判断和更新，在哪？</p><p>我们需要的全局最优解，更新的时候肯定是考虑局部最优解，所以自然就应该将答案的更新放在窗口缩小中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>( valid == need.<span class="hljs-built_in">size</span>() )&#123;<br>    <span class="hljs-comment">// 对答案进行更新</span><br>    <span class="hljs-keyword">if</span>(right - left &lt; len)&#123;<br>        start = left; <br>        len = right - left;<br>    &#125;<br>    <br>    <span class="hljs-type">char</span> d = s2[left];<br>    left++;<br>    <br>    <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>        <span class="hljs-keyword">if</span>(window[d] == need[d])&#123;<br>            valid--;<br>        &#125;<br>        window[d]--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【字符串的排列】【找到字符串中所有字母异位词】</li></ul><blockquote><p>判断字符串 s1 中是否包含 s2 的排列</p><p>找到字符串 s1 中 s2 所有排列的起始位置</p></blockquote><p>这两个问题的核心是一样的，都是查找字符串的排列</p><p>应用上面的框架，移动右边界寻找解的过程是一致的，区别和难点在于【缩减窗口的时机】和【缩减窗口的操作】</p><p><font color='red'>什么时候缩减窗口</font></p><p>缩减窗口的目的是 优化解。</p><p>所以，可以得出缩减窗口的两个时机就是 1、窗口中包含了解2、明显知道窗口中的内容不能满足解，需要对窗口中的内容进行修正。</p><p>这两个时机可以任选一个，就看不同的问题中，哪个时机更加明显。</p><p>对于上一个问题：最小覆盖子串中，时机1是更加明显的，只要窗口中包含了和need中一样的字符和数量（<code>valid == need.size()</code>）；相比之下，时机2是不明显的，【修正解】在这个问题中是需要解先出现的，因为子串可以包含其他字符，在解出现之间都不能知道这个解需不需要被修正。</p><p>而这个问题中，我们很容易就能知道什么时候解需要修正：1、出现了其他字符；（<code>need.count(c) == 0</code>）2、字符数量过多了（窗口的size大于s2的size：<code>right - left &gt; s2.size()</code>）。对于什么时候窗口中包含解，我们是更难以知道的，我们要验证窗口这一块区域，难度更大，也不合适。</p><p>至于缩减窗口的操作，经过思考很容易能够得到，就是将字符从左边界移出，并更新window和valid</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">出现了其他字符如果没有处理会导致字符数量过多, 所以选择用 rigth - left &gt; s2.size() 来判断</span><br><span class="hljs-comment">我们需要判断结果的出现，所以将 = 放进了判断中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">while</span>( right - left &gt;= s2.<span class="hljs-built_in">size</span>() )&#123;<br>    <span class="hljs-keyword">if</span>(valid == need.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">// 满足情况</span><br>    &#125;<br>    <br>    <span class="hljs-type">char</span> d = s1[left];<br>    left++;<br>    <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>        <span class="hljs-keyword">if</span>(window[d] == need[d])&#123;<br>            valid --;<br>        &#125;<br>        window[d]--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【无重复字符最长子串】</li></ul><blockquote><p>找到 s 中没有重复字符的最长子串。</p><p>"pwwkew" =&gt; "wke"</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这道题在框架上更为简单，是一个变种，但是在考虑缩减窗口上还是值得思考一番</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">char</span> c = s[right];<br>        right++;<br>        window[c]++;<br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">        缩减窗口的时机: 存在重复字符</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">while</span>(window[c] &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">char</span> d = s[left];<br>            left++;<br>            window[d]--;<br>        &#125;<br>        len = <span class="hljs-built_in">max</span>(len, right-left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分搜索">二分搜索</h2><p>【二分搜索】是十分常见的算法，其思想十分简单，但是在细节上的处理较为繁琐和复杂。</p><p>下面针对不同的场景和问题来探究一下二分搜索的细节</p><h3 id="二分搜索框架">二分搜索框架</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearchFramework</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = ...<br>    <span class="hljs-built_in">whilie</span>(...)&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)&#123;<br>            right = ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;<br>            left = ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>...</code> 处就是之后要考虑的细节</li><li><code>left + (right - left) / 2</code> 防止溢出问题</li></ul><h3 id="普通二分搜索">普通二分搜索</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用 [left, right] 型的搜索区间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">whilie</span>( left &lt;= right )&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)&#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>right = nums.size() - 1</code> 表示是在<code>[left, right]</code> 这样的闭区间中搜索的 =&gt; 所以 while中的循环条件是 <code>left &lt;= right</code> 而不是<code>left &lt; right</code> 因为 <code>left == right</code>时，<code>[left, right]</code>这个区间仍然是可用的。</li><li>在 <code>if-else</code>结构中的操作，和搜索区间是统一的。【搜索区间】其实就是可能出现解的区间，问题在于区间的开闭需要统一。比如如果要使用闭区间，就要<code>right = nums.size() - 1</code>，在更新<code>left</code> 和 <code>right</code>的时候也要保证更新后搜索区间是闭区间。相反，如果要使用开区间，就要<code>right = nums.size()</code> ，在更新 <code>left</code> 和<code>right</code> 时也要保证更新后搜索区间是开区间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// [left, right) 型搜索区间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">while</span>( left &lt; right )&#123; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)&#123;<br>            right = mid; <span class="hljs-comment">// 注意</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻找左侧边界的二分查找">寻找左侧边界的二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// [left, right] 搜索区间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchLeftBound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// [1]</span><br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123; <span class="hljs-comment">// [2]</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// [3]</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// [4]</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (left &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[left] == target) ? left : <span class="hljs-number">-1</span>; <span class="hljs-comment">// [5]</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>[1]：<code>right = nums.size() - 1</code> 意味着选择 闭区间作为搜索区间 <code>[left, right]</code></li><li>[2]：闭区间，有效的循环范围是 <code>left &lt;= right</code>或者说终止条件是 <code>left = right + 1</code></li><li>[3]、[4]：保证搜索区间是闭区间（保证搜索区间之间没有重叠）</li><li>[5]：考虑终止条件时，<code>left</code>和<code>right</code>的情况：1、如果<code>nums</code>中存在<code>target</code>，<code>nums[left] == target</code>；2、如果<code>nums</code>中不存在<code>target</code>，<code>left == nums.size() || left == 0</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// [left, right) 搜索区间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchLeftBound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (left &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[left] == target) ? left : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻找右侧边界的二分查找">寻找右侧边界的二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用 [left, right] 闭区间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchRightBound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == target) ? right : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重点说一下<code>return</code>：查找右边界的情况要些许复杂一点，和搜索区间的开闭有一定的关系。对于闭区间，终止条件是<code>left == right + 1</code>，经过简单的推理可以知道如果nums中存在target的话，nums[right]==target；如果不存在的话，<code>right == -1 || right = nums.size() - 1</code>，分别对应于<code>target</code>小于全部<code>nums</code>元素和大于全部<code>nums</code>元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用 [left, right) 开区间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchRightBound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; nums[right - <span class="hljs-number">1</span>] == target) ? right - <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>而对于开区间，如果<code>nums</code>中存在<code>target</code>，<code>nums[right - 1] == target</code>（因为是开区间，<code>right</code>位置的值是取不到的，所以需要减一）；如果不存在的话，<code>right == 0 || right == nums.size()</code>，同样分别对应于<code>target</code>小于全部<code>nums</code>元素和大于全部<code>nums</code>元素。</li></ul><h3 id="二分搜索的题型解析">二分搜索的题型解析</h3><p>从上面的例子可以看出，我们使用二分搜索的情景一般如下：【有序数组】、【查找元素或元素边界】</p><p>但是这大大限制了二分搜索的使用，下面我们对二分搜索使用的场景做一下抽象和总结。</p><p>首先，我们还是把眼光放到二分搜索的最普通的场景上。其实对二分搜索最重要的是【有序数组】，只有数组是有序的，我们才能根据中间位置的情况一次筛除掉一半的元素，以达到<spanclass="math inline">\(lg(n)\)</span>的时间复杂度。</p><p>其实，【有序数组】本质上是【单调】，二分搜索之所以可以达到<spanclass="math inline">\(lg(n)\)</span>的复杂度，就是利用了【单调】的性质。</p><p>进一步泛化，我们可以将上述情景抽象成</p><blockquote><p>存在一个单调函数 f(x) ，给定 一个值 target ，返回 令 f(x) = target成立的 x</p><p>（这个单调函数其实就是返回下标x对应的nums数组中的值）</p></blockquote><p>所以，如果我们可以从题目中抽象出</p><p>1、自变量 x</p><p>2、建立在 x 上的单调函数</p><p>3、一个target</p><p>我们就可以使用二分搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> nums[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">whilie</span>(left &lt;= right)&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">f</span>(nums, mid);<br>        <span class="hljs-keyword">if</span>(res == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &gt; target)&#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面通过三个题目来具体讲解一下</p><ul><li>【875.爱吃香蕉的珂珂】</li></ul><blockquote><p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code>堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code>小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 <code>k</code>（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code>根。如果这堆香蕉少于 <code>k</code>根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度<code>k</code>（<code>k</code> 为整数）。</p></blockquote><p>分析：</p><ol type="1"><li><p>x：吃香蕉的速度 k</p></li><li><p>f(x)：在k的吃香蕉速度下，需要的时间</p><p><strong><span class="math inline">\(f(x) = \sum_{i=1}^{n} \lceil\frac{piles[i]}{x} \rceil\)</span></strong></p><p>很明显是一个单调函数</p></li><li><p>target：f(x) &lt;= h</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> h)</span> </span>&#123;<br>        <span class="hljs-comment">// 1 确定 吃香蕉速度 x 的区间 [low, high]</span><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles) &#123;<br>            <span class="hljs-keyword">if</span> (max &lt; pile) &#123;<br>                max = pile;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> high = max;<br>        <br>        <span class="hljs-comment">// 2 二分搜索</span><br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> hours = <span class="hljs-built_in">timeCost</span>(piles, mid);<br>            <span class="hljs-keyword">if</span> (hours &lt;= h) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hours &gt; h) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-comment">// f(x)</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">timeCost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">long</span> hours = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> speed = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            hours += <span class="hljs-built_in">ceil</span>(nums[i] / speed);<br>        &#125;<br>        <span class="hljs-keyword">return</span> hours;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>【1011.在-d-天内送达包裹的能力】</li></ul><blockquote><p>传送带上的包裹必须在 <code>days</code>天内从一个港口运送到另一个港口。</p><p>传送带上的第 <code>i</code> 个包裹的重量为<code>weights[i]</code>。每一天，我们都会按给出重量（<code>weights</code>）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 <code>days</code>天内将传送带上的所有包裹送达的船的最低运载能力。</p></blockquote><p>分析：</p><ol type="1"><li><p>x：船的运载能力</p></li><li><p>f(x)：船的运载能力对应的需要的天数</p><p>这个比较明显，很容易想到，船的运载能力越大，需要的天数肯定不会越多，应该是非递增函数。</p></li><li><p>target：f(x) &lt;= days</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">int</span> days)</span> </span>&#123;<br>        <span class="hljs-comment">// 船的最低承载能力不能小于weights数组中最大的元素</span><br>        <span class="hljs-comment">// 最高承载能力只要是weights数组元素之和即可</span><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> weight : weights) &#123;<br>            low = <span class="hljs-built_in">max</span>(weight, low);<br>            high += weight;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> day = <span class="hljs-built_in">daysNeeded</span>(weights, mid);<br>            <span class="hljs-keyword">if</span> (day &lt;= days) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (day &gt; days) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-comment">// f(x) 某运载能力下，需要的天数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">daysNeeded</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> days = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> weight : weights) &#123;<br>            <span class="hljs-keyword">if</span> (sum + weight &gt; capacity) &#123;<br>                days++;<br>                sum = weight;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += weight;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) days++;<br>        <span class="hljs-keyword">return</span> days;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>【410.分割数组的最大值】</li></ul><blockquote><p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code>，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p><p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p></blockquote><p>这道题在f(x)的选择上比较巧妙</p><p>【分析】</p><p>首先，划分成多少个子数组（m）是确定的，子数组和的最大值只是跟划分方式有关。但是划分方式又不好用数表示出来，所以想写成子数组和的最大值关于划分方式的函数 肯定是行不通的。</p><p>其次，我们要写成 f(x) 的形式，其中 x肯定是数。在这道题中，唯一会变化的数就是子数组的和的最大值。所以大概可以确定，x就是子数组和的最大值。</p><p>那 f(x)是什么呢？根据题意大概就是【是否存在某种划分方式使得子数组和的最大值=x】这样的函数，得到的是0 和 1。只要这个函数以某个分界点一边是0一边是1，也是一种单调函数。</p><p>但是很遗憾，【是否存在某种划分方式使得子数组和的最大值=x】这个函数得到的0/1分布是散乱的。</p><p>下面这个就是最有技巧的一步了：<font color='red'>【是否存在某种划分方式使得子数组和的最大值&lt;= x】</font></p><p>这个函数得到的0/1分布就是以某个点为分界线的，是单调的。</p><ol type="1"><li>x：子数组和的最大值</li><li>f(x)：是否存在某种划分方式使得子数组和的最大值 &lt;= x</li><li>target：f(x) == 1</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// 1 判断 x 的范围: 数组nums的最大值 - 数组nums的元素之和</span><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            low = <span class="hljs-built_in">max</span>(num, low);<br>            high += num;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 2 二分搜索</span><br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">bool</span> res = <span class="hljs-built_in">isExist</span>(nums, m, mid);<br>            <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">true</span>) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">false</span>) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否存在一种分割方式使得子数组的和的最大值&lt;=x</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 相反的思路: 将数组尽可能少的分成和小于x的子数组，如果最终得到的子数组数 &lt;= m(要求划分的子数组个数), 那么就是c</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isExist</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> max)</span> </span>&#123;<br>        <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (sum + num &gt; max) &#123;<br>                cnt++;<br>                sum = num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) cnt++;<br>        <span class="hljs-keyword">return</span> cnt &lt;= m;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="在两个数组中寻找第k个元素">在两个数组中寻找第k个元素</h3><blockquote><p><ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4.寻找两个正序数组的中位数</a></p></blockquote><p>这道题使用二分查找的话，可以将问题转化成【在两个有序数组中寻找第k小的元素】</p><p>【思路】是对<code>k</code>做二分。每次向前走<code>k/2-1</code>个元素，直到数组末尾，这样一次比较就可以排除<code>k/2</code>个元素，就是更小的那个元素对应数组走的那<code>k/2</code>个元素。</p><figure><imgsrc="https://my-pictures-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230304120343432.png"alt="过程" /><figcaption aria-hidden="true">过程</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// nums1和nums2为两个有序数组</span><br><span class="hljs-comment">// 需要找到两个数组中第k小的元素 注意第1小的元素应该是0为下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>(), n = nums2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-comment">// 一个数组已经遍历完，直接去另一个数组的对应区间中找</span><br>        <span class="hljs-keyword">if</span> (index1 &gt;= m) <span class="hljs-keyword">return</span> nums[index2+k<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span> (index2 &gt;= n) <span class="hljs-keyword">return</span> nums[index1+k<span class="hljs-number">-1</span>];<br>        <span class="hljs-comment">// base case 选择两个数组当前走到位置里更小的一个</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[index1], nums2[index2]);<br>        <br>        <span class="hljs-comment">// 需要考虑是否会超出数组长度</span><br>        <span class="hljs-type">int</span> newIndex1 = <span class="hljs-built_in">min</span>(index1+k/<span class="hljs-number">2</span>, m) - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> newIndex2 = <span class="hljs-built_in">min</span>(index2+k/<span class="hljs-number">2</span>, n) - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums1[newIndex1] &gt;= nums2[newIndex2]) &#123;<br>            k -= (newIndex2 - index2 + <span class="hljs-number">1</span>);<br>            index2 = newIndex2 + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            k -= (newIndex1 - index1 + <span class="hljs-number">1</span>);<br>            index1 = newIndex1 + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="田忌赛马">田忌赛马</h2><blockquote><p>优势洗牌 870</p></blockquote><p>算法思想：<font color='red'><strong>如果没办法赢就用最差的去输</strong></font></p><blockquote><p>给定两个大小相等的数组 <code>nums1</code> 和<code>nums2</code>，<code>nums1</code> 相对于 <code>nums</code>的<em>优势</em>可以用满足 <code>nums1[i] &gt; nums2[i]</code> 的索引<code>i</code> 的数目来描述。</p><p>返回 nums1 的<strong>任意</strong>排列，使其相对于 <code>nums2</code>的优势最大化。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p1, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p1.second &lt; p2.second;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">advantageCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">// 1 由于最终的结果是根据nums2的原始顺序的，所以不能直接对nums2进行排序，需要使用priority_queue进行排序</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; v;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            v.<span class="hljs-built_in">push_back</span>(&#123;i, nums2[i]&#125;);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">// 2 排序nums1</span><br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 3 使用双指针进行遍历</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums1.size())</span></span>;<br>        <span class="hljs-type">int</span> right = nums1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> index = right;<br><br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 有优势</span><br>            <span class="hljs-keyword">if</span> (nums1[right] &gt; v[index].second) &#123;<br>                res[v[index].first] = nums1[right];<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 没有优势</span><br>                res[v[index].first] = nums1[left];<br>                left++;<br>            &#125;<br>            index--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="原地修改数组">原地修改数组</h2><blockquote><p>删除有序数组中的重复项 26</p><p>删除排序链表中的重复元素 83</p><p>移除元素 27</p><p>移动零 283</p></blockquote><h3 id="快慢指针">快慢指针</h3><blockquote><p>让快指针在前面探路，当快指针所指向的值和慢指针不同时，则将慢指针向前移动并更新其值为快指针所指向的值</p></blockquote><ul><li>【删除有序数组中的重复项】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(fast != nums.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(nums[slow] != nums[fast])&#123;<br>            slow ++;<br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【删除排序链表中的重复元素】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    ListNode* slow = head, * fast = head;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span>(fast-&gt;val != slow-&gt;val)&#123;<br>            slow-&gt;next = fast;<br>            slow = slow-&gt;next;<br>        &#125;<br>        fast = fast-&gt;next;<br>    &#125;<br>    slow-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【移除元素】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">if</span> (nums[left] == val) &#123;<br>            nums[left] = nums[right];<br>            right--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 快慢指针</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (fast != nums.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>            nums[slow] = nums[fast];<br>            slow++;<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【移除零】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">移除0元素 + 末尾修改成0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">removeElement</span>(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(; len &lt; nums.<span class="hljs-built_in">size</span>(); len++)&#123;<br>        nums[len] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ku&#x27;ao</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (fast != nums.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// swap</span><br>            <span class="hljs-type">int</span> tmp = nums[slow];<br>            nums[slow] = nums[fast];<br>            nums[fast] = tmp;<br>            <br>            slow++;<br>        &#125;<br>        fast++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单链表问题">单链表问题</h2><blockquote><p>合并两个有序链表 21</p><p>合并K个升序链表 23</p><p>环形链表 141</p><p>环形链表Ⅱ 142</p><p>链表的中间节点 876 =&gt; 快慢指针 fast指针走2步，slow指针走1步</p><p>相交链表 160</p><p>删除链表的倒数第N个节点 19 =&gt; 双指针一个指针先走n步，再两个指针同时走</p></blockquote><ul><li>【合并两个有序链表】</li></ul><p>采用双指针 + <font color='red'><strong>dummy头结点</strong></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode *p = dummy, *p1 = list1, *p2 = list2;<br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">nullptr</span> &amp;&amp; p2 != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (p1-&gt;val &gt; p2-&gt;val) &#123;<br>            p-&gt;next = p2;<br>            p2 = p2-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p-&gt;next = p1;<br>            p1 = p1-&gt;next;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p1 != <span class="hljs-literal">nullptr</span>) &#123;<br>        p-&gt;next = p1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p2 != <span class="hljs-literal">nullptr</span>) &#123;<br>        p-&gt;next = p2;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【合并k个升序链表】</li></ul><p>前一道题的升级版。难度在于如何快速找到 k 个 ListNode 中的最小结点=&gt; 使用 priority_queue 最小堆</p><p>算法时间复杂度是 <span class="math inline">\(O(NlgK)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* p1, ListNode* p2)</span> </span>&#123; <span class="hljs-keyword">return</span> p1-&gt;val &gt; p2-&gt;val; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-comment">// 最小堆</span><br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (lists[i] != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(lists[i]);<br>        &#125;<br><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* p = dummy;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ListNode* t = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            p-&gt;next = t;<br>            p = p-&gt;next;<br>            <span class="hljs-comment">// 该链表的下一个元素，加入堆中</span><br>            <span class="hljs-keyword">if</span> (t-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>                t = t-&gt;next;<br>                q.<span class="hljs-built_in">push</span>(t);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>【删除链表的倒数第N个节点】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode *p1 = head, *p2 = dummy;<br>    <span class="hljs-comment">// p1先向前走n步</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        p1 = p1-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// p1和p2一起向前走 直到p1走到链表末尾</span><br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">nullptr</span>) &#123;<br>        p1 = p1-&gt;next;<br>        p2 = p2-&gt;next;<br>    &#125;<br>    p2-&gt;next = p2-&gt;next-&gt;next;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【链表的中间节点】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 快慢指针</span><br><span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-comment">// fast一次走两步 slow一次走一步</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next;<br>        fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【环形链表】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-comment">// fast 一次走两部 slow 一次走一步</span><br>    <span class="hljs-comment">// 由于fast更快 只要存在环 fast和slow一定会相遇</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【环形链表Ⅱ】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> hasCycle = <span class="hljs-literal">false</span>;<br>    ListNode *fast = head, *slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            hasCycle = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!hasCycle) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    设 s 是环的起点到链表起点的距离 l 是相遇点到环的起点的距离</span><br><span class="hljs-comment">    易知 慢指针走过的距离为 s + l 快指针走过的是 2(s + l)</span><br><span class="hljs-comment">    又 快指针比慢指针多走一个环的长度</span><br><span class="hljs-comment">    所以 2(s+l) - (s+l) = n</span><br><span class="hljs-comment">    s + l = n</span><br><span class="hljs-comment">    =&gt; s = n - l</span><br><span class="hljs-comment">    所以 让慢指针回到链表起点 快指针继续向前 以相同的速度走 最后会在环的起点相遇</span><br><span class="hljs-comment">    */</span><br>    slow = head;<br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【相交链表】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">设A链表与B链表相交的部分长度为 m</span><br><span class="hljs-comment">A链表剩余部分长度为 x B链表剩余部分长度为 y</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">让 p1 先走A链表 走完再走B链表</span><br><span class="hljs-comment">p2 先走B链表 走完再走A链表</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果存在相交部分 那么就会在相交的起点相遇 因为走的距离都为 x + y + m</span><br><span class="hljs-comment">如果不存在相交部分 那么就会使得 p1 p2 都为 nullptr</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    ListNode *p1 = headA, *p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">nullptr</span>)<br>            p1 = headB;<br>        <span class="hljs-keyword">else</span><br>            p1 = p1-&gt;next;<br><br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">nullptr</span>)<br>            p2 = headA;<br>        <span class="hljs-keyword">else</span><br>            p2 = p2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表操作递归思想">链表操作递归思想</h2><blockquote><p>反转链表 206</p><p>反转链表 Ⅱ 92</p></blockquote><ul><li>反转整个链表</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>    ListNode* p = <span class="hljs-built_in">reverse</span>(head-&gt;next);<br>    <span class="hljs-comment">// 把后一个结点的next指针指向当前的节点(head)</span><br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>反转链表的前n个结点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ListNode* successor = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-function">ListNode* <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>        successor = head-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* p = <span class="hljs-built_in">reverseN</span>(head-&gt;next, --n);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = successor; <span class="hljs-comment">// 改变每次的后继 使得反转后的最后一个结点指向链表剩余部分(n+1个结点)</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>反转链表的一部分</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 就是反转前n个结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverseN</span>(head, right-left+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 向前di&#x27;gui</span><br>    head-&gt;next = <span class="hljs-built_in">reverseBetween</span>(head-&gt;next, left<span class="hljs-number">-1</span>, right<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记4-二叉树</title>
      <link href="/2022/09/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B04%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/"/>
      <url>/2022/09/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B04%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一">（一）</h2><blockquote><p>翻转二叉树 226</p><p>二叉树展开为链表 114</p><p>填充每个节点的下一个右侧节点指针 116</p></blockquote><h3 id="翻转二叉树">【翻转二叉树】</h3><blockquote><p>给你一棵二叉树的根节点 <code>root</code>，翻转这棵二叉树，并返回其根节点。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = left;<br>        root-&gt;right = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3id="填充每个节点的下一个右侧节点指针">【填充每个节点的下一个右侧节点指针】</h3><blockquote><p>给定一个 <strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p></blockquote><p>【分析】</p><p>这道题的递归解法十分巧妙，而迭代解法更为自然</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief 借用队列实现的迭代解法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param root</span><br><span class="hljs-comment">     * @return Node*</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Node* <span class="hljs-title">connect1</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        queue&lt;Node*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 用nullptr标志一层的结束</span><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>            Node* n = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">nullptr</span>) &#123;<br>                n-&gt;next = q.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">if</span> (n-&gt;left) q.<span class="hljs-built_in">push</span>(n-&gt;left);<br>                <span class="hljs-keyword">if</span> (n-&gt;right) q.<span class="hljs-built_in">push</span>(n-&gt;right);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief 递归解法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param root</span><br><span class="hljs-comment">     * @return Node*</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        root-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">connectionTwoNode</span>(root-&gt;left, root-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-comment">// 采用两个结点的递归</span><br>    <span class="hljs-comment">// 但是这个递归会存在重叠部分</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectionTwoNode</span><span class="hljs-params">(Node* node1, Node* node2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node1 == <span class="hljs-literal">nullptr</span> || node2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        node1-&gt;next = node2;<br>        node2-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">connectionTwoNode</span>(node1-&gt;left, node1-&gt;right);<br>        <span class="hljs-built_in">connectionTwoNode</span>(node1-&gt;right, node2-&gt;left);<br>        <span class="hljs-built_in">connectionTwoNode</span>(node2-&gt;left, node2-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树展开为链表">【二叉树展开为链表】</h3><blockquote><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中<code>right</code> 子指针指向链表中下一个结点，而左子指针始终为<code>null</code> 。</li><li>展开后的单链表应该与二叉树 <ahref="https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin"><strong>先序遍历</strong></a>顺序相同。</li></ul></blockquote><p>【思路】</p><p>先将<code>root</code>的左子树部分展开为链表，再将右子树部分展开为链表，最后进行连接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">flatten</span>(root-&gt;left);<br>        <span class="hljs-built_in">flatten</span>(root-&gt;right);<br><br>        <span class="hljs-built_in">connect</span>(root);<br>    &#125;<br><span class="hljs-comment">// 将左边的链表、根节点、右边的链表进行连接</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 找到左子节点的最右子节点</span><br>        TreeNode* rightConnector = root-&gt;left;<br>        <span class="hljs-keyword">while</span> (rightConnector-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            rightConnector = rightConnector-&gt;right;<br>        &#125;<br><br>        rightConnector-&gt;right = root-&gt;right;<br>        root-&gt;right = root-&gt;left;<br>        root-&gt;left = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>二叉树的递归解法需要从大局来看，先将整个二叉树看成是左子树、根节点、右子树三部分，然后考虑应该对左子树和右子树如何递归操作，以及和根节点如何整合。不要局限于递归的细节，而是用整体来看待。但是对于最基本的base-case还是要考虑清楚以及是否能正确执行。</p><h2 id="二">（二）</h2><blockquote><p>最大二叉树 654</p><p>从前序与中序遍历序列构造二叉树 105</p><p>从中序与后序遍历序列构造二叉树 106</p></blockquote><h3 id="最大二叉树">【最大二叉树】</h3><blockquote><p>给定一个不重复的整数数组 <code>nums</code> 。<strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code>递归地构建:</p><ol type="1"><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的<strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的<strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">constructMaximumBinaryTreeHelper</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTreeHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 找到[left, right]部分的最大元素</span><br>        <span class="hljs-type">int</span> idx = left;<br>        <span class="hljs-type">int</span> val = nums[left];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; val) &#123;<br>                val = nums[i];<br>                idx = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 创建根节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        <span class="hljs-comment">// 递归</span><br>        root-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTreeHelper</span>(nums, left, idx - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTreeHelper</span>(nums, idx + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3id="从前序与中序遍历序列构造二叉树">【从前序与中序遍历序列构造二叉树】</h3><blockquote><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中<code>preorder</code> 是二叉树的<strong>先序遍历</strong>，<code>inorder</code>是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过先序遍历数组确定根的位置，然后通过中序遍历数组构造二叉树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTreeHelper</span>(preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>,<br>                               inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTreeHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">int</span> preleft, <span class="hljs-type">int</span> preright,</span></span><br><span class="hljs-params"><span class="hljs-function">                              vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inleft, <span class="hljs-type">int</span> inright)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preleft &gt; preright || inleft &gt; inright) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 通过先序遍历数组部分得到根节点</span><br>        <span class="hljs-type">int</span> root_val = preorder[preleft];<br>        <span class="hljs-comment">// 到中序遍历数组中找到根节点</span><br>        <span class="hljs-type">int</span> idx;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = inleft; i &lt;= inright; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i] == root_val) &#123;<br>                idx = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 创建根节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val);<br>        <span class="hljs-comment">// 判断该根节点左右子树的结点数</span><br>        <span class="hljs-type">int</span> left_nodes = idx - inleft;<br>        <span class="hljs-type">int</span> right_nodes = inright - idx;<br>        <span class="hljs-comment">// 递归</span><br>        root-&gt;left =<br>            <span class="hljs-built_in">buildTreeHelper</span>(preorder, preleft + <span class="hljs-number">1</span>, (left_nodes + preleft),<br>                            inorder, inleft, idx - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">buildTreeHelper</span>(preorder, (left_nodes + preleft + <span class="hljs-number">1</span>),<br>                                      preright, inorder, idx + <span class="hljs-number">1</span>, inright);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3id="从中序与后序遍历序列构造二叉树">【从中序与后序遍历序列构造二叉树】</h3><blockquote><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code>，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code>是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTreeHelper</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>,<br>                               postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTreeHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inleft, <span class="hljs-type">int</span> inright,</span></span><br><span class="hljs-params"><span class="hljs-function">                              vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> postleft,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">int</span> postright)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (inleft &gt; inright) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 根据后序遍历数组找到根节点 最后一个就是根节点</span><br>        <span class="hljs-type">int</span> root_val = postorder[postright];<br>        <span class="hljs-comment">// 找到根节点在中序遍历数组中的位置</span><br>        <span class="hljs-type">int</span> idx;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = inleft; i &lt;= inright; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i] == root_val) &#123;<br>                idx = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 创建根节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val);<br>        <span class="hljs-comment">// 确定左子树和右子树结点数量</span><br>        <span class="hljs-type">int</span> left_nodes = idx - inleft;<br>        <span class="hljs-type">int</span> right_nodes = inright - idx;<br>        <span class="hljs-comment">// 递归</span><br>        root-&gt;left = <span class="hljs-built_in">buildTreeHelper</span>(inorder, inleft, idx - <span class="hljs-number">1</span>, postorder,<br>                                     postleft, postright - right_nodes - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">buildTreeHelper</span>(inorder, idx + <span class="hljs-number">1</span>, inright, postorder,<br>                                      postleft + left_nodes - <span class="hljs-number">1</span>, postright - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-1">【总结】</h3><p>这三道题都是关于如何构建二叉树的，而构建二叉树的关键在于【中序遍历数组】+【可以确定根节点的条件】</p><p>在【最大二叉树】中可以确定根节点的条件是最大元素，而在后两道题中分别是前序遍历数组和后序遍历数组。</p><h2 id="三">（三）</h2><blockquote><p>寻找重复的子树 652</p></blockquote><h3 id="寻找重复的子树">【寻找重复的子树】</h3><blockquote><p>给定一棵二叉树<code>root</code>，返回所有<strong>重复的子树</strong>。</p><p>对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>如果两棵树具有<strong>相同的结构</strong>和<strong>相同的结点值</strong>，则它们是<strong>重复</strong>的。</p></blockquote><p>【思路】</p><p>要找重复的子树，【就需要记录之前的子树，然后再去匹配】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">private</span>:<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; memo; <span class="hljs-comment">// 记录子树出现的次数 string表示树的结构 int表示出现次数</span><br>    vector&lt;TreeNode*&gt; res; <span class="hljs-comment">// 结果集</span><br><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">findDuplicateSubtreesHelper</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">findDuplicateSubtreesHelper</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        &#125;<br><br>        string left = <span class="hljs-built_in">findDuplicateSubtreesHelper</span>(root-&gt;left);<br>        string right = <span class="hljs-built_in">findDuplicateSubtreesHelper</span>(root-&gt;right);<br><br>        <span class="hljs-comment">// </span><br>        string tree = <span class="hljs-string">&quot;&quot;</span>;<br>        tree.<span class="hljs-built_in">append</span>(left).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;,&quot;</span>).<span class="hljs-built_in">append</span>(right).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;,&quot;</span>).<span class="hljs-built_in">append</span>(<br>            <span class="hljs-built_in">to_string</span>(root-&gt;val));<br><br>        <span class="hljs-keyword">if</span> (memo.<span class="hljs-built_in">count</span>(tree) &amp;&amp; memo[tree] == <span class="hljs-number">1</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(root);<br>            memo[tree] = memo[tree] + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!memo[tree]) &#123;<br>            memo[tree] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tree;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的序列化">二叉树的序列化</h2><blockquote><ol start="297" type="1"><li>二叉树的序列化与反序列化</li></ol></blockquote><p><strong>使用Java</strong></p><blockquote><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 /反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode目前使用的方式一致，详情请参阅 <ahref="vscode-webview://158f0tu0bi5btl1al2do8fjqofsbp3m18hvj94kqe2d694ac5r1p/faq/#binary-tree">LeetCode序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p></blockquote><p>这里提供四种方法（两种思路：递归和迭代）</p><p>每种方法的序列化过程都十分的简单，关键在于反序列化过程。</p><p>1、【前序遍历】/【后序遍历】：按理说，将二叉树序列化后再变回二叉树，是还需要中序遍历数组的。但是在序列化的时候，将空指针的也加入序列化的过程，也就是说二叉树序列化后可以是包含空指针，有了空指针的位置，就可以只依靠前序遍历或后序遍历重构二叉树。而前序遍历和后序遍历的区别就在于根节点的位置不同。【而这里的递归思路和之前不一样】，之前是找到序列中表示左子树的部分进行递归，...</p><p>2、【层次遍历】：利用队列对二叉树进行按层次遍历</p><p>3、【递归定义】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm.tree.binaryTree;<br><br><span class="hljs-keyword">import</span> algorithm.tree.TreeNode;<br><span class="hljs-keyword">import</span> sun.font.TextRecord;<br><span class="hljs-keyword">import</span> sun.reflect.generics.tree.Tree;<br><br><span class="hljs-keyword">import</span> javax.naming.directory.SearchResult;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 二叉树的序列化</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Serialization</span> &#123;<br>    <br>    List&lt;String&gt; list;<br>    <br>    <span class="hljs-comment">// 前序遍历</span><br>    <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">preSerialize</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> preSerialize(root.left);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> preSerialize(root.right);<br>    <br>        <span class="hljs-keyword">return</span> root.val + <span class="hljs-string">&quot;,&quot;</span> + left + <span class="hljs-string">&quot;,&quot;</span> + right;<br>    &#125;<br>    <span class="hljs-comment">// 下面这个解法在某些情况下无法给出正确答案，虽然感觉它很正确</span><br>    <span class="hljs-comment">// 这里采用的递归思路是: 找到data中属于左子树和右子树的部分，再去递归</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    private TreeNode preDeserialize(String data)&#123;</span><br><span class="hljs-comment">        if(data == null || data.length() == 0) return null;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        char c = data.charAt(0);</span><br><span class="hljs-comment">        if(c == &#x27;#&#x27;) return null;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        // 前序排列的第一个就是根节点</span><br><span class="hljs-comment">        TreeNode root = new TreeNode(c - &#x27;0&#x27;);</span><br><span class="hljs-comment">        // 找到左子树的部分</span><br><span class="hljs-comment">        int left_tree_nodes = 1; // 无论root的左节点是空还是存在左子树 data[1]一定是属于左子树的</span><br><span class="hljs-comment">        int i = 1;</span><br><span class="hljs-comment">        while(left_tree_nodes &gt; 0 &amp;&amp; i &lt; data.length())&#123;</span><br><span class="hljs-comment">            if(data.charAt(i) != &#x27;#&#x27;)&#123; // 如果存在非空结点，左子树在data中的元素个数多2个</span><br><span class="hljs-comment">                left_tree_nodes += 2;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            left_tree_nodes--;</span><br><span class="hljs-comment">            i++;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        root.left = preDeserialize(data.substring(1, i));</span><br><span class="hljs-comment">        // 找到右子树的部分</span><br><span class="hljs-comment">        root.right = preDeserialize(data.substring(i));</span><br><span class="hljs-comment">        return root;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">preDeserialize</span><span class="hljs-params">(String data)</span>&#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(list, data.split(<span class="hljs-string">&quot;,&quot;</span>));<br>        <span class="hljs-keyword">return</span> preDeserializeHelper();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">preDeserializeHelper</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(list.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(rootVal.equals(<span class="hljs-string">&quot;#&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(rootVal));<br>        <br>        root.left = preDeserializeHelper();<br>        root.right = preDeserializeHelper();<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 后序遍历</span><br>    <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">postSerialize</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> postSerialize(root.left);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> postSerialize(root.right);<br>        <br>        <span class="hljs-keyword">return</span> left + <span class="hljs-string">&quot;,&quot;</span> + right + <span class="hljs-string">&quot;,&quot;</span> + root.val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">postDeserialize</span><span class="hljs-params">(String data)</span>&#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        String[] split = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> split.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            list.add(split[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> postDeserializeHelper();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">postDeserializeHelper</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(list.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(rootVal.equals(<span class="hljs-string">&quot;#&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(rootVal));<br>        <br>        root.right = postDeserializeHelper();<br>        root.left = postDeserializeHelper();<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 中序遍历</span><br>    <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">inSerialize</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>    <br>        <span class="hljs-type">String</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> postSerialize(root.left);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> postSerialize(root.right);<br>    <br>        <span class="hljs-keyword">return</span> left + <span class="hljs-string">&quot;,&quot;</span> + root.val + <span class="hljs-string">&quot;,&quot;</span> + right;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 无法进行反序列化</span><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">inDeserialize</span><span class="hljs-params">(String data)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用层级遍历</span><br>    <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">levelSerialize</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) sb.append(<span class="hljs-string">&quot;#&quot;</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                sb.append(node.val);<br>                queue.offer(node.left);<br>                queue.offer(node.right);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (!queue.isEmpty()) sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">levelDeserialize</span><span class="hljs-params">(String data)</span>&#123;<br>        <span class="hljs-keyword">if</span>(data.equals(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 存在一个问题: split空字符串的时候返回的数组长度为1</span><br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(list, data.split(<span class="hljs-string">&quot;,&quot;</span>));<br>        <span class="hljs-keyword">return</span> levelDeserializeHelper();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">levelDeserializeHelper</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(list.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(list.remove(<span class="hljs-number">0</span>))); <span class="hljs-comment">// 根节点</span><br>        <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <br>            <span class="hljs-type">String</span> <span class="hljs-variable">leftVal</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(leftVal.equals(<span class="hljs-string">&quot;#&quot;</span>))&#123;<br>                node.left = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(leftVal));<br>                queue.offer(node.left);<br>            &#125;<br>            <br>            <span class="hljs-type">String</span> <span class="hljs-variable">rightVal</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(rightVal.equals(<span class="hljs-string">&quot;#&quot;</span>))&#123;<br>                node.right = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(rightVal));<br>                queue.offer(node.right);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> levelSerialize(root);<br>    &#125;<br>    <br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">return</span> levelDeserialize(data);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>.split(<span class="hljs-string">&quot;,&quot;</span>).length);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;X&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(&quot;</span> + serialize(root.left) + <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(&quot;</span> + serialize(root.right) + <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-keyword">return</span> left + root.val + right;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-type">int</span>[] ptr = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">return</span> parse(data, ptr);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">parse</span><span class="hljs-params">(String data, <span class="hljs-type">int</span>[] ptr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data.charAt(ptr[<span class="hljs-number">0</span>]) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>            ++ptr[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>);<br>        cur.left = parseSubtree(data, ptr);<br>        cur.val = parseInt(data, ptr);<br>        cur.right = parseSubtree(data, ptr);<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">parseSubtree</span><span class="hljs-params">(String data, <span class="hljs-type">int</span>[] ptr)</span> &#123;<br>        ++ptr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 跳过左括号</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">subtree</span> <span class="hljs-operator">=</span> parse(data, ptr);<br>        ++ptr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 跳过右括号</span><br>        <span class="hljs-keyword">return</span> subtree;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseInt</span><span class="hljs-params">(String data, <span class="hljs-type">int</span>[] ptr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sgn = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!Character.isDigit(data.charAt(ptr[<span class="hljs-number">0</span>]))) &#123;<br>            sgn = -<span class="hljs-number">1</span>;<br>            ++ptr[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (Character.isDigit(data.charAt(ptr[<span class="hljs-number">0</span>]))) &#123;<br>            x = x * <span class="hljs-number">10</span> + data.charAt(ptr[<span class="hljs-number">0</span>]++) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x * sgn;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用后序遍历优化算法">利用后序遍历优化算法</h2><blockquote><p>二叉搜索子树的最大键值和 1373</p><p>给你一棵以 root 为根的 二叉树 ，请你返回 任意二叉搜索子树的最大键值和。</p></blockquote><p>【思路】</p><p>这道题无论是判断是否为BST，还是求树的键值和都需要用到左右子树的相关信息，而判断树是否为BST以及求树的键值和本身又是递归求解，一旦采用前序遍历的思想就是递归套递归，复杂度很高。原因就在于前面递归求过的到后面还得再递归再求一次，复杂度会达到指数级。、</p><p>而使用后序遍历的思想，可以在递归遍历的过程中直接拿到左右子树的相关信息，然后根据这些信息求出该树是否为BST以及键值和，依次向下求解，复杂度大大降低，只有线性复杂度。</p><p>还是要从大局看起，不要一开始就限于细节，应该再整体的递归布局想清楚后再考虑细节问题。否则不容易写出递归的解法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NOT_BST</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求二叉树中 键值和最大的二叉搜索子树</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSumBST</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> maxSumBSTHelper(root);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 根节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果是二叉树返回该树的键值和，如果不是则返回 NOT_BST</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSumBSTHelper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> maxSumBSTHelper(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxSumBSTHelper(root.right);<br>        <br>        <span class="hljs-keyword">if</span>(left != NOT_BST &amp;&amp; right != NOT_BST)&#123; <span class="hljs-comment">// 左右子树都是BST</span><br>            <span class="hljs-keyword">if</span>(isBST(root))&#123; <span class="hljs-comment">// 判断以root为根的树是否为BST</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> left + root.val + right;<br>                <span class="hljs-keyword">if</span>(tree &gt; maxSum) maxSum = tree;<br>                <span class="hljs-keyword">return</span> tree;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> NOT_BST;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 左子树或者右子树不是BST</span><br>            <span class="hljs-keyword">return</span> NOT_BST;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当该根节点的左右子树均为BST的前提下，判断以root为根的树是否为BST</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root 根节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否是BST</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBST</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">is_left_satisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">is_right_satisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <br>        <br>        <span class="hljs-comment">// 判断左子树是否满足条件</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>        <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; left.right != <span class="hljs-literal">null</span>)&#123;<br>            left = left.right;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> || left.val &lt; root.val) is_left_satisfied = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 判断右子树是否满足条件</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> root.right;<br>        <span class="hljs-keyword">while</span> (right != <span class="hljs-literal">null</span> &amp;&amp; right.left != <span class="hljs-literal">null</span>)&#123;<br>            right = right.left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">null</span> || right.val &gt; root.val) is_right_satisfied = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">return</span> is_left_satisfied &amp; is_right_satisfied;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结-2">总结</h2><h3 id="深入理解遍历方式">深入理解遍历方式</h3><h4 id="前中后序遍历">前中后序遍历</h4><p>一般我们求解二叉树的前中后序遍历的框架如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历框架</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">preTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">/* 处理 */</span><br>    <br>    preTraversal(root.left);<br>    preTraversal(root.right);<br>    <br>&#125;<br><br><span class="hljs-comment">// 中序遍历框架</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">inTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <br>    inTraversal(root.left);<br>    <br>    <span class="hljs-comment">/* 处理 */</span><br>    <br>    inTraversal(root.right);<br>    <br>&#125;<br><br><span class="hljs-comment">// 后序遍历框架</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">postTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <br>    postTraversal(root.left);<br>    postTraversal(root.right);<br>    <br>    <span class="hljs-comment">/* 处理 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>其实，用前中后序遍历的递归框架来解决问题，本质上就是【按照前中后序三种遍历顺序来处理每一个结点】，而利用这种框架来解决二叉树问题，只要考虑在每一个结点位置（<code>/* 处理 */</code>）应该编写怎样的逻辑。</p><h4 id="层次遍历">层次遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">levelTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <br>    Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    q.offer(root);<br>    <br>    <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> q.poll();<br>        <span class="hljs-comment">/* 处理 */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种解题思路">两种解题思路</h3><ul><li>遍历二叉树 =》 回溯算法思想</li><li>分解问题 =》 动态规划思想</li></ul><p>以【二叉树的最大深度】为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 分解问题: 将原问题分解为规模更小的子问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>    <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 遍历二叉树</span><br><span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth1</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    traversal(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 到达分支的最底部</span><br>        res = Math.max(res, depth);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    depth++; <span class="hljs-comment">// 进入子树，深度+1</span><br>    traversal(root.left);<br>    traversal(root.right);<br>    depth--; <span class="hljs-comment">// 回到根节点，深度-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的直径">【二叉树的直径】</h3><blockquote><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p></blockquote><p>利用后序遍历的递归方法，得到左右子树中距离子树根节点的最大距离，由此计算经过root结点的最大距离，并更新<code>diameter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历二叉树</span><br><span class="hljs-type">int</span> <span class="hljs-variable">diameter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    diameterOfBinaryTreeHelper(root);<br>    <span class="hljs-keyword">return</span> diameter;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param root 根节点</span><br><span class="hljs-comment"> * @return 该树距离根节点的最远距离</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTreeHelper</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> diameterOfBinaryTreeHelper(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> diameterOfBinaryTreeHelper(root.right);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">distance_cross_root</span> <span class="hljs-operator">=</span> left + right + <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max_distance_to_root</span> <span class="hljs-operator">=</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br><br>    diameter = Math.max(diameter, distance_cross_root);<br><br>    <span class="hljs-keyword">return</span> max_distance_to_root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记2-队列/栈</title>
      <link href="/2022/09/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B02%EF%BC%88%E9%98%9F%E5%88%97%E6%A0%88%EF%BC%89/"/>
      <url>/2022/09/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B02%EF%BC%88%E9%98%9F%E5%88%97%E6%A0%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="括号问题">括号问题</h2><blockquote><p>有效的括号 20</p><p>使括号有效的最小添加 921</p><p>平衡括号串的最小插入 1541</p></blockquote><ul><li>【有效括号】</li></ul><p>如果只判断一种括号，则不需要使用栈，通过一次遍历即可解决</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s)&#123;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            left ++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>)&#123;<br>            left --;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> left == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要同时判断三种括号是否正确：<code>() [] &#123;&#125;</code></p><p>使用上述方法就显得十分麻烦，应该利用栈结构的特性来解决</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_PUSH(x) (x == <span class="hljs-string">&#x27;(&#x27;</span> || x == <span class="hljs-string">&#x27;[&#x27;</span> || x == <span class="hljs-string">&#x27;&#123;&#x27;</span>)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_MATCH(x, y) \</span><br><span class="hljs-meta">    ((x == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; y == <span class="hljs-string">&#x27;)&#x27;</span>) || (x == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; y == <span class="hljs-string">&#x27;]&#x27;</span>) || (x == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; y == <span class="hljs-string">&#x27;&#125;&#x27;</span>))</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_PUSH</span>(c)) &#123; <span class="hljs-comment">// 左半括号，压栈</span><br>                stk.<span class="hljs-built_in">push</span>(c);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 缺少左半括号</span><br>                <span class="hljs-type">char</span> c1 = stk.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_MATCH</span>(c1, c)) &#123; <span class="hljs-comment">// 匹配</span><br>                    stk.<span class="hljs-built_in">pop</span>();<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 左右括号不匹配</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 如果栈不为空，缺少右半括号</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>【使括号有效的最小添加】</li></ul><p>由于只涉及一种括号，就不需要使用栈结构，通过一次遍历即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            left--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left + cnt;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【平衡括号串的最小插入】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 比较普通的解法</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minInsertions1</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rightInRow = <span class="hljs-number">0</span>; <span class="hljs-comment">// 连续右括号的数目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (rightInRow != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>                    cnt++;  <span class="hljs-comment">//增加一个右括号</span><br>                    left--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    cnt += <span class="hljs-number">2</span>;  <span class="hljs-comment">// 增加一个左括号和右括号</span><br>                &#125;<br>                rightInRow = <span class="hljs-number">0</span>;<br>            &#125;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rightInRow++;<br>            <span class="hljs-keyword">if</span> (rightInRow == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>)<br>                    left--;<br>                <span class="hljs-keyword">else</span><br>                    cnt++;  <span class="hljs-comment">// 增加一个左括号</span><br>                rightInRow = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (rightInRow != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 多余的右括号</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) &#123;<br>            cnt += <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left--;<br>            cnt++;<br>        &#125;<br>        rightInRow = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> left * <span class="hljs-number">2</span> + cnt;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 更加简洁的jie&#x27;fa</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minInsertions</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> need = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 当出现一个左括号时，其前的右括号数目应该为偶数，即need应该为偶数，若为奇数需要插入一个右括号</span><br>            <span class="hljs-keyword">if</span> (need % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                need--;<br>                cnt++;  <span class="hljs-comment">// 插入一个右括号</span><br>            &#125;<br>            need += <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            need--;<br>            <span class="hljs-keyword">if</span> (need == <span class="hljs-number">-1</span>) &#123;<br>                cnt++;  <span class="hljs-comment">// 插入一个左括号</span><br>                need =<br>                    <span class="hljs-number">1</span>;  <span class="hljs-comment">// 由于一个左括号需要两个右括号，所以还需要一个右括号</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt + need;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调栈">单调栈</h2><blockquote><p>单调栈实际上就是栈，只是通过简单的技巧使得其中元素的呈单调排列</p><p>可以很好解决【下一个更大元素】的问题</p><p>下一个更大元素Ⅰ 496</p><p>下一个更大元素Ⅱ 503</p><p>每日温度 739</p></blockquote><ul><li>【base case】</li></ul><blockquote><p>给定一个数组 nums 返回一个结果数组 res，res[i] 表示 nums[i]的下一个更大的元素，没有返回 -1</p></blockquote><p>[2, 1, 2, 4, 3]将每一个元素看成是相应高度的棍子。res[i]就是从nums[i]这根棍子向后所能看到的那个棍子的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size())</span></span>;<br>    <span class="hljs-comment">// 从后往前遍历，因为栈是后进先出，从后开始遍历，保证出栈的顺序是从前到后</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">// 如果栈不空 依次取出栈顶元素和当前元素比较</span><br>        <span class="hljs-comment">// 直到找到比当前元素大的那一个</span><br>        <span class="hljs-comment">// 【&lt;= 当前元素的可以从栈顶移除，因为当前元素前面的元素是看不见它们的】</span><br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() &lt;= nums[i])&#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        res[i] = stk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">push</span>(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【下一个更大元素Ⅰ】</li></ul><blockquote><p><code>nums1</code> 中数字 <code>x</code> 的<strong>下一个更大元素</strong> 是指 <code>x</code> 在<code>nums2</code> 中对应位置 <strong>右侧</strong> 的<strong>第一个</strong> 比 <code>x</code> 大的元素。</p></blockquote><p>这个问题更难了一些，因为是<code>nums1</code>中的<code>x</code>映射到<code>nums2</code>后的下一个更大元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">对nums2进行base case的处理，但是将结果存放在map中</span><br><span class="hljs-comment">对nums1进行遍历，根据map得到最终结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums1.size())</span></span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br><br>    <span class="hljs-comment">// 对nums2求每个元素的下一个更大元素</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() &lt;= nums2[i]) &#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        map[nums2[i]] = stk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : stk.<span class="hljs-built_in">top</span>();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            if (stk.empty()) &#123;</span><br><span class="hljs-comment">                map[nums2[i]] = -1;</span><br><span class="hljs-comment">            &#125; else &#123;</span><br><span class="hljs-comment">                while (!stk.empty() &amp;&amp; stk.top() &lt;= nums2[i]) &#123;</span><br><span class="hljs-comment">                    stk.pop();</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                if (stk.empty()) &#123;</span><br><span class="hljs-comment">                    map[nums2[i]] = -1;</span><br><span class="hljs-comment">                &#125; else &#123;</span><br><span class="hljs-comment">                    map[nums2[i]] = stk.top();</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        */</span><br>        stk.<span class="hljs-built_in">push</span>(nums2[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        res[i] = map[nums1[i]];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【每日温度】</li></ul><p>base case 的变式，res[i] 是 下一个最大元素 到 nums[i] 的距离</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 栈结构中存放的是 &lt;index, value&gt; 的pair</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>    <span class="hljs-comment">// &lt;pos, value&gt;</span><br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = temperatures.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>().second &lt;= temperatures[i]) &#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        res[i] = stk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">0</span> : stk.<span class="hljs-built_in">top</span>().first - i;<br>        stk.<span class="hljs-built_in">push</span>(&#123;i, temperatures[i]&#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 栈结构存放的index</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;  <span class="hljs-comment">// 存放索引</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = temperatures.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[stk.<span class="hljs-built_in">top</span>()] &lt;= temperatures[i]) &#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        res[i] = stk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">0</span> : stk.<span class="hljs-built_in">top</span>() - i;<br>        stk.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>【下一个更大元素Ⅱ】</li></ul><p>引入了<strong>环形数组</strong>，但是可以通过<strong>模运算</strong>来模拟环形数组的效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size())</span></span>;<br><br>    <span class="hljs-comment">// 利用单调栈时将数组长度翻倍，但是循环数组的效果是用模运算体现出来的</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> * nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> j = i % nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 对应的下标</span><br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() &lt;= nums[j]) &#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            res[i] = stk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : stk.<span class="hljs-built_in">top</span>();<br>        &#125;<br>        stk.<span class="hljs-built_in">push</span>(nums[j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><blockquote><p>滑动窗口最大值 239</p></blockquote><p>【题目】给你一个整数数组 <code>nums</code>，有一个大小为<code>k</code>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的<code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure></blockquote><p><font color='red'>最主要是利用了【双端队列】，或者说是利用可以在头部尾部增减元素的数据结构</font></p><p>难点在于：为什么窗口和队列中的元素可以不同步？</p><p><strong>队列中的元素x，是在 比它更大元素y插入时【注意y是在x后面的】被移出的</strong>。由于只是求窗口中的最大值，所以结果是不受影响的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size() - k + <span class="hljs-number">1</span>)</span></span>;<br>    deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>    <br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录队列中的元素个数</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">// 结果集的下标</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-comment">// 将队列中所有比 nums[i] 小的元素移出 =&gt; 使得队列中元素呈单调递减排列</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1、这样使得队列头部元素就是队列中最大元素，即窗口最大值</span><br><span class="hljs-comment">        2、为什么要移出，而不是让它们排列</span><br><span class="hljs-comment">        2.1、如果不将它们移出，只是排列，当窗口需要实际移出它们时就会变得困难</span><br><span class="hljs-comment">        2.2、而且在排列时就移出，不会对正确性产生影响，队列和窗口中的元素不是同时移出，</span><br><span class="hljs-comment">        会出现四种情况: 有两种是对应的，即窗口中和队列中都有某元素、都没有某元素  这两种肯定是正确的。另外两种:</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        2.2.1、窗口中有该元素，而队列中没有。队列中没有 说明该元素不是队列中最大元素，在比其更大的元素插入时被移出，</span><br><span class="hljs-comment">        还说明该元素在nums中的位置是先于比它更大的元素的，所以窗口也是更早将其移出的。</span><br><span class="hljs-comment">        由于只需要求窗口最大元素，所以没有影响</span><br><span class="hljs-comment">        2.2.2、窗口中没有某元素，而队列中有。</span><br><span class="hljs-comment">        如果该元素不是最大元素的话，同2.2.1 在窗口实际移除它之前，队列就已经把它给移出了，故不存在该情况</span><br><span class="hljs-comment">        如果该元素是最大元素的话，那么在窗口移出它的同时，队列会移出它，即代码29、30行所做，也不会存在该情况</span><br><span class="hljs-comment">        3、将元素从尾部取出比较的，这样才能保证是单调递减 =&gt; 所以需要双端队列</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">back</span>() &lt; nums[i])&#123;<br>            dq.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        dq.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        cnt++;<br>        <br>        <span class="hljs-comment">// 窗口元素满了</span><br>        <span class="hljs-keyword">if</span>(cnt == k)&#123;<br>            res[index++] = dq.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 最大元素就是队列头部元素</span><br>            <span class="hljs-comment">// 如果窗口需要移出的是最大元素，那队列就要移出该元素。</span><br>            <span class="hljs-comment">// 否则不需要，因为更早时候已经移出了</span><br>            <span class="hljs-keyword">if</span>(dq.<span class="hljs-built_in">front</span>() == nums[i - k + <span class="hljs-number">1</span>])&#123;<br>                dq.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            cnt --;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组去重">数组去重</h2><blockquote><p>去除重复字母 316</p><p>不同字符的最小子序列 1081</p></blockquote><p>给你一个字符串 <code>s</code>，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证<strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p><blockquote><p>例如</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bcabc&quot;</span><br>输出：<span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 利用栈结构</span><br><span class="hljs-function">string <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* cnts = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>]&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 记录字符串中每种字符的数量</span><br>    <span class="hljs-type">bool</span>* isInStk = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[<span class="hljs-number">26</span>]&#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">// 记录对应字符在栈中是否出现</span><br><br>    <span class="hljs-comment">// 统计字符串中每种字符的数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cnts[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br><br>    stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <br>        cnts[stk.<span class="hljs-built_in">top</span>() - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        <br>        <span class="hljs-keyword">if</span> (isInStk[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123; <span class="hljs-comment">// 栈中已经存在该字符</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp;<br>               stk.<span class="hljs-built_in">top</span>() &gt;= s[i] &amp;&amp; <span class="hljs-comment">// 前面的字符字典序更大</span><br>               cnts[stk.<span class="hljs-built_in">top</span>() - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 而且后面还存在该字符 就可以将该字符移除</span><br>            isInStk[stk.<span class="hljs-built_in">top</span>() - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">false</span>;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        stk.<span class="hljs-built_in">push</span>(s[i]);<br>        isInStk[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        ans += stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br><span class="hljs-comment">// 直接使用字符串</span><br><span class="hljs-function">string <span class="hljs-title">smallestSubsequence</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* cnts = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>]&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">bool</span>* isInStk = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[<span class="hljs-number">26</span>]&#123;<span class="hljs-literal">false</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cnts[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br><br>    string stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (isInStk[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>            cnts[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">back</span>() &gt;= s[i] &amp;&amp;<br>               cnts[stk.<span class="hljs-built_in">back</span>() - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">1</span>) &#123;<br>            isInStk[stk.<span class="hljs-built_in">back</span>() - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">false</span>;<br>            cnts[stk.<span class="hljs-built_in">back</span>() - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            stk.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        stk.<span class="hljs-built_in">push_back</span>(s[i]);<br>        isInStk[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> stk;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记5-二叉搜索树</title>
      <link href="/2022/09/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B05%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89/"/>
      <url>/2022/09/15/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B05%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一">（一）</h2><blockquote><p>230、二叉搜索树中第K小的元素</p><p>538、把二叉搜索树转换为累加树</p></blockquote><h3 id="二叉搜索树中第k小的元素">【二叉搜索树中第K小的元素】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历二叉树的方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>    kthSmallestTraversal(root, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kthSmallestTraversal</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    kthSmallestTraversal(root.left, k);<br>    rank++;<br>    <span class="hljs-keyword">if</span>(rank == k)&#123;<br>        res = root.val;<br>    &#125;<br>    kthSmallestTraversal(root.right, k);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="把二叉搜索树转换为累加树">【把二叉搜索树转换为累加树】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    convertBSTHelper(root);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 关键!! 使用一个外部变量来记录和 大大降低了复杂度</span><br><span class="hljs-comment">/* 特殊的中序遍历 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">convertBSTHelper</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    convertBSTHelper(root.right);<br>    root.val += sum;<br>    sum = root.val;<br>    convertBSTHelper(root.left);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二">（二）</h2><h3 id="判断bst的合法性">1、判断BST的合法性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 采用后序遍历的方式 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isValidBST(root.right);<br><br>    <span class="hljs-keyword">if</span>(left &amp;&amp; right)&#123; <span class="hljs-comment">// 左右子树都是二叉搜索树</span><br>        <span class="hljs-keyword">return</span> isValidBSTHelper(root);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//当左右子树都是二叉搜索树时，判断加上根后是否为二叉搜索树</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBSTHelper</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">is_left_satisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">is_right_satisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 左边是否满足情况</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left_max</span> <span class="hljs-operator">=</span> root.left;<br>    <span class="hljs-keyword">while</span> (left_max != <span class="hljs-literal">null</span> &amp;&amp; left_max.right != <span class="hljs-literal">null</span>)&#123;<br>        left_max = left_max.right;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left_max == <span class="hljs-literal">null</span> || left_max.val &lt; root.val)&#123;<br>        is_left_satisfied = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 右边是否满足情况</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right_min</span> <span class="hljs-operator">=</span> root.right;<br>    <span class="hljs-keyword">while</span> (right_min != <span class="hljs-literal">null</span> &amp;&amp; right_min.left != <span class="hljs-literal">null</span>)&#123;<br>        right_min = right_min.left;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(right_min == <span class="hljs-literal">null</span> || right_min.val &gt; root.val)&#123;<br>        is_right_satisfied = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> is_left_satisfied &amp; is_right_satisfied;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分解问题</span><br><span class="hljs-comment"> * 但是由于在原函数上不好直接分解，所以需要扩展函数参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">return</span> isValidBST1Helper(root, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBSTHelper</span><span class="hljs-params">(TreeNode root, TreeNode min, TreeNode max)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">if</span>( (min != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= min.val) ||<br>                (max != <span class="hljs-literal">null</span> &amp;&amp; root.val &gt;= max.val))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isValidBST1Helper(root.left, min, root) &amp;&amp;<br>                   isValidBST1Helper(root.right, root, max);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在bst中搜索元素">2、在BST中搜索元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(root.val == val) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; val) &#123;<br>        <span class="hljs-keyword">return</span> searchBST1(root.left, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> searchBST1(root.right, val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在bst中插入元素">3、在BST中插入元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>    <span class="hljs-keyword">if</span> (root.val &gt; val)&#123;<br>        root.left = insertIntoBST(root.left, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.right = insertIntoBST(root.right, val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在bst中删除元素">4、在BST中删除元素</h3><p>删除元素相对来说要复杂一些。</p><p>因为做递归的时候是将所有节点都当作根节点（一颗子树的根）来看的，所以如果需要删除，那么就要找到其左子树的最大结点或者右子树的最小结点来替换根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(root.val == key)&#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left_min</span> <span class="hljs-operator">=</span> root.left;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">min_parent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(left_min != <span class="hljs-literal">null</span> &amp;&amp; left_min.right != <span class="hljs-literal">null</span>)&#123;<br>            min_parent = left_min;<br>            left_min = left_min.right;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left_min == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 没有左子树</span><br>            <span class="hljs-keyword">return</span> root.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            * 这里是采用了交换两个结点的值来实现删除结点的交换</span><br><span class="hljs-comment">            * 也可以实际交换两个结点</span><br><span class="hljs-comment">            * */</span><br>            root.val = left_min.val;<br>            <span class="hljs-keyword">if</span>(min_parent == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 左子树的根节点就是最大，没有右节点</span><br>                root.left = left_min.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 右边没有结点，左边可能有</span><br>                min_parent.right = left_min.left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; key) &#123;<br>        root.left = deleteNode(root.left, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.right = deleteNode(root.right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">5、总结</h3><ul><li><p>BST 的框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(root.val == val)&#123;<br>        <span class="hljs-comment">// 具体操作</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; val)&#123;<br>        BST(root.left, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        BST(root.right, val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在解决递归问题时，如果发现在原函数上难以正确执行，可以考虑</p><ul><li>借助外部变量</li><li>借助另外一个函数，增加函数参数</li></ul></li></ul><h2 id="三">（三）</h2><blockquote><p>96、不同的二叉搜索树</p><p>95、不同的二叉搜索树 Ⅱ</p></blockquote><h3 id="二叉树数量">【二叉树数量】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归求解</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 其实就是n个数能形成多少个合法二叉搜索树: i, i+1, i+2, ... , i+n-1</span><br><span class="hljs-comment">* numTrees(n) = numTrees(j-1) + numTrees(n-j) 其中 j 在 [1,n] 之间</span><br><span class="hljs-comment">* */</span><br><span class="hljs-comment">// 递归 =&gt; 很慢 递归+循环 存在重叠的部分</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">// 分别以i为根节点</span><br>        sum += numTrees(i-<span class="hljs-number">1</span>) * numTrees(n-i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 迭代 动态规划 大大降低了时间复杂度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>    tmp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; tmp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>            tmp[i] += (tmp[j-<span class="hljs-number">1</span>] * tmp[i-j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生成二叉树">【生成二叉树】</h3><blockquote><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code>个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同<strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong>返回答案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> generateTree(<span class="hljs-number">1</span>, n);<br>&#125;<br><br><span class="hljs-keyword">private</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generateTree</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> h)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt; h)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    List&lt;TreeNode&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= h; i++)&#123;<br><br>        List&lt;TreeNode&gt; lefts = generateTree(l, i-<span class="hljs-number">1</span>);<br>        List&lt;TreeNode&gt; rights = generateTree(i+<span class="hljs-number">1</span>, h);<br><br><br>        <span class="hljs-keyword">for</span>(TreeNode left : lefts)&#123;<br>            <span class="hljs-keyword">for</span> (TreeNode right : rights) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);<br>                root.left = left;<br>                root.right = right;<br>                res.add(root);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 动态规划 不如递归优雅 而且 优化不了多少</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记3-设计数据结构</title>
      <link href="/2022/09/07/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B03%EF%BC%88%E8%AE%BE%E8%AE%A1%EF%BC%89/"/>
      <url>/2022/09/07/leetcode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B03%EF%BC%88%E8%AE%BE%E8%AE%A1%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="lru">1 LRU</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=146 lang=cpp</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [146] LRU 缓存</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 该数据结构需要满足满足的要求:</span><br><span class="hljs-comment"> * 1、get方法需要根据key值快速获取到value =&gt; 哈希表</span><br><span class="hljs-comment"> * 2、数据结构中 key-value 需要按照是使用时间排序 =&gt;</span><br><span class="hljs-comment"> * 这样可以在需要逐出最久没使用的关键字时直接移除最头部或最尾部元素</span><br><span class="hljs-comment"> * 3、get或者put的 key 后，需要改变其位置，因为其是最近被使用的关键字</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 哈希 + shua链表</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><br><span class="hljs-comment">// 链表结点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> key&#123;<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> value&#123;<span class="hljs-number">-1</span>&#125;;<br>    Node* next&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    Node* prev&#123;<span class="hljs-literal">nullptr</span>&#125;;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;key = key;<br>        <span class="hljs-keyword">this</span>-&gt;value = value;<br>    &#125;<br>    <span class="hljs-built_in">Node</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 双向链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span> &#123;<br>   <span class="hljs-keyword">private</span>:<br>    Node *head, *tail;<br>    <span class="hljs-type">int</span> size;<br><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DoubleLinkedList</span>() &#123;<br>        size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* n)</span> </span>&#123;  <span class="hljs-comment">// 从链表中删除一个结点</span><br>        n-&gt;prev-&gt;next = n-&gt;next;<br>        n-&gt;next-&gt;prev = n-&gt;prev;<br>        n-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        n-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addInLast</span><span class="hljs-params">(Node* n)</span> </span>&#123;  <span class="hljs-comment">// 把一个结点插在尾部</span><br>        tail-&gt;prev-&gt;next = n;<br>        n-&gt;prev = tail-&gt;prev;<br>        tail-&gt;prev = n;<br>        n-&gt;next = tail;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否在某个容量内</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isWithinCap</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> </span>&#123; <span class="hljs-keyword">return</span> size &lt; capacity; &#125;<br><br>    <span class="hljs-comment">// 返回第一个元素</span><br>    <span class="hljs-function">Node* <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// LRUcache类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>   <span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; um;  <span class="hljs-comment">// 哈希表</span><br>    DoubleLinkedList list;         <span class="hljs-comment">// 双向链表</span><br>    <span class="hljs-type">int</span> _cap;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;  <span class="hljs-comment">// 把某个关键字变成最近使用</span><br>        Node* p = um[key];<br>        list.<span class="hljs-built_in">remove</span>(p);<br>        list.<span class="hljs-built_in">addInLast</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeLeastRecentlyUsed</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 逐出最不常使用的关键字</span><br>        Node* p = list.<span class="hljs-built_in">first</span>();<br>        list.<span class="hljs-built_in">remove</span>(p);<br>        um.<span class="hljs-built_in">erase</span>(p-&gt;key);<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123; _cap = capacity; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!um.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-built_in">makeRecently</span>(key);<br>        <span class="hljs-keyword">return</span> um[key]-&gt;value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 已经存在</span><br>        <span class="hljs-keyword">if</span> (um.<span class="hljs-built_in">count</span>(key)) &#123;<br>            um[key]-&gt;value = value;  <span class="hljs-comment">// 更新值</span><br>            <span class="hljs-built_in">makeRecently</span>(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不存在，需要插入</span><br>        <span class="hljs-keyword">if</span> (!list.<span class="hljs-built_in">isWithinCap</span>(_cap)) &#123;  <span class="hljs-comment">// 满了</span><br>            <span class="hljs-built_in">removeLeastRecentlyUsed</span>();<br>        &#125;<br>        <span class="hljs-comment">// 加在尾部</span><br>        Node* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>        list.<span class="hljs-built_in">addInLast</span>(n);<br>        um[key] = n;  <span class="hljs-comment">// 加在map中</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// @lc code=end</span><br><br></code></pre></td></tr></table></figure><h2 id="lfu">2 LFU</h2><p><code>lfu</code> 算法的难度更大，其要求如下：</p><p>1、使用<code>get</code>函数根据<code>key</code>得到<code>value</code>，时间复杂度为<code>O(1)</code></p><p>2、<code>put</code>函数（需要<code>O(1)</code>时间复杂度）</p><p>​2.1、如果<code>key</code>已经存在，那么修改对应的<code>value</code></p><p>​2.2、如果容量够，那么插入一个<code>key-value</code>，且其使用频率（<code>freq</code>）为1</p><p>​2.3、如果容量不够，那么逐出使用频率最少的一个<code>key-value</code>，如果存在多个使用频率最少的<code>key-value</code>，那么逐出最近最不常使用的那一个</p><p>3、所有<code>key-value</code>在被访问后其使用频率<code>freq</code>都应该加一</p><p>分析：</p><p>很明显，需要<code>O(1)</code>的时间复杂度，肯定还是离不开【哈希表】和【链表】</p><p>对上面的要求来逐个分析</p><p>1和3、建立一个 <code>key</code> 到 <code>value</code> 和<code>freq</code> 的哈希映射（<font color='red'>建立key到Node的哈希映射</font>）</p><p>2.1、建立和哈希映射之后可以很好解决</p><p>2.2、建立一个新的key-Node映射即可</p><p>2.3、存在两层的排序【使用频率】和【使用时间】。其中【使用时间】其实就是<code>lru</code>算法中的排序，使用双向链表即可解决。但是注意，是先根据使用【频率排序】，当使用【频率相同】的情况下再根据【使用时间】排序，所以应该是一个freq值对应这一个双向链表，这个双向链表记录【使用时间】的远近，所以再建立一个freq到双向链表的映射，就可以很好解决这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 双向链表的结点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> key&#123;<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> val&#123;<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> freq&#123;<span class="hljs-number">-1</span>&#125;;<br>    Node* next&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    Node* prev&#123;<span class="hljs-literal">nullptr</span>&#125;;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> f) &#123;<br>        key = k;<br>        val = v;<br>        freq = f;<br>    &#125;<br><br>    <span class="hljs-built_in">Node</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    Node *head, *tail;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-built_in">DoubleLinkedList</span>() &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* n)</span> </span>&#123;  <span class="hljs-comment">// 从链表中删除一个结点</span><br>        n-&gt;prev-&gt;next = n-&gt;next;<br>        n-&gt;next-&gt;prev = n-&gt;prev;<br>        n-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        n-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addInLast</span><span class="hljs-params">(Node* n)</span> </span>&#123;  <span class="hljs-comment">// 把一个结点插在尾部</span><br>        tail-&gt;prev-&gt;next = n;<br>        n-&gt;prev = tail-&gt;prev;<br>        tail-&gt;prev = n;<br>        n-&gt;next = tail;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-function">Node* <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 返回第一个结点</span><br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">// 判断是否为空</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>   <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 建立key-&gt;Node的映射，因为Node中包含了value和freq等信息，这样可以直接通过key获取到</span><br>    <span class="hljs-comment">// Node也是DoubleLinkedList的结点，这样建立映射就可以使得两个map之间关联起来了</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; keyTonode;<br>    unordered_map&lt;<span class="hljs-type">int</span>, DoubleLinkedList&gt; freqTokeys;<br>    <span class="hljs-type">int</span> _cap;<br>    <span class="hljs-type">int</span> minFreq; <span class="hljs-comment">// 记录最小的freq</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;  <span class="hljs-comment">// 将key对应的Node从相应freq对应的双向链表中移除</span><br>        Node* n = keyTonode[key];<br>        freqTokeys[n-&gt;freq].<span class="hljs-built_in">remove</span>(n);<br>        <span class="hljs-comment">// 判断更新minFreq</span><br>        <span class="hljs-keyword">if</span> (n-&gt;freq == minFreq &amp;&amp; freqTokeys[n-&gt;freq].<span class="hljs-built_in">empty</span>()) &#123;<br>            minFreq++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increaseFreq</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;  <span class="hljs-comment">// 增加key对应的freq，并且将其插入到对应的双向链表中</span><br>        Node* n = keyTonode[key];<br>        n-&gt;freq++;<br>        <span class="hljs-type">int</span> freq = n-&gt;freq;<br>        <span class="hljs-keyword">if</span> (freqTokeys.<span class="hljs-built_in">count</span>(freq) == <span class="hljs-number">0</span>) &#123;<br>            DoubleLinkedList dl;<br>            freqTokeys[freq] = dl;<br>        &#125;<br>        freqTokeys[freq].<span class="hljs-built_in">addInLast</span>(n);<br>    &#125;<br><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> capacity) &#123; _cap = capacity; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (keyTonode.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-built_in">remove</span>(key);<br>        <span class="hljs-built_in">increaseFreq</span>(key);<br>        <span class="hljs-keyword">return</span> keyTonode[key]-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 存在key</span><br>        <span class="hljs-keyword">if</span> (keyTonode.<span class="hljs-built_in">count</span>(key)) &#123;<br>            keyTonode[key]-&gt;val = value;<br>            <span class="hljs-built_in">remove</span>(key);<br>            <span class="hljs-built_in">increaseFreq</span>(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (_cap == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 不存在key</span><br>        <span class="hljs-keyword">if</span> (keyTonode.<span class="hljs-built_in">size</span>() == _cap) &#123;  <span class="hljs-comment">// 容量不足</span><br>            Node* node = freqTokeys[minFreq].<span class="hljs-built_in">first</span>();<br>            keyTonode.<span class="hljs-built_in">erase</span>(node-&gt;key);<br>            freqTokeys[minFreq].<span class="hljs-built_in">remove</span>(node);<br>            <span class="hljs-keyword">delete</span> node;<br>        &#125;<br>        Node* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value, <span class="hljs-number">0</span>);<br>        keyTonode[key] = n;<br>        <span class="hljs-built_in">increaseFreq</span>(key);<br>        minFreq = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="常数时间查找删除数组元素">3 常数时间查找/删除数组元素</h2><blockquote><p>常数时间插入、删除和获取随机元素 380</p><p>黑名单中的随机数 710</p></blockquote><p>【要求】</p><p>实现<code>RandomizedSet</code> 类：</p><ul><li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code>对象</li><li><code>bool insert(int val)</code> 当元素 <code>val</code>不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回<code>false</code> 。</li><li><code>bool remove(int val)</code> 当元素 <code>val</code>存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回<code>false</code> 。</li><li><code>int getRandom()</code>随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有<strong>相同的概率</strong> 被返回。</li></ul><p>你必须实现类的所有函数，并满足每个函数的 <strong>平均</strong>时间复杂度为 <code>O(1)</code> 。</p><p>分析：</p><p>1、需要判断<code>val</code>是否存在，肯定要用到哈希表</p><p>2、<code>getRandom</code>函数：生成一个随机数，返回该随机数为下标的数组元素</p><p>3、<code>remove</code>函数的实现需要一些技巧：将需要<code>remove</code>的元素和最后一个元素换位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; valToidx;<br><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RandomizedSet</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (valToidx.<span class="hljs-built_in">count</span>(val) == <span class="hljs-number">0</span>) &#123;<br>            arr.<span class="hljs-built_in">push_back</span>(val);<br>            valToidx[val] = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    存在的问题是：直接从数组中间earse掉的话，会影响后面元素的下标，即map中对应的下标就失效了</span><br><span class="hljs-comment">        bool remove1(int val) &#123;</span><br><span class="hljs-comment">            if (valToidx.count(val) == 1) &#123;</span><br><span class="hljs-comment">                int idx = valToidx[val];</span><br><span class="hljs-comment">                arr.erase(arr.begin() + idx);</span><br><span class="hljs-comment">                valToidx.erase(val);</span><br><span class="hljs-comment">                return true;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            return false;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 将需要pop的元素和数组末尾的元素换个位置就可以很好解决了</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (valToidx.<span class="hljs-built_in">count</span>(val) == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> idx = valToidx[val];<br>            <span class="hljs-type">int</span> lastIdx = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> lastVal = arr[lastIdx];<br>            <span class="hljs-comment">// swap</span><br>            arr[idx] = lastVal;<br>            arr[lastIdx] = val;<br>            <span class="hljs-comment">// update map</span><br>            valToidx[val] = lastIdx;<br>            valToidx[lastVal] = idx;<br><br>            arr.<span class="hljs-built_in">pop_back</span>();<br>            valToidx.<span class="hljs-built_in">erase</span>(val);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">rand</span>() % arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> arr[idx];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>【要求】</p><p>给定一个整数 <code>n</code> 和一个 <strong>无重复</strong>黑名单整数数组 <code>blacklist</code> 。设计一种算法，从<code>[0, n - 1]</code> 范围内的任意整数中选取一个<strong>未加入</strong> 黑名单 <code>blacklist</code>的整数。任何在上述范围内且不在黑名单 <code>blacklist</code>中的整数都应该有 <strong>同等的可能性</strong> 被返回。</p><p>优化你的算法，使它最小化调用语言 <strong>内置</strong>随机函数的次数。</p><p>实现 <code>Solution</code> 类:</p><ul><li><code>Solution(int n, int[] blacklist)</code> 初始化整数<code>n</code> 和被加入黑名单 <code>blacklist</code> 的整数</li><li><code>int pick()</code> 返回一个范围为 <code>[0, n - 1]</code>且不在黑名单 <code>blacklist</code> 中的随机整数</li></ul><p>【分析】</p><p>1、如果使用一般的思路，将<code>[0,n-1]</code>中的元素除去<code>blacklist</code>中的放到数组里，然后再生成随机数返回。这样会出现超时（时间复杂度为<code>O(n)</code>，而<code>n</code>比较大）</p><p>2、可以把<code>[0,n-1]</code>想象成一个下标和值对应的数组（实际不存在），我们将所有<code>blacklist</code>中的元素全部移到数组末尾，然后再根据实际的长度生成随机数返回即可。</p><p>3、<strong>难点在于</strong>：如何正确地将所有<code>blacklist</code>元素移到数组末尾（注意数组并不真实存在）</p><p>​ 3.1、已经在数组末尾的元素不用移动</p><p>​3.2、<code>blacklist</code>中的一个元素映射到另一个元素时怎么处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mapping; <span class="hljs-comment">// 处理&quot;移动&quot;: tong&#x27;g将blacklist中的元素映射到相应位置</span><br>    <span class="hljs-type">int</span> sz;<br><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; blacklist) &#123;<br>        sz = n - blacklist.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> last = n - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 先将所有blacklist中的值加入到哈希表中，方便后续的判断</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : blacklist) &#123;<br>            mapping[i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; blacklist.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (blacklist[i] &gt;= sz) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 元素本身就在数组末尾</span><br>            <span class="hljs-keyword">while</span> (mapping.<span class="hljs-built_in">count</span>(last)) &#123; <span class="hljs-comment">// blacklist中的元素映射到了另一个元素，last就要变小</span><br>                last--;<br>            &#125;<br>            mapping[blacklist[i]] = last;<br>            last--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pick</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">rand</span>() % sz;<br>        <span class="hljs-keyword">if</span> (mapping.<span class="hljs-built_in">count</span>(idx)) &#123;<br>            <span class="hljs-keyword">return</span> mapping[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> idx;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="求中位数">4 求中位数</h2><blockquote><p>数据流的中位数 295</p></blockquote><p>【要求】</p><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p>使用两个优先队列：一个大顶堆、一个小顶堆</p><p>相当于将一个数组在中间分成两部分，这样通过两个堆的堆顶元素就可以求出中位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; small;                <span class="hljs-comment">// 大顶堆</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; large;  <span class="hljs-comment">// 小顶堆</span><br><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MedianFinder</span>() &#123;&#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        满足两个条件</span><br><span class="hljs-comment">        1、small和large的大小最多相差一</span><br><span class="hljs-comment">        2、small.top() &lt;= large.top()</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (small.<span class="hljs-built_in">size</span>() &gt;= large.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-comment">// 插入large</span><br>            small.<span class="hljs-built_in">push</span>(num);<br>            large.<span class="hljs-built_in">push</span>(small.<span class="hljs-built_in">top</span>());<br>            small.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 插入samll</span><br>            large.<span class="hljs-built_in">push</span>(num);<br>            small.<span class="hljs-built_in">push</span>(large.<span class="hljs-built_in">top</span>());<br>            large.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (small.<span class="hljs-built_in">size</span>() == large.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> (small.<span class="hljs-built_in">top</span>() + large.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (small.<span class="hljs-built_in">size</span>() &gt; large.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> small.<span class="hljs-built_in">top</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> large.<span class="hljs-built_in">top</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
